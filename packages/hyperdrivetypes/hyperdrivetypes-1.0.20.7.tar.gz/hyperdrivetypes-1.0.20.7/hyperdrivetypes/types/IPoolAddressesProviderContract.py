"""A web3.py Contract class for the IPoolAddressesProvider contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.43.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overriden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long


from __future__ import annotations

from typing import Any, Iterable, Sequence, Type, cast

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    combomethod_typed,
    dataclass_to_tuple,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunction,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from .IPoolAddressesProviderTypes import (
    ACLAdminUpdatedEvent,
    ACLManagerUpdatedEvent,
    AddressSetAsProxyEvent,
    AddressSetEvent,
    MarketIdSetEvent,
    PoolConfiguratorUpdatedEvent,
    PoolDataProviderUpdatedEvent,
    PoolUpdatedEvent,
    PriceOracleSentinelUpdatedEvent,
    PriceOracleUpdatedEvent,
    ProxyCreatedEvent,
)

structs = {}


class IPoolAddressesProviderGetACLAdminContractFunction(ContractFunction):
    """ContractFunction for the getACLAdmin method."""

    def __call__(self) -> IPoolAddressesProviderGetACLAdminContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolAddressesProviderGetACLManagerContractFunction(ContractFunction):
    """ContractFunction for the getACLManager method."""

    def __call__(self) -> IPoolAddressesProviderGetACLManagerContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolAddressesProviderGetAddressContractFunction(ContractFunction):
    """ContractFunction for the getAddress method."""

    def __call__(self, _id: bytes) -> IPoolAddressesProviderGetAddressContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(_id))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolAddressesProviderGetMarketIdContractFunction(ContractFunction):
    """ContractFunction for the getMarketId method."""

    def __call__(self) -> IPoolAddressesProviderGetMarketIdContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolAddressesProviderGetPoolContractFunction(ContractFunction):
    """ContractFunction for the getPool method."""

    def __call__(self) -> IPoolAddressesProviderGetPoolContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolAddressesProviderGetPoolConfiguratorContractFunction(
    ContractFunction
):
    """ContractFunction for the getPoolConfigurator method."""

    def __call__(self) -> IPoolAddressesProviderGetPoolConfiguratorContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolAddressesProviderGetPoolDataProviderContractFunction(
    ContractFunction
):
    """ContractFunction for the getPoolDataProvider method."""

    def __call__(self) -> IPoolAddressesProviderGetPoolDataProviderContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolAddressesProviderGetPriceOracleContractFunction(ContractFunction):
    """ContractFunction for the getPriceOracle method."""

    def __call__(self) -> IPoolAddressesProviderGetPriceOracleContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolAddressesProviderGetPriceOracleSentinelContractFunction(
    ContractFunction
):
    """ContractFunction for the getPriceOracleSentinel method."""

    def __call__(self) -> IPoolAddressesProviderGetPriceOracleSentinelContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolAddressesProviderSetACLAdminContractFunction(ContractFunction):
    """ContractFunction for the setACLAdmin method."""

    def __call__(self, newAclAdmin: str) -> IPoolAddressesProviderSetACLAdminContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(newAclAdmin))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolAddressesProviderSetACLManagerContractFunction(ContractFunction):
    """ContractFunction for the setACLManager method."""

    def __call__(self, newAclManager: str) -> IPoolAddressesProviderSetACLManagerContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(newAclManager))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolAddressesProviderSetAddressContractFunction(ContractFunction):
    """ContractFunction for the setAddress method."""

    def __call__(self, _id: bytes, newAddress: str) -> IPoolAddressesProviderSetAddressContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(_id), dataclass_to_tuple(newAddress)
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolAddressesProviderSetAddressAsProxyContractFunction(ContractFunction):
    """ContractFunction for the setAddressAsProxy method."""

    def __call__(self, _id: bytes, newImplementationAddress: str) -> IPoolAddressesProviderSetAddressAsProxyContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(_id),
            dataclass_to_tuple(newImplementationAddress),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolAddressesProviderSetMarketIdContractFunction(ContractFunction):
    """ContractFunction for the setMarketId method."""

    def __call__(self, newMarketId: str) -> IPoolAddressesProviderSetMarketIdContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(newMarketId))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolAddressesProviderSetPoolConfiguratorImplContractFunction(
    ContractFunction
):
    """ContractFunction for the setPoolConfiguratorImpl method."""

    def __call__(self, newPoolConfiguratorImpl: str) -> IPoolAddressesProviderSetPoolConfiguratorImplContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(newPoolConfiguratorImpl))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolAddressesProviderSetPoolDataProviderContractFunction(
    ContractFunction
):
    """ContractFunction for the setPoolDataProvider method."""

    def __call__(self, newDataProvider: str) -> IPoolAddressesProviderSetPoolDataProviderContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(newDataProvider))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolAddressesProviderSetPoolImplContractFunction(ContractFunction):
    """ContractFunction for the setPoolImpl method."""

    def __call__(self, newPoolImpl: str) -> IPoolAddressesProviderSetPoolImplContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(newPoolImpl))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolAddressesProviderSetPriceOracleContractFunction(ContractFunction):
    """ContractFunction for the setPriceOracle method."""

    def __call__(self, newPriceOracle: str) -> IPoolAddressesProviderSetPriceOracleContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(newPriceOracle))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolAddressesProviderSetPriceOracleSentinelContractFunction(
    ContractFunction
):
    """ContractFunction for the setPriceOracleSentinel method."""

    def __call__(self, newPriceOracleSentinel: str) -> IPoolAddressesProviderSetPriceOracleSentinelContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(newPriceOracleSentinel))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolAddressesProviderContractFunctions(ContractFunctions):
    """ContractFunctions for the IPoolAddressesProvider contract."""

    getACLAdmin: IPoolAddressesProviderGetACLAdminContractFunction

    getACLManager: IPoolAddressesProviderGetACLManagerContractFunction

    getAddress: IPoolAddressesProviderGetAddressContractFunction

    getMarketId: IPoolAddressesProviderGetMarketIdContractFunction

    getPool: IPoolAddressesProviderGetPoolContractFunction

    getPoolConfigurator: (
        IPoolAddressesProviderGetPoolConfiguratorContractFunction
    )

    getPoolDataProvider: (
        IPoolAddressesProviderGetPoolDataProviderContractFunction
    )

    getPriceOracle: IPoolAddressesProviderGetPriceOracleContractFunction

    getPriceOracleSentinel: (
        IPoolAddressesProviderGetPriceOracleSentinelContractFunction
    )

    setACLAdmin: IPoolAddressesProviderSetACLAdminContractFunction

    setACLManager: IPoolAddressesProviderSetACLManagerContractFunction

    setAddress: IPoolAddressesProviderSetAddressContractFunction

    setAddressAsProxy: IPoolAddressesProviderSetAddressAsProxyContractFunction

    setMarketId: IPoolAddressesProviderSetMarketIdContractFunction

    setPoolConfiguratorImpl: (
        IPoolAddressesProviderSetPoolConfiguratorImplContractFunction
    )

    setPoolDataProvider: (
        IPoolAddressesProviderSetPoolDataProviderContractFunction
    )

    setPoolImpl: IPoolAddressesProviderSetPoolImplContractFunction

    setPriceOracle: IPoolAddressesProviderSetPriceOracleContractFunction

    setPriceOracleSentinel: (
        IPoolAddressesProviderSetPriceOracleSentinelContractFunction
    )

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.getACLAdmin = (
            IPoolAddressesProviderGetACLAdminContractFunction.factory(
                "getACLAdmin",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getACLAdmin",
            )
        )
        self.getACLManager = (
            IPoolAddressesProviderGetACLManagerContractFunction.factory(
                "getACLManager",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getACLManager",
            )
        )
        self.getAddress = (
            IPoolAddressesProviderGetAddressContractFunction.factory(
                "getAddress",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getAddress",
            )
        )
        self.getMarketId = (
            IPoolAddressesProviderGetMarketIdContractFunction.factory(
                "getMarketId",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getMarketId",
            )
        )
        self.getPool = IPoolAddressesProviderGetPoolContractFunction.factory(
            "getPool",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getPool",
        )
        self.getPoolConfigurator = (
            IPoolAddressesProviderGetPoolConfiguratorContractFunction.factory(
                "getPoolConfigurator",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getPoolConfigurator",
            )
        )
        self.getPoolDataProvider = (
            IPoolAddressesProviderGetPoolDataProviderContractFunction.factory(
                "getPoolDataProvider",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getPoolDataProvider",
            )
        )
        self.getPriceOracle = (
            IPoolAddressesProviderGetPriceOracleContractFunction.factory(
                "getPriceOracle",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getPriceOracle",
            )
        )
        self.getPriceOracleSentinel = IPoolAddressesProviderGetPriceOracleSentinelContractFunction.factory(
            "getPriceOracleSentinel",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getPriceOracleSentinel",
        )
        self.setACLAdmin = (
            IPoolAddressesProviderSetACLAdminContractFunction.factory(
                "setACLAdmin",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setACLAdmin",
            )
        )
        self.setACLManager = (
            IPoolAddressesProviderSetACLManagerContractFunction.factory(
                "setACLManager",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setACLManager",
            )
        )
        self.setAddress = (
            IPoolAddressesProviderSetAddressContractFunction.factory(
                "setAddress",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setAddress",
            )
        )
        self.setAddressAsProxy = (
            IPoolAddressesProviderSetAddressAsProxyContractFunction.factory(
                "setAddressAsProxy",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setAddressAsProxy",
            )
        )
        self.setMarketId = (
            IPoolAddressesProviderSetMarketIdContractFunction.factory(
                "setMarketId",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setMarketId",
            )
        )
        self.setPoolConfiguratorImpl = IPoolAddressesProviderSetPoolConfiguratorImplContractFunction.factory(
            "setPoolConfiguratorImpl",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setPoolConfiguratorImpl",
        )
        self.setPoolDataProvider = (
            IPoolAddressesProviderSetPoolDataProviderContractFunction.factory(
                "setPoolDataProvider",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setPoolDataProvider",
            )
        )
        self.setPoolImpl = (
            IPoolAddressesProviderSetPoolImplContractFunction.factory(
                "setPoolImpl",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setPoolImpl",
            )
        )
        self.setPriceOracle = (
            IPoolAddressesProviderSetPriceOracleContractFunction.factory(
                "setPriceOracle",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setPriceOracle",
            )
        )
        self.setPriceOracleSentinel = IPoolAddressesProviderSetPriceOracleSentinelContractFunction.factory(
            "setPriceOracleSentinel",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setPriceOracleSentinel",
        )


class IPoolAddressesProviderACLAdminUpdatedContractEvent(ContractEvent):
    """ContractEvent for ACLAdminUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ACLAdminUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ACLAdminUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ACLAdminUpdatedEvent.ACLAdminUpdatedEventArgs(
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ACLAdminUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ACLAdminUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ACLAdminUpdatedEvent.ACLAdminUpdatedEventArgs(
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolAddressesProviderACLManagerUpdatedContractEvent(ContractEvent):
    """ContractEvent for ACLManagerUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ACLManagerUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ACLManagerUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ACLManagerUpdatedEvent.ACLManagerUpdatedEventArgs(
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ACLManagerUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ACLManagerUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ACLManagerUpdatedEvent.ACLManagerUpdatedEventArgs(
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolAddressesProviderAddressSetContractEvent(ContractEvent):
    """ContractEvent for AddressSet."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[AddressSetEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AddressSetEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AddressSetEvent.AddressSetEventArgs(
                    _id=abi_event.args["_id"],
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[AddressSetEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AddressSetEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AddressSetEvent.AddressSetEventArgs(
                    _id=abi_event.args["_id"],
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolAddressesProviderAddressSetAsProxyContractEvent(ContractEvent):
    """ContractEvent for AddressSetAsProxy."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[AddressSetAsProxyEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AddressSetAsProxyEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AddressSetAsProxyEvent.AddressSetAsProxyEventArgs(
                    _id=abi_event.args["_id"],
                    proxyAddress=abi_event.args["proxyAddress"],
                    oldImplementationAddress=abi_event.args[
                        "oldImplementationAddress"
                    ],
                    newImplementationAddress=abi_event.args[
                        "newImplementationAddress"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[AddressSetAsProxyEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AddressSetAsProxyEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AddressSetAsProxyEvent.AddressSetAsProxyEventArgs(
                    _id=abi_event.args["_id"],
                    proxyAddress=abi_event.args["proxyAddress"],
                    oldImplementationAddress=abi_event.args[
                        "oldImplementationAddress"
                    ],
                    newImplementationAddress=abi_event.args[
                        "newImplementationAddress"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolAddressesProviderMarketIdSetContractEvent(ContractEvent):
    """ContractEvent for MarketIdSet."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MarketIdSetEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MarketIdSetEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MarketIdSetEvent.MarketIdSetEventArgs(
                    oldMarketId=abi_event.args["oldMarketId"],
                    newMarketId=abi_event.args["newMarketId"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MarketIdSetEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MarketIdSetEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MarketIdSetEvent.MarketIdSetEventArgs(
                    oldMarketId=abi_event.args["oldMarketId"],
                    newMarketId=abi_event.args["newMarketId"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolAddressesProviderPoolConfiguratorUpdatedContractEvent(ContractEvent):
    """ContractEvent for PoolConfiguratorUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[PoolConfiguratorUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PoolConfiguratorUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PoolConfiguratorUpdatedEvent.PoolConfiguratorUpdatedEventArgs(
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[PoolConfiguratorUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PoolConfiguratorUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PoolConfiguratorUpdatedEvent.PoolConfiguratorUpdatedEventArgs(
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolAddressesProviderPoolDataProviderUpdatedContractEvent(ContractEvent):
    """ContractEvent for PoolDataProviderUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[PoolDataProviderUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PoolDataProviderUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PoolDataProviderUpdatedEvent.PoolDataProviderUpdatedEventArgs(
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[PoolDataProviderUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PoolDataProviderUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PoolDataProviderUpdatedEvent.PoolDataProviderUpdatedEventArgs(
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolAddressesProviderPoolUpdatedContractEvent(ContractEvent):
    """ContractEvent for PoolUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[PoolUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PoolUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PoolUpdatedEvent.PoolUpdatedEventArgs(
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[PoolUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PoolUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PoolUpdatedEvent.PoolUpdatedEventArgs(
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolAddressesProviderPriceOracleSentinelUpdatedContractEvent(
    ContractEvent
):
    """ContractEvent for PriceOracleSentinelUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[PriceOracleSentinelUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PriceOracleSentinelUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PriceOracleSentinelUpdatedEvent.PriceOracleSentinelUpdatedEventArgs(
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[PriceOracleSentinelUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PriceOracleSentinelUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PriceOracleSentinelUpdatedEvent.PriceOracleSentinelUpdatedEventArgs(
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolAddressesProviderPriceOracleUpdatedContractEvent(ContractEvent):
    """ContractEvent for PriceOracleUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[PriceOracleUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PriceOracleUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PriceOracleUpdatedEvent.PriceOracleUpdatedEventArgs(
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[PriceOracleUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PriceOracleUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PriceOracleUpdatedEvent.PriceOracleUpdatedEventArgs(
                    oldAddress=abi_event.args["oldAddress"],
                    newAddress=abi_event.args["newAddress"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolAddressesProviderProxyCreatedContractEvent(ContractEvent):
    """ContractEvent for ProxyCreated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ProxyCreatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ProxyCreatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ProxyCreatedEvent.ProxyCreatedEventArgs(
                    _id=abi_event.args["_id"],
                    proxyAddress=abi_event.args["proxyAddress"],
                    implementationAddress=abi_event.args[
                        "implementationAddress"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ProxyCreatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ProxyCreatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ProxyCreatedEvent.ProxyCreatedEventArgs(
                    _id=abi_event.args["_id"],
                    proxyAddress=abi_event.args["proxyAddress"],
                    implementationAddress=abi_event.args[
                        "implementationAddress"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolAddressesProviderContractEvents(ContractEvents):
    """ContractEvents for the IPoolAddressesProvider contract."""

    ACLAdminUpdated: Type[IPoolAddressesProviderACLAdminUpdatedContractEvent]

    ACLManagerUpdated: Type[
        IPoolAddressesProviderACLManagerUpdatedContractEvent
    ]

    AddressSet: Type[IPoolAddressesProviderAddressSetContractEvent]

    AddressSetAsProxy: Type[
        IPoolAddressesProviderAddressSetAsProxyContractEvent
    ]

    MarketIdSet: Type[IPoolAddressesProviderMarketIdSetContractEvent]

    PoolConfiguratorUpdated: Type[
        IPoolAddressesProviderPoolConfiguratorUpdatedContractEvent
    ]

    PoolDataProviderUpdated: Type[
        IPoolAddressesProviderPoolDataProviderUpdatedContractEvent
    ]

    PoolUpdated: Type[IPoolAddressesProviderPoolUpdatedContractEvent]

    PriceOracleSentinelUpdated: Type[
        IPoolAddressesProviderPriceOracleSentinelUpdatedContractEvent
    ]

    PriceOracleUpdated: Type[
        IPoolAddressesProviderPriceOracleUpdatedContractEvent
    ]

    ProxyCreated: Type[IPoolAddressesProviderProxyCreatedContractEvent]

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.ACLAdminUpdated = cast(
            Type[IPoolAddressesProviderACLAdminUpdatedContractEvent],
            IPoolAddressesProviderACLAdminUpdatedContractEvent.factory(
                "ACLAdminUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="ACLAdminUpdated",
            ),
        )
        self.ACLManagerUpdated = cast(
            Type[IPoolAddressesProviderACLManagerUpdatedContractEvent],
            IPoolAddressesProviderACLManagerUpdatedContractEvent.factory(
                "ACLManagerUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="ACLManagerUpdated",
            ),
        )
        self.AddressSet = cast(
            Type[IPoolAddressesProviderAddressSetContractEvent],
            IPoolAddressesProviderAddressSetContractEvent.factory(
                "AddressSet",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="AddressSet",
            ),
        )
        self.AddressSetAsProxy = cast(
            Type[IPoolAddressesProviderAddressSetAsProxyContractEvent],
            IPoolAddressesProviderAddressSetAsProxyContractEvent.factory(
                "AddressSetAsProxy",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="AddressSetAsProxy",
            ),
        )
        self.MarketIdSet = cast(
            Type[IPoolAddressesProviderMarketIdSetContractEvent],
            IPoolAddressesProviderMarketIdSetContractEvent.factory(
                "MarketIdSet",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MarketIdSet",
            ),
        )
        self.PoolConfiguratorUpdated = cast(
            Type[IPoolAddressesProviderPoolConfiguratorUpdatedContractEvent],
            IPoolAddressesProviderPoolConfiguratorUpdatedContractEvent.factory(
                "PoolConfiguratorUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="PoolConfiguratorUpdated",
            ),
        )
        self.PoolDataProviderUpdated = cast(
            Type[IPoolAddressesProviderPoolDataProviderUpdatedContractEvent],
            IPoolAddressesProviderPoolDataProviderUpdatedContractEvent.factory(
                "PoolDataProviderUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="PoolDataProviderUpdated",
            ),
        )
        self.PoolUpdated = cast(
            Type[IPoolAddressesProviderPoolUpdatedContractEvent],
            IPoolAddressesProviderPoolUpdatedContractEvent.factory(
                "PoolUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="PoolUpdated",
            ),
        )
        self.PriceOracleSentinelUpdated = cast(
            Type[IPoolAddressesProviderPriceOracleSentinelUpdatedContractEvent],
            IPoolAddressesProviderPriceOracleSentinelUpdatedContractEvent.factory(
                "PriceOracleSentinelUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="PriceOracleSentinelUpdated",
            ),
        )
        self.PriceOracleUpdated = cast(
            Type[IPoolAddressesProviderPriceOracleUpdatedContractEvent],
            IPoolAddressesProviderPriceOracleUpdatedContractEvent.factory(
                "PriceOracleUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="PriceOracleUpdated",
            ),
        )
        self.ProxyCreated = cast(
            Type[IPoolAddressesProviderProxyCreatedContractEvent],
            IPoolAddressesProviderProxyCreatedContractEvent.factory(
                "ProxyCreated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="ProxyCreated",
            ),
        )


ipooladdressesprovider_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "getACLAdmin",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getACLManager",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getAddress",
            "inputs": [
                {"name": "id", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getMarketId",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getPool",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getPoolConfigurator",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getPoolDataProvider",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getPriceOracle",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getPriceOracleSentinel",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "setACLAdmin",
            "inputs": [
                {
                    "name": "newAclAdmin",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setACLManager",
            "inputs": [
                {
                    "name": "newAclManager",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setAddress",
            "inputs": [
                {"name": "id", "type": "bytes32", "internalType": "bytes32"},
                {
                    "name": "newAddress",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setAddressAsProxy",
            "inputs": [
                {"name": "id", "type": "bytes32", "internalType": "bytes32"},
                {
                    "name": "newImplementationAddress",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setMarketId",
            "inputs": [
                {
                    "name": "newMarketId",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setPoolConfiguratorImpl",
            "inputs": [
                {
                    "name": "newPoolConfiguratorImpl",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setPoolDataProvider",
            "inputs": [
                {
                    "name": "newDataProvider",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setPoolImpl",
            "inputs": [
                {
                    "name": "newPoolImpl",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setPriceOracle",
            "inputs": [
                {
                    "name": "newPriceOracle",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setPriceOracleSentinel",
            "inputs": [
                {
                    "name": "newPriceOracleSentinel",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "event",
            "name": "ACLAdminUpdated",
            "inputs": [
                {
                    "name": "oldAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ACLManagerUpdated",
            "inputs": [
                {
                    "name": "oldAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "AddressSet",
            "inputs": [
                {
                    "name": "id",
                    "type": "bytes32",
                    "indexed": True,
                    "internalType": "bytes32",
                },
                {
                    "name": "oldAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "AddressSetAsProxy",
            "inputs": [
                {
                    "name": "id",
                    "type": "bytes32",
                    "indexed": True,
                    "internalType": "bytes32",
                },
                {
                    "name": "proxyAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "oldImplementationAddress",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "newImplementationAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MarketIdSet",
            "inputs": [
                {
                    "name": "oldMarketId",
                    "type": "string",
                    "indexed": True,
                    "internalType": "string",
                },
                {
                    "name": "newMarketId",
                    "type": "string",
                    "indexed": True,
                    "internalType": "string",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "PoolConfiguratorUpdated",
            "inputs": [
                {
                    "name": "oldAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "PoolDataProviderUpdated",
            "inputs": [
                {
                    "name": "oldAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "PoolUpdated",
            "inputs": [
                {
                    "name": "oldAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "PriceOracleSentinelUpdated",
            "inputs": [
                {
                    "name": "oldAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "PriceOracleUpdated",
            "inputs": [
                {
                    "name": "oldAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ProxyCreated",
            "inputs": [
                {
                    "name": "id",
                    "type": "bytes32",
                    "indexed": True,
                    "internalType": "bytes32",
                },
                {
                    "name": "proxyAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "implementationAddress",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
    ],
)


class IPoolAddressesProviderContract(Contract):
    """A web3.py Contract class for the IPoolAddressesProvider contract."""

    abi: ABI = ipooladdressesprovider_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr("0x")

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = IPoolAddressesProviderContractFunctions(ipooladdressesprovider_abi, self.w3, address)  # type: ignore
        self.events = IPoolAddressesProviderContractEvents(ipooladdressesprovider_abi, self.w3, address)  # type: ignore

    events: IPoolAddressesProviderContractEvents

    functions: IPoolAddressesProviderContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = IPoolAddressesProviderContractFunctions(
            ipooladdressesprovider_abi, w3, None
        )

        return contract

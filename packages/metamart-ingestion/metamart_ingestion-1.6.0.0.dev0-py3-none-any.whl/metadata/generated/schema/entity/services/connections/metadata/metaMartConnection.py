# generated by datamodel-codegen:
#   filename:  entity/services/connections/metadata/metaMartConnection.json
#   timestamp: 2024-10-17T09:28:17+00:00

from __future__ import annotations

from enum import Enum
from typing import Dict, Optional

from pydantic import ConfigDict, Field, RootModel
from typing_extensions import Annotated

from metadata.ingestion.models.custom_pydantic import BaseModel

from .....security.client import metaMartJWTClientConfig
from .....security.secrets import secretsManagerClientLoader, secretsManagerProvider
from .....security.ssl import verifySSLConfig
from .....type import basic
from .. import connectionBasicType


class ElasticsSearch(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Annotated[str, Field(description='Type of sink component ex: metadata')]
    config: Optional[basic.ComponentConfig] = None


class MetamartType(Enum):
    MetaMart = 'MetaMart'


class ExtraHeaders(RootModel[Optional[Dict[str, str]]]):
    root: Optional[Dict[str, str]] = None


class AuthProvider(Enum):
    basic = 'basic'
    azure = 'azure'
    google = 'google'
    okta = 'okta'
    auth0 = 'auth0'
    aws_cognito = 'aws-cognito'
    custom_oidc = 'custom-oidc'
    ldap = 'ldap'
    saml = 'saml'
    metamart = 'metamart'


class MetaMartConnection(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    clusterName: Annotated[
        Optional[str],
        Field(
            'metamart',
            description='Cluster name to differentiate MetaMart Server instance',
        ),
    ]
    type: Annotated[
        Optional[MetamartType], Field(MetamartType.MetaMart, description='Service Type')
    ]
    hostPort: Annotated[
        str,
        Field(
            description='MetaMart Server Config. Must include API end point ex: http://localhost:8585/api'
        ),
    ]
    authProvider: Annotated[
        Optional[AuthProvider],
        Field(
            AuthProvider.basic, description='MetaMart Server Authentication Provider.'
        ),
    ]
    verifySSL: Annotated[
        Optional[verifySSLConfig.VerifySSL],
        Field(
            verifySSLConfig.VerifySSL.no_ssl,
            description='Flag to verify SSL Certificate for MetaMart Server.',
        ),
    ]
    sslConfig: Annotated[
        Optional[verifySSLConfig.SslConfig],
        Field(None, description='SSL Configuration for MetaMart Server'),
    ]
    securityConfig: Annotated[
        Optional[metaMartJWTClientConfig.MetaMartJWTClientConfig],
        Field(None, description='MetaMart Client security configuration.'),
    ]
    secretsManagerProvider: Annotated[
        Optional[secretsManagerProvider.SecretsManagerProvider],
        Field(
            secretsManagerProvider.SecretsManagerProvider.db,
            description='Secrets Manager Provider for MetaMart Server.',
        ),
    ]
    secretsManagerLoader: Annotated[
        Optional[secretsManagerClientLoader.SecretsManagerClientLoader],
        Field(
            secretsManagerClientLoader.SecretsManagerClientLoader.noop,
            description='Secrets Manager Loader for the Pipeline Service Client.',
        ),
    ]
    apiVersion: Annotated[
        Optional[str], Field('v1', description='MetaMart server API version to use.')
    ]
    includeTopics: Annotated[
        Optional[bool], Field(True, description='Include Topics for Indexing')
    ]
    includeTables: Annotated[
        Optional[bool], Field(True, description='Include Tables for Indexing')
    ]
    includeDashboards: Annotated[
        Optional[bool], Field(True, description='Include Dashboards for Indexing')
    ]
    includePipelines: Annotated[
        Optional[bool], Field(True, description='Include Pipelines for Indexing')
    ]
    includeMlModels: Annotated[
        Optional[bool], Field(True, description='Include MlModels for Indexing')
    ]
    includeUsers: Annotated[
        Optional[bool], Field(True, description='Include Users for Indexing')
    ]
    includeTeams: Annotated[
        Optional[bool], Field(True, description='Include Teams for Indexing')
    ]
    includeGlossaryTerms: Annotated[
        Optional[bool], Field(True, description='Include Glossary Terms for Indexing')
    ]
    includeTags: Annotated[
        Optional[bool], Field(True, description='Include Tags for Indexing')
    ]
    includePolicy: Annotated[
        Optional[bool], Field(True, description='Include Tags for Policy')
    ]
    includeMessagingServices: Annotated[
        Optional[bool],
        Field(True, description='Include Messaging Services for Indexing'),
    ]
    enableVersionValidation: Annotated[
        Optional[bool],
        Field(True, description='Validate Metamart Server & Client Version.'),
    ]
    includeDatabaseServices: Annotated[
        Optional[bool],
        Field(True, description='Include Database Services for Indexing'),
    ]
    includePipelineServices: Annotated[
        Optional[bool],
        Field(True, description='Include Pipeline Services for Indexing'),
    ]
    limitRecords: Annotated[
        Optional[int],
        Field(1000, description='Limit the number of records for Indexing.'),
    ]
    forceEntityOverwriting: Annotated[
        Optional[bool],
        Field(
            False,
            description='Force the overwriting of any entity during the ingestion.',
        ),
    ]
    storeServiceConnection: Annotated[
        Optional[bool],
        Field(
            True,
            description='If set to true, when creating a service during the ingestion we will store its Service Connection. Otherwise, the ingestion will create a bare service without connection details.',
        ),
    ]
    elasticsSearch: Annotated[
        Optional[ElasticsSearch],
        Field(
            None,
            description='Configuration for Sink Component in the MetaMart Ingestion Framework.',
        ),
    ]
    supportsDataInsightExtraction: Annotated[
        Optional[connectionBasicType.SupportsDataInsightExtraction],
        Field(None, description='Flag to enable Data Insight Extraction'),
    ]
    supportsElasticSearchReindexingExtraction: Annotated[
        Optional[connectionBasicType.SupportsElasticSearchReindexingExtraction],
        Field(None, description='Flag to enable ElasticSearch Reindexing Extraction'),
    ]
    extraHeaders: Annotated[Optional[ExtraHeaders], Field(None, title='Extra Headers')]

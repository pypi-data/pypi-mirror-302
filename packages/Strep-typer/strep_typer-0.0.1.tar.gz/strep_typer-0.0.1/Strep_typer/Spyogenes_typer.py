# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_Spyogenes_analysis.ipynb.

# %% auto 0
__all__ = ['arguments_present_check', 'update_cleanup_config', 'check_arguments', 'Spyogenes_analysis', 'Spyogenes_manager',
           'print_fasta_from_dict', 'unit_test_single', 'unit_test_single_2', 'unit_test_from_folder',
           'unit_test_from_samplesheet', 'cli']

# %% ../nbs/03_Spyogenes_analysis.ipynb 2
# That export there, it makes sure this code goes into the module.

# standard libs
import os
import re

# Common to template
# add into settings.ini, requirements, package name is python-dotenv, for conda build ensure `conda config --add channels conda-forge`
import dotenv  # for loading config from .env files, https://pypi.org/project/python-dotenv/
import envyaml  # Allows to loads env vars into a yaml file, https://github.com/thesimj/envyaml
import fastcore  # To add functionality related to nbdev development, https://github.com/fastai/fastcore/
from fastcore import (
    test,
)
from fastcore.script import (
    call_parse,
)  # for @call_parse, https://fastcore.fast.ai/script
import json  # for nicely printing json and yaml
from fastcore import test
from Strep_typer import (
    core,
    sample_manager,
    analysis_utility,
)
from fastcore.script import call_parse
from pathlib import Path  # to be able write :Path in cli function

# Project specific libraries
import pandas as pd
import numpy as np
import subprocess

# %% ../nbs/03_Spyogenes_analysis.ipynb 6
def arguments_present_check(input_config):
    # Check if an input-file is provided, either as argument or unit-test. If not, exit with error
    if (
        input_config["assembly_file"] is None
        and input_config["Illumina_read_files"] is None
        and input_config["Nanopore_read_files"] is None
        and input_config["samplesheet"] is None
        and input_config["input_folder"] is None
    ):
        print(
            f"Input data must be given in the form of sequence data (assembly_file, Illumina_read_files and/or Nanopore_read_files), an input_dir with sequencing data, or a metadatas tsv with paths to those files"
        )
        return False
    elif input_config["load_from_folder"] and input_config["input_folder"] is None:
        print(
            f"When running --load_from_folder an input directory must be provided with --input_folder"
        )
    elif input_config["load_from_samplesheet"] and (
        not input_config["samplesheet"] or input_config["samplesheet"] is None
    ):
        print(
            f"When running --load_from_samplesheet a samplesheet must be provided with --samplesheet"
        )
    else:
        return True


def update_cleanup_config(analysis_config, files_to_keep_string):
    files_to_keep_list = files_to_keep_string.split(" ")
    for element in files_to_keep_list:
        element_split = element.split(":")
        if element_split[0] in analysis_config:
            if len(element_split) == 1:
                analysis_config[element]["files_to_clean"] = []
            else:
                analysis_config[element_split[0]]["files_to_clean"] = list(
                    set(analysis_config[element_split[0]]["files_to_clean"])
                    - set(element_split[1].split(","))
                )
    return analysis_config

# %% ../nbs/03_Spyogenes_analysis.ipynb 8
def check_arguments(input, config_file):
    exit_code = 0
    error_messages = list()
    # If a config-file was provided, check that it exists. If not, exit directly.
    if config_file is not None:
        config_dir = os.path.abspath(config_file)
        isConfig = os.path.isfile(config_dir)
        if not isConfig:
            print("ERROR: The provided config-file doesnt exist: " + config_dir)
            exit()
    input_dir = os.path.abspath(input)
    isInput = os.path.isfile(input_dir)
    if not isInput:
        error_msg = "Your input log-file does not exist: " + input_dir
        error_messages.append(error_msg)
        exit_code = 1
    # Report errors and exit (if any)
    if exit_code == 1:
        print("Error: there were problems with the following script arguments:")
        for msg in error_messages:
            print(msg)
        exit()

# %% ../nbs/03_Spyogenes_analysis.ipynb 10
class Spyogenes_analysis(analysis_utility.analysis_utility):
    species = "Streptococcus pyogenes"

    def __init__(self, attributes, input_folder, output_folder, analysis_config):
        attributes = attributes.copy()
        super().__init__(attributes, input_folder, output_folder)
        self.run_analyses(analysis_config)

    def run_analyses(self, analysis_config):
        analyses_to_run = analysis_config["analyses_to_run"]
        self.sample_setup(analyses_to_run)
        if "assembly_lineage_determination" in analyses_to_run:
            lineage_determination_config = analysis_config[
                "assembly_lineage_determination"
            ]
            self._assembly_lineage_determination_(
                "Lineage_determination", lineage_determination_config
            )
        if "emm_typing" in analyses_to_run:
            emm_typing_config = analysis_config["emm_typing"]
            self._emm_typing_("emm_typing", emm_typing_config)
        if "resistance_gene_detection" in analyses_to_run:
            AMR_gene_reference_fasta = analysis_config["resistance_gene_detection"][
                "resistance_gene_file"
            ]
            AMR_blast_config = analysis_config["resistance_gene_detection"]
            self._blast_presence_absence_(
                "resistance_gene_detection", AMR_gene_reference_fasta, AMR_blast_config
            )
        if "virulence_gene_detection" in analyses_to_run:
            VFDB_gene_reference_fasta = analysis_config["virulence_gene_detection"][
                "virulence_gene_file"
            ]
            VFDB_blast_config = analysis_config["virulence_gene_detection"]
            VFDB_blast_config["results_format"] = "string"
            self._blast_presence_absence_(
                "virulence_gene_detection", VFDB_gene_reference_fasta, VFDB_blast_config
            )
        self.sample_cleanup()
        self.write_to_tsv()

    def load_emm_clusters(emm_cluster_file):
        emm_clusters = {}
        with open(emm_cluster_file) as f:
            for line in f:
                line = line.rstrip("\n").split(" ")
                for i in range(1, len(line)):
                    try:
                        emm_clusters[line[i]] += f",{line[0]}"
                    except KeyError:
                        emm_clusters[line[i]] = line[0]
        return emm_clusters

    def _emm_typing_(self, analysis_alias, emm_typing_config, output_folder=False):
        if self.assembly_file is None:
            self.logger.critical(
                f"Assembly file not provided or not found. Skipping analysis {analysis_alias}"
            )
            self.analysis_results[analysis_alias] = {analysis_alias: "NA"}
        else:
            output_folder = self.analysis_setup(analysis_alias, output_folder)
            if not output_folder:
                output_folder = os.path.join(self.output_folder, analysis_alias)
            output_folder = self.analysis_setup(analysis_alias, output_folder)
            emm_blast_output_file = os.path.join(output_folder, "blast.tsv")
            try:
                with open(emm_typing_config["emm_cluster_file"]) as f:
                    emm_clusters = {}
                    for line in f:
                        line = line.rstrip("\n").split()
                        for ele in line:
                            emm_clusters[ele] = line[0]
                self.logger.info(
                    f"Loaded EMM clusters from file {emm_typing_config['emm_cluster_file']}"
                )
            except Exception as e:
                self.logger.error(
                    f"Failed to parse cluster EMM cluster file, error: {e}"
                )
            cmd = f"blastn -query {emm_typing_config['emm_allele_file']} -subject {self.assembly_file} -qcov_hsp_perc 90 -out {emm_blast_output_file} -outfmt \"6 {emm_typing_config['blast_header']}\""
            if not os.path.exists(emm_blast_output_file):
                stdout, stderr = self.execute_cmd_and_log(cmd)
            blast_df = pd.read_csv(emm_blast_output_file, sep="\t", header=None)
            blast_df.columns = emm_typing_config["blast_header"].split(" ")
            blast_df["plen"] = blast_df["length"] / blast_df["qlen"] * 100
            blast_df["extended_sstart"] = np.where(
                blast_df["sstart"] < blast_df["send"],
                round((blast_df["sstart"] - blast_df["qstart"] + 1) / 100),
                round((blast_df["send"] - blast_df["qstart"] + 1) / 100),
            )
            blast_df_sorted = blast_df.sort_values(by=["bitscore"], ascending=False)
            emm_typing_results = {
                "EMM_type": "-",
                "EMM_cluster": "-",
                "ENN_type": "-",
                "ENN_cluster": "-",
                "MRP_type": "-",
                "MRP_cluster": "-",
            }
            unclassified_alleles = []
            for start_pos in set(blast_df_sorted["extended_sstart"]):
                allele_type = False
                df_filtered = blast_df.query("extended_sstart == @start_pos")
                df_filtered_dict = df_filtered.to_dict("records")
                for row in df_filtered_dict:
                    allele_name = row["qseqid"][3:]
                    if allele_name in emm_clusters:
                        cluster = emm_clusters[allele_name]
                        allele_type = cluster[:3]
                        emm_typing_results[f"{allele_type}_cluster"] = cluster
                        break
                    elif allele_name.split(".")[0] in emm_clusters:
                        cluster = emm_clusters[allele_name.split(".")[0]]
                        allele_type = cluster[:3]
                        emm_typing_results[f"{allele_type}_cluster"] = cluster
                        break
                if row["pident"] < 100:
                    allele_name = f"{allele_name}*"
                if row["plen"] < 100:
                    allele_name = f"{allele_name}?"
                if not allele_type:
                    unclassified_alleles.append(allele_name)
                emm_typing_results[f"{allele_type}_type"] = allele_name
            if unclassified_alleles:
                emm_typing_results["unclassified_emm_like_alleles"] = ",".join(
                    unclassified_alleles
                )
                if emm_typing_results["EMM_type"] == "-":
                    emm_typing_results["EMM_type"] = (
                        "/".join(unclassified_alleles) + "+"
                    )
            else:
                emm_typing_results["unclassified_emm_like_alleles"] = "-"
            self.analysis_results[analysis_alias] = emm_typing_results
            self.analysis_output_files[analysis_alias] = {
                "blast": emm_blast_output_file
            }
            self.analysis_cleanup(analysis_alias, emm_typing_config["files_to_clean"])


class Spyogenes_manager(analysis_utility.analysis_manager):

    def __init__(self, input_config, analysis_settings_config):
        self.analysis_settings: dict = analysis_settings_config
        super().__init__(input_config)
        self.write_to_tsv()

    def add_sample(self, attributes):
        try:
            output_folder = os.path.abspath(attributes["output_folder"])
        except KeyError:
            output_folder = os.path.join(
                self.base_output_folder, attributes["sample_name"]
            )
        self.samples.append(
            Spyogenes_analysis(
                attributes,
                self.base_input_folder,
                output_folder,
                self.analysis_settings,
            )
        )
        return


def print_fasta_from_dict(fasta_dict, output_file):
    printlines = ""
    for header, sequence in fasta_dict.items():
        printlines += ">" + header + "\n" + sequence + "\n"
    o = open(output_file, "w")
    o.write(printlines)
    o.close()

# %% ../nbs/03_Spyogenes_analysis.ipynb 14
def unit_test_single():
    config = core.get_config()
    example_sample = Spyogenes_analysis(
        {
            "sample_name": "GAS-2022-1029",
            "assembly_file": "examples/GAS-2022-1029.fasta",
            "Illumina_read_files": [
                "examples/GAS-2022-1029_S42_L555_R1_001.fastq.gz",
                "examples/GAS-2022-1029_S42_L555_R2_001.fastq.gz",
            ],
        },
        input_folder=False,
        output_folder="output/GAS-2022-1029",
        analysis_config=config["analysis_settings"]["Spyogenes"],
    )
    assert example_sample.sample_name == "GAS-2022-1029"
    assert len(example_sample.Illumina_read_files) == 2
    assert not example_sample.Nanopore_read_file
    assert example_sample.analysis_results["emm_typing"]["EMM_type"] == "1.0"
    assert example_sample.analysis_results["Lineage_determination"]["Lineage"] == "M1DK"


def unit_test_single_2():
    config = core.get_config()
    example_sample = Spyogenes_analysis(
        {
            "sample_name": "GAS-2024-0773",
            "assembly_file": "GAS-2024-0773.fasta",
            "Illumina_read_files": "GAS-2024-0773_S35_L555_R1_001.fastq.gz,GAS-2024-0773_S35_L555_R2_001.fastq.gz",
        },
        input_folder="examples",
        # output_folder = "output/",
        analysis_config=config["analysis_settings"]["Spyogenes"],
    )
    assert example_sample.sample_name == "GAS-2024-0773"
    assert len(example_sample.Illumina_read_files) == 2
    assert not example_sample.Nanopore_read_file
    assert example_sample.analysis_results["emm_typing"]["EMM_type"] == "4.0"
    assert example_sample.analysis_results["emm_typing"]["ENN_type"] == "203.3*"
    assert example_sample.analysis_results["emm_typing"]["MRP_type"] == "156.0"
    assert example_sample.analysis_results["Lineage_determination"]["Lineage"] == "-"


def unit_test_from_folder():
    sample_manager
    config = core.get_config()
    input_config = config["input_manager"]
    input_config["load_from_folder"] = True
    input_config["input_folder"] = "examples/"
    input_config["output_folder"] = "output_from_folder/"
    input_config["analysis_config"] = config["analysis_settings"]["Spyogenes"]
    test = Spyogenes_manager(input_config, config["analysis_settings"]["Spyogenes"])


def unit_test_from_samplesheet():
    config = core.get_config()
    input_config = config["input_manager"]
    input_config["load_from_samplesheet"] = True
    input_config["samplesheet"] = "examples/samplesheet.tsv"
    input_config["output_folder"] = "output_from_samplesheet/"
    input_config["analysis_config"] = config["analysis_settings"]["Spyogenes"]
    test = Spyogenes_manager(input_config, config["analysis_settings"]["Spyogenes"])
    print(test.__dict__)
    for x in test:
        print(x.__dict__)

# %% ../nbs/03_Spyogenes_analysis.ipynb 20
@call_parse
def cli(
    # Definition of command-line arguments
    assembly_file: str = None,  # Path to log-file from rclone (required, unless using config)
    Illumina_read_files: str = None,  # Path to log-file from rclone (required, unless using config)
    Nanopore_read_file: str = None,  # Path to log-file from rclone (required, unless using config)
    samplesheet: str = None,
    input_folder: str = None,
    output_folder: str = None,
    analyses_to_run: str = "all",
    keep_files: str = None,
    load_from_folder: bool = False,
    load_from_samplesheet: bool = False,
    config_file: Path = None,  # Config-file containing all required arguments (required, unless using input arg)
) -> None:
    # Set env vars and get config variables
    config = core.get_config(config_file)
    input_config = config["input_manager"]
    analysis_config = config["analysis_settings"]["Spyogenes"]
    # If unit-test requested: run unit-test and exit

    if samplesheet is not None:
        input_config["samplesheet"] = samplesheet
    if assembly_file is not None:
        input_config["assembly_file"] = assembly_file
    if Illumina_read_files is not None:
        input_config["Illumina_read_files"] = Illumina_read_files
    if Nanopore_read_file is not None:
        input_config["Nanopore_read_file"] = Nanopore_read_file
    if input_folder is not None:
        input_config["input_folder"] = input_folder
    if output_folder is not None:
        input_config["output_folder"] = output_folder
    if not analyses_to_run == "all":
        analysis_config["analyses_to_run"] = list(
            set(analysis_config["analyses_to_run"]).intersection(
                analyses_to_run.split(",")
            )
        )
    if keep_files is not None:
        analysis_config = update_cleanup_config(analysis_config, keep_files)
    input_config["load_from_folder"] = load_from_folder
    input_config["load_from_samplesheet"] = load_from_samplesheet

    # Check if any required arguments are missing
    if arguments_present_check(input_config):
        print("Running analyses")
        Spyogenes_manager(input_config, analysis_config)
    # Possible next: print some summary information to stdout about transfers found? Not sure if that is necessary in production.
    # Next: write function that adds data into transfer-db

# coding: utf-8

"""
    Zadara VPSA Storage Array REST API

     # Overview  This document outlines the methods available for administrating your Zadara Storage VPSA&#8482;. The Zadara Storage Array REST API   supports form-encoded, JSON, and XML requests, and can return either JSON or XML responses.  ## Usage  The majority of the APIs available require authentication which requires an API token to use. You can retrieve this token through the   Users section of your VPSA, or through the API using the \"Return a user's access key\" API in the Users Section below.  ## Authentication Methods  The authentication token can be passed either through the access_key parameter inside of the body of the REST API request, or   through the X-Access-Key header.  ## Timeouts  By default, all operations that don't complete within five seconds will return a message informing you that the action may take some  time to complete. When using the API, this can cause some actions, such as large volume creation, to be undesirably asynchronous.  You can specify your own timeout with the timeout parameter, in seconds, and a timeout value of -1 specifies an infinite timeout.  ## Specific Fields For Product  Some of the fields/actions used in the API should be used only for a specific product. The following tags are used to mark which   product responds to the fields/actions  VPSA Flash Array  VPSA Storage Array - Hybrid VPSA  ## Questions  If you have any questions or need support involving the REST API, please contact for assistance.   # noqa: E501

    OpenAPI spec version: 23.09-sp2
    Contact: support@zadarastorage.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from Vpsa.api_client import ApiClient


class SettingsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def change_encryption_to_aws_kms(self, change_encryption_to_aws_kms, **kwargs):  # noqa: E501
        """change_encryption_to_aws_kms  # noqa: E501

        Change encryption from using Master Encryption Password to use AWS KMS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_encryption_to_aws_kms(change_encryption_to_aws_kms, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ChangeEncryptionToAwsKms change_encryption_to_aws_kms: (required)
        :return: InlineResponse200183
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.change_encryption_to_aws_kms_with_http_info(change_encryption_to_aws_kms, **kwargs)  # noqa: E501
        else:
            (data) = self.change_encryption_to_aws_kms_with_http_info(change_encryption_to_aws_kms, **kwargs)  # noqa: E501
            return data

    def change_encryption_to_aws_kms_with_http_info(self, change_encryption_to_aws_kms, **kwargs):  # noqa: E501
        """change_encryption_to_aws_kms  # noqa: E501

        Change encryption from using Master Encryption Password to use AWS KMS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_encryption_to_aws_kms_with_http_info(change_encryption_to_aws_kms, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ChangeEncryptionToAwsKms change_encryption_to_aws_kms: (required)
        :return: InlineResponse200183
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['change_encryption_to_aws_kms']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_encryption_to_aws_kms" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'change_encryption_to_aws_kms' is set
        if self.api_client.client_side_validation and ('change_encryption_to_aws_kms' not in params or
                                                       params['change_encryption_to_aws_kms'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `change_encryption_to_aws_kms` when calling `change_encryption_to_aws_kms`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'change_encryption_to_aws_kms' in params:
            body_params = params['change_encryption_to_aws_kms']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/aws_encryption.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200183',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def change_mtu_for_ni(self, change_mtu_for_ni, **kwargs):  # noqa: E501
        """change_mtu_for_ni  # noqa: E501

        Changes the MTU for a network interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_mtu_for_ni(change_mtu_for_ni, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ChangeMtuForNi change_mtu_for_ni: (required)
        :return: InlineResponse200197
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.change_mtu_for_ni_with_http_info(change_mtu_for_ni, **kwargs)  # noqa: E501
        else:
            (data) = self.change_mtu_for_ni_with_http_info(change_mtu_for_ni, **kwargs)  # noqa: E501
            return data

    def change_mtu_for_ni_with_http_info(self, change_mtu_for_ni, **kwargs):  # noqa: E501
        """change_mtu_for_ni  # noqa: E501

        Changes the MTU for a network interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_mtu_for_ni_with_http_info(change_mtu_for_ni, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ChangeMtuForNi change_mtu_for_ni: (required)
        :return: InlineResponse200197
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['change_mtu_for_ni']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_mtu_for_ni" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'change_mtu_for_ni' is set
        if self.api_client.client_side_validation and ('change_mtu_for_ni' not in params or
                                                       params['change_mtu_for_ni'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `change_mtu_for_ni` when calling `change_mtu_for_ni`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'change_mtu_for_ni' in params:
            body_params = params['change_mtu_for_ni']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/set_mtu.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200197',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def configure_file_access_audit(self, configure_file_access_audit, **kwargs):  # noqa: E501
        """configure_file_access_audit  # noqa: E501

        Pause, enable or resume file access auditing configuration for the vpsa.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.configure_file_access_audit(configure_file_access_audit, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigureFileAccessAudit configure_file_access_audit: (required)
        :return: InlineResponse200189
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.configure_file_access_audit_with_http_info(configure_file_access_audit, **kwargs)  # noqa: E501
        else:
            (data) = self.configure_file_access_audit_with_http_info(configure_file_access_audit, **kwargs)  # noqa: E501
            return data

    def configure_file_access_audit_with_http_info(self, configure_file_access_audit, **kwargs):  # noqa: E501
        """configure_file_access_audit  # noqa: E501

        Pause, enable or resume file access auditing configuration for the vpsa.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.configure_file_access_audit_with_http_info(configure_file_access_audit, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigureFileAccessAudit configure_file_access_audit: (required)
        :return: InlineResponse200189
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['configure_file_access_audit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method configure_file_access_audit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'configure_file_access_audit' is set
        if self.api_client.client_side_validation and ('configure_file_access_audit' not in params or
                                                       params['configure_file_access_audit'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `configure_file_access_audit` when calling `configure_file_access_audit`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'configure_file_access_audit' in params:
            body_params = params['configure_file_access_audit']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/configure_file_access_audit.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200189',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_zcs_image_repository(self, create_zcs_image_repository, **kwargs):  # noqa: E501
        """create_zcs_image_repository  # noqa: E501

        Creates the ZCS image repository on the specified pool. ZCS images will be stored in this repository. 100 GB will be consumed on the specified pool for this repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_zcs_image_repository(create_zcs_image_repository, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateZcsImageRepository create_zcs_image_repository: (required)
        :return: InlineResponse200192
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_zcs_image_repository_with_http_info(create_zcs_image_repository, **kwargs)  # noqa: E501
        else:
            (data) = self.create_zcs_image_repository_with_http_info(create_zcs_image_repository, **kwargs)  # noqa: E501
            return data

    def create_zcs_image_repository_with_http_info(self, create_zcs_image_repository, **kwargs):  # noqa: E501
        """create_zcs_image_repository  # noqa: E501

        Creates the ZCS image repository on the specified pool. ZCS images will be stored in this repository. 100 GB will be consumed on the specified pool for this repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_zcs_image_repository_with_http_info(create_zcs_image_repository, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateZcsImageRepository create_zcs_image_repository: (required)
        :return: InlineResponse200192
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['create_zcs_image_repository']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_zcs_image_repository" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'create_zcs_image_repository' is set
        if self.api_client.client_side_validation and ('create_zcs_image_repository' not in params or
                                                       params['create_zcs_image_repository'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `create_zcs_image_repository` when calling `create_zcs_image_repository`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_zcs_image_repository' in params:
            body_params = params['create_zcs_image_repository']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/create_images_repository.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200192',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def default_write_policy(self, default_write_policy, **kwargs):  # noqa: E501
        """default_write_policy  # noqa: E501

        Set Default Filesystem Write Policy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.default_write_policy(default_write_policy, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DefaultWritePolicy default_write_policy: (required)
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.default_write_policy_with_http_info(default_write_policy, **kwargs)  # noqa: E501
        else:
            (data) = self.default_write_policy_with_http_info(default_write_policy, **kwargs)  # noqa: E501
            return data

    def default_write_policy_with_http_info(self, default_write_policy, **kwargs):  # noqa: E501
        """default_write_policy  # noqa: E501

        Set Default Filesystem Write Policy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.default_write_policy_with_http_info(default_write_policy, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DefaultWritePolicy default_write_policy: (required)
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['default_write_policy']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method default_write_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'default_write_policy' is set
        if self.api_client.client_side_validation and ('default_write_policy' not in params or
                                                       params['default_write_policy'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `default_write_policy` when calling `default_write_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'default_write_policy' in params:
            body_params = params['default_write_policy']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/default_write_policy.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200166',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_zcs_image_repository(self, **kwargs):  # noqa: E501
        """delete_zcs_image_repository  # noqa: E501

        Delete the images repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_zcs_image_repository(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200194
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_zcs_image_repository_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_zcs_image_repository_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_zcs_image_repository_with_http_info(self, **kwargs):  # noqa: E501
        """delete_zcs_image_repository  # noqa: E501

        Delete the images repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_zcs_image_repository_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200194
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_zcs_image_repository" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/images_repository.json', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200194',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_defrag(self, **kwargs):  # noqa: E501
        """disable_defrag  # noqa: E501

        Disable volumes defragmentation scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_defrag(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_defrag_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.disable_defrag_with_http_info(**kwargs)  # noqa: E501
            return data

    def disable_defrag_with_http_info(self, **kwargs):  # noqa: E501
        """disable_defrag  # noqa: E501

        Disable volumes defragmentation scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_defrag_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_defrag" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/defrag_disable.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200166',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_file_access_audit_conf(self, disable_file_access_audit_conf, **kwargs):  # noqa: E501
        """disable_file_access_audit_conf  # noqa: E501

        Disable file access auditing configuration for the vpsa.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_file_access_audit_conf(disable_file_access_audit_conf, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DisableFileAccessAuditConf disable_file_access_audit_conf: (required)
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_file_access_audit_conf_with_http_info(disable_file_access_audit_conf, **kwargs)  # noqa: E501
        else:
            (data) = self.disable_file_access_audit_conf_with_http_info(disable_file_access_audit_conf, **kwargs)  # noqa: E501
            return data

    def disable_file_access_audit_conf_with_http_info(self, disable_file_access_audit_conf, **kwargs):  # noqa: E501
        """disable_file_access_audit_conf  # noqa: E501

        Disable file access auditing configuration for the vpsa.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_file_access_audit_conf_with_http_info(disable_file_access_audit_conf, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DisableFileAccessAuditConf disable_file_access_audit_conf: (required)
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['disable_file_access_audit_conf']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_file_access_audit_conf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'disable_file_access_audit_conf' is set
        if self.api_client.client_side_validation and ('disable_file_access_audit_conf' not in params or
                                                       params['disable_file_access_audit_conf'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `disable_file_access_audit_conf` when calling `disable_file_access_audit_conf`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'disable_file_access_audit_conf' in params:
            body_params = params['disable_file_access_audit_conf']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/disable_file_access_audit.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200166',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_privilege_access(self, disable_privilege_access, **kwargs):  # noqa: E501
        """disable_privilege_access  # noqa: E501

        Disable privilege access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_privilege_access(disable_privilege_access, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DisablePrivilegeAccess disable_privilege_access: (required)
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_privilege_access_with_http_info(disable_privilege_access, **kwargs)  # noqa: E501
        else:
            (data) = self.disable_privilege_access_with_http_info(disable_privilege_access, **kwargs)  # noqa: E501
            return data

    def disable_privilege_access_with_http_info(self, disable_privilege_access, **kwargs):  # noqa: E501
        """disable_privilege_access  # noqa: E501

        Disable privilege access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_privilege_access_with_http_info(disable_privilege_access, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DisablePrivilegeAccess disable_privilege_access: (required)
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['disable_privilege_access']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_privilege_access" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'disable_privilege_access' is set
        if self.api_client.client_side_validation and ('disable_privilege_access' not in params or
                                                       params['disable_privilege_access'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `disable_privilege_access` when calling `disable_privilege_access`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'disable_privilege_access' in params:
            body_params = params['disable_privilege_access']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/disable_privilege_access.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200166',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_trim(self, **kwargs):  # noqa: E501
        """disable_trim  # noqa: E501

        Disable volumes File System scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_trim(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_trim_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.disable_trim_with_http_info(**kwargs)  # noqa: E501
            return data

    def disable_trim_with_http_info(self, **kwargs):  # noqa: E501
        """disable_trim  # noqa: E501

        Disable volumes File System scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_trim_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_trim" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/trim_disable.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200166',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_metering_database(self, **kwargs):  # noqa: E501
        """download_metering_database  # noqa: E501

        Download the metering database  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_metering_database(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Default
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.download_metering_database_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.download_metering_database_with_http_info(**kwargs)  # noqa: E501
            return data

    def download_metering_database_with_http_info(self, **kwargs):  # noqa: E501
        """download_metering_database  # noqa: E501

        Download the metering database  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_metering_database_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Default
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_metering_database" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/metering_db.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Default',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_defrag(self, **kwargs):  # noqa: E501
        """enable_defrag  # noqa: E501

        Enable volumes defragmentation scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_defrag(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_defrag_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.enable_defrag_with_http_info(**kwargs)  # noqa: E501
            return data

    def enable_defrag_with_http_info(self, **kwargs):  # noqa: E501
        """enable_defrag  # noqa: E501

        Enable volumes defragmentation scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_defrag_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_defrag" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/defrag_enable.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200166',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_privilege_access(self, **kwargs):  # noqa: E501
        """enable_privilege_access  # noqa: E501

        Enable privilege access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_privilege_access(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_privilege_access_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.enable_privilege_access_with_http_info(**kwargs)  # noqa: E501
            return data

    def enable_privilege_access_with_http_info(self, **kwargs):  # noqa: E501
        """enable_privilege_access  # noqa: E501

        Enable privilege access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_privilege_access_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_privilege_access" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/enable_privilege_access.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200166',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_trim(self, **kwargs):  # noqa: E501
        """enable_trim  # noqa: E501

        Enable volumes File System scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_trim(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_trim_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.enable_trim_with_http_info(**kwargs)  # noqa: E501
            return data

    def enable_trim_with_http_info(self, **kwargs):  # noqa: E501
        """enable_trim  # noqa: E501

        Enable volumes File System scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_trim_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_trim" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/trim_enable.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200166',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_app_settings(self, **kwargs):  # noqa: E501
        """get_all_app_settings  # noqa: E501

        Get all application settings. Allowed to admin only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_app_settings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200196
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_app_settings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_app_settings_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_app_settings_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_app_settings  # noqa: E501

        Get all application settings. Allowed to admin only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_app_settings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200196
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_app_settings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings_config.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200196',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_network(self, **kwargs):  # noqa: E501
        """get_network  # noqa: E501

        Returns network settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_network(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200172
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_network_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_network_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_network_with_http_info(self, **kwargs):  # noqa: E501
        """get_network  # noqa: E501

        Returns network settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_network_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200172
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_network" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/network.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200172',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nfs_domain(self, **kwargs):  # noqa: E501
        """get_nfs_domain  # noqa: E501

        Gets the NFS Domain associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nfs_domain(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200173
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_nfs_domain_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_nfs_domain_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_nfs_domain_with_http_info(self, **kwargs):  # noqa: E501
        """get_nfs_domain  # noqa: E501

        Gets the NFS Domain associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nfs_domain_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200173
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nfs_domain" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/nfs_domain.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200173',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_public_ip(self, **kwargs):  # noqa: E501
        """get_public_ip  # noqa: E501

        Returns the public IP(s) associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_public_ip(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200180
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_public_ip_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_public_ip_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_public_ip_with_http_info(self, **kwargs):  # noqa: E501
        """get_public_ip  # noqa: E501

        Returns the public IP(s) associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_public_ip_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200180
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_public_ip" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/public_ips.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200180',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vpsa_flc_global(self, **kwargs):  # noqa: E501
        """get_vpsa_flc_global  # noqa: E501

        Retrieves the VPSA FLC global.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vpsa_flc_global(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_vpsa_flc_global_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_vpsa_flc_global_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_vpsa_flc_global_with_http_info(self, **kwargs):  # noqa: E501
        """get_vpsa_flc_global  # noqa: E501

        Retrieves the VPSA FLC global.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vpsa_flc_global_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vpsa_flc_global" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/flc_global.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_zcs_settings(self, **kwargs):  # noqa: E501
        """get_zcs_settings  # noqa: E501

        Get the APP repository details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_zcs_settings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200190
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_zcs_settings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_zcs_settings_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_zcs_settings_with_http_info(self, **kwargs):  # noqa: E501
        """get_zcs_settings  # noqa: E501

        Get the APP repository details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_zcs_settings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200190
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_zcs_settings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/container_service.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200190',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_all_vc_capabilities(self, **kwargs):  # noqa: E501
        """list_all_vc_capabilities  # noqa: E501

        Returns a list of all VC capabilities.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_vc_capabilities(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200199
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_all_vc_capabilities_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_all_vc_capabilities_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_all_vc_capabilities_with_http_info(self, **kwargs):  # noqa: E501
        """list_all_vc_capabilities  # noqa: E501

        Returns a list of all VC capabilities.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_vc_capabilities_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200199
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_all_vc_capabilities" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/vc_capabilities.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200199',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def migrate_zcs_image_repository(self, migrate_zcs_image_repository, **kwargs):  # noqa: E501
        """migrate_zcs_image_repository  # noqa: E501

        Migrate the images repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.migrate_zcs_image_repository(migrate_zcs_image_repository, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MigrateZcsImageRepository migrate_zcs_image_repository: (required)
        :return: InlineResponse200193
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.migrate_zcs_image_repository_with_http_info(migrate_zcs_image_repository, **kwargs)  # noqa: E501
        else:
            (data) = self.migrate_zcs_image_repository_with_http_info(migrate_zcs_image_repository, **kwargs)  # noqa: E501
            return data

    def migrate_zcs_image_repository_with_http_info(self, migrate_zcs_image_repository, **kwargs):  # noqa: E501
        """migrate_zcs_image_repository  # noqa: E501

        Migrate the images repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.migrate_zcs_image_repository_with_http_info(migrate_zcs_image_repository, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MigrateZcsImageRepository migrate_zcs_image_repository: (required)
        :return: InlineResponse200193
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['migrate_zcs_image_repository']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method migrate_zcs_image_repository" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'migrate_zcs_image_repository' is set
        if self.api_client.client_side_validation and ('migrate_zcs_image_repository' not in params or
                                                       params['migrate_zcs_image_repository'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `migrate_zcs_image_repository` when calling `migrate_zcs_image_repository`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'migrate_zcs_image_repository' in params:
            body_params = params['migrate_zcs_image_repository']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/migrate_images_repository.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200193',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_encryption_kms(self, **kwargs):  # noqa: E501
        """remove_encryption_kms  # noqa: E501

        Remove encryption KMS on the VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_encryption_kms(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200182
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_encryption_kms_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.remove_encryption_kms_with_http_info(**kwargs)  # noqa: E501
            return data

    def remove_encryption_kms_with_http_info(self, **kwargs):  # noqa: E501
        """remove_encryption_kms  # noqa: E501

        Remove encryption KMS on the VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_encryption_kms_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200182
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_encryption_kms" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/remove_encryption_kms.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200182',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_encryption_password(self, **kwargs):  # noqa: E501
        """remove_encryption_password  # noqa: E501

        Remove any encryption configured on your VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_encryption_password(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200187
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_encryption_password_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.remove_encryption_password_with_http_info(**kwargs)  # noqa: E501
            return data

    def remove_encryption_password_with_http_info(self, **kwargs):  # noqa: E501
        """remove_encryption_password  # noqa: E501

        Remove any encryption configured on your VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_encryption_password_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200187
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_encryption_password" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/clear_encryption.json', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200187',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restore_aws_kms_store(self, restore_aws_kms_store, **kwargs):  # noqa: E501
        """restore_aws_kms_store  # noqa: E501

        Restore the AWS KMS details for your VPSA, if cleared.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_aws_kms_store(restore_aws_kms_store, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestoreAwsKmsStore restore_aws_kms_store: (required)
        :return: InlineResponse200185
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.restore_aws_kms_store_with_http_info(restore_aws_kms_store, **kwargs)  # noqa: E501
        else:
            (data) = self.restore_aws_kms_store_with_http_info(restore_aws_kms_store, **kwargs)  # noqa: E501
            return data

    def restore_aws_kms_store_with_http_info(self, restore_aws_kms_store, **kwargs):  # noqa: E501
        """restore_aws_kms_store  # noqa: E501

        Restore the AWS KMS details for your VPSA, if cleared.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_aws_kms_store_with_http_info(restore_aws_kms_store, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestoreAwsKmsStore restore_aws_kms_store: (required)
        :return: InlineResponse200185
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['restore_aws_kms_store']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restore_aws_kms_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'restore_aws_kms_store' is set
        if self.api_client.client_side_validation and ('restore_aws_kms_store' not in params or
                                                       params['restore_aws_kms_store'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `restore_aws_kms_store` when calling `restore_aws_kms_store`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'restore_aws_kms_store' in params:
            body_params = params['restore_aws_kms_store']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/restore_encryption_aws.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200185',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restore_encryption_password(self, restore_encryption_password, **kwargs):  # noqa: E501
        """restore_encryption_password  # noqa: E501

        Restore the Master Encryption Password for your VPSA, if cleared.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_encryption_password(restore_encryption_password, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestoreEncryptionPassword restore_encryption_password: (required)
        :return: InlineResponse200184
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.restore_encryption_password_with_http_info(restore_encryption_password, **kwargs)  # noqa: E501
        else:
            (data) = self.restore_encryption_password_with_http_info(restore_encryption_password, **kwargs)  # noqa: E501
            return data

    def restore_encryption_password_with_http_info(self, restore_encryption_password, **kwargs):  # noqa: E501
        """restore_encryption_password  # noqa: E501

        Restore the Master Encryption Password for your VPSA, if cleared.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_encryption_password_with_http_info(restore_encryption_password, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestoreEncryptionPassword restore_encryption_password: (required)
        :return: InlineResponse200184
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['restore_encryption_password']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restore_encryption_password" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'restore_encryption_password' is set
        if self.api_client.client_side_validation and ('restore_encryption_password' not in params or
                                                       params['restore_encryption_password'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `restore_encryption_password` when calling `restore_encryption_password`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'restore_encryption_password' in params:
            body_params = params['restore_encryption_password']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/restore_encryption.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200184',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restore_encryption_password_kmip(self, restore_encryption_password_kmip, **kwargs):  # noqa: E501
        """restore_encryption_password_kmip  # noqa: E501

        Restore the KMIP KMS details for your VPSA, if cleared.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_encryption_password_kmip(restore_encryption_password_kmip, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestoreEncryptionPasswordKmip restore_encryption_password_kmip: (required)
        :return: InlineResponse200186
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.restore_encryption_password_kmip_with_http_info(restore_encryption_password_kmip, **kwargs)  # noqa: E501
        else:
            (data) = self.restore_encryption_password_kmip_with_http_info(restore_encryption_password_kmip, **kwargs)  # noqa: E501
            return data

    def restore_encryption_password_kmip_with_http_info(self, restore_encryption_password_kmip, **kwargs):  # noqa: E501
        """restore_encryption_password_kmip  # noqa: E501

        Restore the KMIP KMS details for your VPSA, if cleared.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_encryption_password_kmip_with_http_info(restore_encryption_password_kmip, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestoreEncryptionPasswordKmip restore_encryption_password_kmip: (required)
        :return: InlineResponse200186
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['restore_encryption_password_kmip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restore_encryption_password_kmip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'restore_encryption_password_kmip' is set
        if self.api_client.client_side_validation and ('restore_encryption_password_kmip' not in params or
                                                       params['restore_encryption_password_kmip'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `restore_encryption_password_kmip` when calling `restore_encryption_password_kmip`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'restore_encryption_password_kmip' in params:
            body_params = params['restore_encryption_password_kmip']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/restore_encryption_kmip.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200186',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_encription_pass(self, set_encription_pass, **kwargs):  # noqa: E501
        """set_encription_pass  # noqa: E501

        Change Master Encryption Password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_encription_pass(set_encription_pass, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetEncriptionPass set_encription_pass: (required)
        :return: InlineResponse200183
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_encription_pass_with_http_info(set_encription_pass, **kwargs)  # noqa: E501
        else:
            (data) = self.set_encription_pass_with_http_info(set_encription_pass, **kwargs)  # noqa: E501
            return data

    def set_encription_pass_with_http_info(self, set_encription_pass, **kwargs):  # noqa: E501
        """set_encription_pass  # noqa: E501

        Change Master Encryption Password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_encription_pass_with_http_info(set_encription_pass, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetEncriptionPass set_encription_pass: (required)
        :return: InlineResponse200183
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set_encription_pass']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_encription_pass" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set_encription_pass' is set
        if self.api_client.client_side_validation and ('set_encription_pass' not in params or
                                                       params['set_encription_pass'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `set_encription_pass` when calling `set_encription_pass`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_encription_pass' in params:
            body_params = params['set_encription_pass']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/password_encryption.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200183',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_encription_pass_or_use_aws_kms_store(self, set_encription_pass_or_use_aws_kms_store, **kwargs):  # noqa: E501
        """set_encription_pass_or_use_aws_kms_store  # noqa: E501

        Sets the encryption password globally on the VPSA. or Change Master Encryption Password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_encription_pass_or_use_aws_kms_store(set_encription_pass_or_use_aws_kms_store, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetEncriptionPassOrUseAwsKmsStore set_encription_pass_or_use_aws_kms_store: (required)
        :return: InlineResponse200181
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_encription_pass_or_use_aws_kms_store_with_http_info(set_encription_pass_or_use_aws_kms_store, **kwargs)  # noqa: E501
        else:
            (data) = self.set_encription_pass_or_use_aws_kms_store_with_http_info(set_encription_pass_or_use_aws_kms_store, **kwargs)  # noqa: E501
            return data

    def set_encription_pass_or_use_aws_kms_store_with_http_info(self, set_encription_pass_or_use_aws_kms_store, **kwargs):  # noqa: E501
        """set_encription_pass_or_use_aws_kms_store  # noqa: E501

        Sets the encryption password globally on the VPSA. or Change Master Encryption Password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_encription_pass_or_use_aws_kms_store_with_http_info(set_encription_pass_or_use_aws_kms_store, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetEncriptionPassOrUseAwsKmsStore set_encription_pass_or_use_aws_kms_store: (required)
        :return: InlineResponse200181
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set_encription_pass_or_use_aws_kms_store']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_encription_pass_or_use_aws_kms_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set_encription_pass_or_use_aws_kms_store' is set
        if self.api_client.client_side_validation and ('set_encription_pass_or_use_aws_kms_store' not in params or
                                                       params['set_encription_pass_or_use_aws_kms_store'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `set_encription_pass_or_use_aws_kms_store` when calling `set_encription_pass_or_use_aws_kms_store`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_encription_pass_or_use_aws_kms_store' in params:
            body_params = params['set_encription_pass_or_use_aws_kms_store']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/encryption.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200181',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_encryption_password_kmip(self, set_encryption_password_kmip, **kwargs):  # noqa: E501
        """set_encryption_password_kmip  # noqa: E501

        Change encryption from using Master Encryption Password to use KMIP KMS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_encryption_password_kmip(set_encryption_password_kmip, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetEncryptionPasswordKmip set_encryption_password_kmip: (required)
        :return: InlineResponse200183
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_encryption_password_kmip_with_http_info(set_encryption_password_kmip, **kwargs)  # noqa: E501
        else:
            (data) = self.set_encryption_password_kmip_with_http_info(set_encryption_password_kmip, **kwargs)  # noqa: E501
            return data

    def set_encryption_password_kmip_with_http_info(self, set_encryption_password_kmip, **kwargs):  # noqa: E501
        """set_encryption_password_kmip  # noqa: E501

        Change encryption from using Master Encryption Password to use KMIP KMS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_encryption_password_kmip_with_http_info(set_encryption_password_kmip, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetEncryptionPasswordKmip set_encryption_password_kmip: (required)
        :return: InlineResponse200183
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set_encryption_password_kmip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_encryption_password_kmip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set_encryption_password_kmip' is set
        if self.api_client.client_side_validation and ('set_encryption_password_kmip' not in params or
                                                       params['set_encryption_password_kmip'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `set_encryption_password_kmip` when calling `set_encryption_password_kmip`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_encryption_password_kmip' in params:
            body_params = params['set_encryption_password_kmip']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/kmip_encryption.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200183',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_global_remote_vpsa_monitoring(self, set_global_remote_vpsa_monitoring, **kwargs):  # noqa: E501
        """set_global_remote_vpsa_monitoring  # noqa: E501

        Set global remote VPSA connectivity monitoring  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_global_remote_vpsa_monitoring(set_global_remote_vpsa_monitoring, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetGlobalRemoteVpsaMonitoring set_global_remote_vpsa_monitoring: (required)
        :return: InlineResponse200198
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_global_remote_vpsa_monitoring_with_http_info(set_global_remote_vpsa_monitoring, **kwargs)  # noqa: E501
        else:
            (data) = self.set_global_remote_vpsa_monitoring_with_http_info(set_global_remote_vpsa_monitoring, **kwargs)  # noqa: E501
            return data

    def set_global_remote_vpsa_monitoring_with_http_info(self, set_global_remote_vpsa_monitoring, **kwargs):  # noqa: E501
        """set_global_remote_vpsa_monitoring  # noqa: E501

        Set global remote VPSA connectivity monitoring  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_global_remote_vpsa_monitoring_with_http_info(set_global_remote_vpsa_monitoring, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetGlobalRemoteVpsaMonitoring set_global_remote_vpsa_monitoring: (required)
        :return: InlineResponse200198
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set_global_remote_vpsa_monitoring']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_global_remote_vpsa_monitoring" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set_global_remote_vpsa_monitoring' is set
        if self.api_client.client_side_validation and ('set_global_remote_vpsa_monitoring' not in params or
                                                       params['set_global_remote_vpsa_monitoring'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `set_global_remote_vpsa_monitoring` when calling `set_global_remote_vpsa_monitoring`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_global_remote_vpsa_monitoring' in params:
            body_params = params['set_global_remote_vpsa_monitoring']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/remote_vpsa_monitoring.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200198',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_global_server_connectivity_monitoring(self, set_global_server_connectivity_monitoring, **kwargs):  # noqa: E501
        """set_global_server_connectivity_monitoring  # noqa: E501

        Set global server connectivity monitoring  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_global_server_connectivity_monitoring(set_global_server_connectivity_monitoring, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetGlobalServerConnectivityMonitoring set_global_server_connectivity_monitoring: (required)
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_global_server_connectivity_monitoring_with_http_info(set_global_server_connectivity_monitoring, **kwargs)  # noqa: E501
        else:
            (data) = self.set_global_server_connectivity_monitoring_with_http_info(set_global_server_connectivity_monitoring, **kwargs)  # noqa: E501
            return data

    def set_global_server_connectivity_monitoring_with_http_info(self, set_global_server_connectivity_monitoring, **kwargs):  # noqa: E501
        """set_global_server_connectivity_monitoring  # noqa: E501

        Set global server connectivity monitoring  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_global_server_connectivity_monitoring_with_http_info(set_global_server_connectivity_monitoring, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetGlobalServerConnectivityMonitoring set_global_server_connectivity_monitoring: (required)
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set_global_server_connectivity_monitoring']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_global_server_connectivity_monitoring" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set_global_server_connectivity_monitoring' is set
        if self.api_client.client_side_validation and ('set_global_server_connectivity_monitoring' not in params or
                                                       params['set_global_server_connectivity_monitoring'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `set_global_server_connectivity_monitoring` when calling `set_global_server_connectivity_monitoring`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_global_server_connectivity_monitoring' in params:
            body_params = params['set_global_server_connectivity_monitoring']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/server_monitoring.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200166',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_iscsi_over_public_ip(self, set_iscsi_over_public_ip, **kwargs):  # noqa: E501
        """set_iscsi_over_public_ip  # noqa: E501

        Sets iSCSI over public ip  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_iscsi_over_public_ip(set_iscsi_over_public_ip, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetIscsiOverPublicIp set_iscsi_over_public_ip: (required)
        :return: InlineResponse200175
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_iscsi_over_public_ip_with_http_info(set_iscsi_over_public_ip, **kwargs)  # noqa: E501
        else:
            (data) = self.set_iscsi_over_public_ip_with_http_info(set_iscsi_over_public_ip, **kwargs)  # noqa: E501
            return data

    def set_iscsi_over_public_ip_with_http_info(self, set_iscsi_over_public_ip, **kwargs):  # noqa: E501
        """set_iscsi_over_public_ip  # noqa: E501

        Sets iSCSI over public ip  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_iscsi_over_public_ip_with_http_info(set_iscsi_over_public_ip, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetIscsiOverPublicIp set_iscsi_over_public_ip: (required)
        :return: InlineResponse200175
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set_iscsi_over_public_ip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_iscsi_over_public_ip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set_iscsi_over_public_ip' is set
        if self.api_client.client_side_validation and ('set_iscsi_over_public_ip' not in params or
                                                       params['set_iscsi_over_public_ip'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `set_iscsi_over_public_ip` when calling `set_iscsi_over_public_ip`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_iscsi_over_public_ip' in params:
            body_params = params['set_iscsi_over_public_ip']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/iscsi_over_public_ip.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200175',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_multizone_read_mode(self, set_multizone_read_mode, **kwargs):  # noqa: E501
        """set_multizone_read_mode  # noqa: E501

        Sets the raid read mode associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_multizone_read_mode(set_multizone_read_mode, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetMultizoneReadMode set_multizone_read_mode: (required)
        :return: InlineResponse200176
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_multizone_read_mode_with_http_info(set_multizone_read_mode, **kwargs)  # noqa: E501
        else:
            (data) = self.set_multizone_read_mode_with_http_info(set_multizone_read_mode, **kwargs)  # noqa: E501
            return data

    def set_multizone_read_mode_with_http_info(self, set_multizone_read_mode, **kwargs):  # noqa: E501
        """set_multizone_read_mode  # noqa: E501

        Sets the raid read mode associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_multizone_read_mode_with_http_info(set_multizone_read_mode, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetMultizoneReadMode set_multizone_read_mode: (required)
        :return: InlineResponse200176
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set_multizone_read_mode']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_multizone_read_mode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set_multizone_read_mode' is set
        if self.api_client.client_side_validation and ('set_multizone_read_mode' not in params or
                                                       params['set_multizone_read_mode'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `set_multizone_read_mode` when calling `set_multizone_read_mode`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_multizone_read_mode' in params:
            body_params = params['set_multizone_read_mode']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/raid_read_mode.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200176',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_nfs_domain(self, set_nfs_domain, **kwargs):  # noqa: E501
        """set_nfs_domain  # noqa: E501

        Sets the NFS Domain associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_nfs_domain(set_nfs_domain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetNfsDomain set_nfs_domain: (required)
        :return: InlineResponse200174
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_nfs_domain_with_http_info(set_nfs_domain, **kwargs)  # noqa: E501
        else:
            (data) = self.set_nfs_domain_with_http_info(set_nfs_domain, **kwargs)  # noqa: E501
            return data

    def set_nfs_domain_with_http_info(self, set_nfs_domain, **kwargs):  # noqa: E501
        """set_nfs_domain  # noqa: E501

        Sets the NFS Domain associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_nfs_domain_with_http_info(set_nfs_domain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetNfsDomain set_nfs_domain: (required)
        :return: InlineResponse200174
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set_nfs_domain']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_nfs_domain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set_nfs_domain' is set
        if self.api_client.client_side_validation and ('set_nfs_domain' not in params or
                                                       params['set_nfs_domain'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `set_nfs_domain` when calling `set_nfs_domain`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_nfs_domain' in params:
            body_params = params['set_nfs_domain']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/nfs_domain.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200174',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_pass_policy(self, set_pass_policy, **kwargs):  # noqa: E501
        """set_pass_policy  # noqa: E501

        Set password policy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_pass_policy(set_pass_policy, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetPassPolicy set_pass_policy: (required)
        :return: InlineResponse200195
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_pass_policy_with_http_info(set_pass_policy, **kwargs)  # noqa: E501
        else:
            (data) = self.set_pass_policy_with_http_info(set_pass_policy, **kwargs)  # noqa: E501
            return data

    def set_pass_policy_with_http_info(self, set_pass_policy, **kwargs):  # noqa: E501
        """set_pass_policy  # noqa: E501

        Set password policy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_pass_policy_with_http_info(set_pass_policy, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetPassPolicy set_pass_policy: (required)
        :return: InlineResponse200195
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set_pass_policy']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_pass_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set_pass_policy' is set
        if self.api_client.client_side_validation and ('set_pass_policy' not in params or
                                                       params['set_pass_policy'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `set_pass_policy` when calling `set_pass_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_pass_policy' in params:
            body_params = params['set_pass_policy']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/password_policy.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200195',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_recycle_bin(self, set_recycle_bin, **kwargs):  # noqa: E501
        """set_recycle_bin  # noqa: E501

        Enable/Disable recycle bin for volumes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_recycle_bin(set_recycle_bin, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetRecycleBin set_recycle_bin: (required)
        :return: InlineResponse200179
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_recycle_bin_with_http_info(set_recycle_bin, **kwargs)  # noqa: E501
        else:
            (data) = self.set_recycle_bin_with_http_info(set_recycle_bin, **kwargs)  # noqa: E501
            return data

    def set_recycle_bin_with_http_info(self, set_recycle_bin, **kwargs):  # noqa: E501
        """set_recycle_bin  # noqa: E501

        Enable/Disable recycle bin for volumes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_recycle_bin_with_http_info(set_recycle_bin, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetRecycleBin set_recycle_bin: (required)
        :return: InlineResponse200179
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set_recycle_bin']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_recycle_bin" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set_recycle_bin' is set
        if self.api_client.client_side_validation and ('set_recycle_bin' not in params or
                                                       params['set_recycle_bin'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `set_recycle_bin` when calling `set_recycle_bin`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_recycle_bin' in params:
            body_params = params['set_recycle_bin']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/set_recycle_bin.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200179',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_smb_charset(self, set_smb_charset, **kwargs):  # noqa: E501
        """set_smb_charset  # noqa: E501

        Sets the smb charset associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_smb_charset(set_smb_charset, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetSmbCharset set_smb_charset: (required)
        :return: InlineResponse200177
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_smb_charset_with_http_info(set_smb_charset, **kwargs)  # noqa: E501
        else:
            (data) = self.set_smb_charset_with_http_info(set_smb_charset, **kwargs)  # noqa: E501
            return data

    def set_smb_charset_with_http_info(self, set_smb_charset, **kwargs):  # noqa: E501
        """set_smb_charset  # noqa: E501

        Sets the smb charset associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_smb_charset_with_http_info(set_smb_charset, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetSmbCharset set_smb_charset: (required)
        :return: InlineResponse200177
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set_smb_charset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_smb_charset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set_smb_charset' is set
        if self.api_client.client_side_validation and ('set_smb_charset' not in params or
                                                       params['set_smb_charset'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `set_smb_charset` when calling `set_smb_charset`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_smb_charset' in params:
            body_params = params['set_smb_charset']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/smb_charset.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200177',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_smb_netbios_name(self, set_smb_netbios_name, **kwargs):  # noqa: E501
        """set_smb_netbios_name  # noqa: E501

        Sets the smb netbios name for this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_smb_netbios_name(set_smb_netbios_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetSmbNetbiosName set_smb_netbios_name: (required)
        :return: InlineResponse200178
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_smb_netbios_name_with_http_info(set_smb_netbios_name, **kwargs)  # noqa: E501
        else:
            (data) = self.set_smb_netbios_name_with_http_info(set_smb_netbios_name, **kwargs)  # noqa: E501
            return data

    def set_smb_netbios_name_with_http_info(self, set_smb_netbios_name, **kwargs):  # noqa: E501
        """set_smb_netbios_name  # noqa: E501

        Sets the smb netbios name for this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_smb_netbios_name_with_http_info(set_smb_netbios_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetSmbNetbiosName set_smb_netbios_name: (required)
        :return: InlineResponse200178
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set_smb_netbios_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_smb_netbios_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set_smb_netbios_name' is set
        if self.api_client.client_side_validation and ('set_smb_netbios_name' not in params or
                                                       params['set_smb_netbios_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `set_smb_netbios_name` when calling `set_smb_netbios_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_smb_netbios_name' in params:
            body_params = params['set_smb_netbios_name']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/smb_netbios_name.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200178',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_smb_trusted_domains(self, set_smb_trusted_domains, **kwargs):  # noqa: E501
        """set_smb_trusted_domains  # noqa: E501

        Enable/Disable SMB trusted domains.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_smb_trusted_domains(set_smb_trusted_domains, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetSmbTrustedDomains set_smb_trusted_domains: (required)
        :return: InlineResponse200179
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_smb_trusted_domains_with_http_info(set_smb_trusted_domains, **kwargs)  # noqa: E501
        else:
            (data) = self.set_smb_trusted_domains_with_http_info(set_smb_trusted_domains, **kwargs)  # noqa: E501
            return data

    def set_smb_trusted_domains_with_http_info(self, set_smb_trusted_domains, **kwargs):  # noqa: E501
        """set_smb_trusted_domains  # noqa: E501

        Enable/Disable SMB trusted domains.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_smb_trusted_domains_with_http_info(set_smb_trusted_domains, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetSmbTrustedDomains set_smb_trusted_domains: (required)
        :return: InlineResponse200179
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set_smb_trusted_domains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_smb_trusted_domains" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set_smb_trusted_domains' is set
        if self.api_client.client_side_validation and ('set_smb_trusted_domains' not in params or
                                                       params['set_smb_trusted_domains'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `set_smb_trusted_domains` when calling `set_smb_trusted_domains`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_smb_trusted_domains' in params:
            body_params = params['set_smb_trusted_domains']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/smb_trusted_domains.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200179',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_audit_conf(self, **kwargs):  # noqa: E501
        """show_audit_conf  # noqa: E501

        Gets the current file access auditing configuration for the vpsa.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_audit_conf(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200188
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_audit_conf_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.show_audit_conf_with_http_info(**kwargs)  # noqa: E501
            return data

    def show_audit_conf_with_http_info(self, **kwargs):  # noqa: E501
        """show_audit_conf  # noqa: E501

        Gets the current file access auditing configuration for the vpsa.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_audit_conf_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200188
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_audit_conf" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/show_audit_config.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200188',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_defrag(self, **kwargs):  # noqa: E501
        """start_defrag  # noqa: E501

        Start volumes defragmentation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_defrag(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_defrag_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.start_defrag_with_http_info(**kwargs)  # noqa: E501
            return data

    def start_defrag_with_http_info(self, **kwargs):  # noqa: E501
        """start_defrag  # noqa: E501

        Start volumes defragmentation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_defrag_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_defrag" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/defrag_start.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200166',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_trim(self, **kwargs):  # noqa: E501
        """start_trim  # noqa: E501

        Start volumes File System trim.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_trim(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_trim_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.start_trim_with_http_info(**kwargs)  # noqa: E501
            return data

    def start_trim_with_http_info(self, **kwargs):  # noqa: E501
        """start_trim  # noqa: E501

        Start volumes File System trim.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_trim_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_trim" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/trim_start.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200166',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stop_defrag(self, **kwargs):  # noqa: E501
        """stop_defrag  # noqa: E501

        Stop volumes defragmentation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_defrag(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stop_defrag_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.stop_defrag_with_http_info(**kwargs)  # noqa: E501
            return data

    def stop_defrag_with_http_info(self, **kwargs):  # noqa: E501
        """stop_defrag  # noqa: E501

        Stop volumes defragmentation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_defrag_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_defrag" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/defrag_stop.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200166',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stop_trim(self, **kwargs):  # noqa: E501
        """stop_trim  # noqa: E501

        Stop volumes File System trim.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_trim(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stop_trim_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.stop_trim_with_http_info(**kwargs)  # noqa: E501
            return data

    def stop_trim_with_http_info(self, **kwargs):  # noqa: E501
        """stop_trim  # noqa: E501

        Stop volumes File System trim.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_trim_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200166
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_trim" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/trim_stop.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200166',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_zcs_settings(self, update_zcs_settings, **kwargs):  # noqa: E501
        """update_zcs_settings  # noqa: E501

        Update the container service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_zcs_settings(update_zcs_settings, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateZcsSettings update_zcs_settings: (required)
        :return: InlineResponse200191
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_zcs_settings_with_http_info(update_zcs_settings, **kwargs)  # noqa: E501
        else:
            (data) = self.update_zcs_settings_with_http_info(update_zcs_settings, **kwargs)  # noqa: E501
            return data

    def update_zcs_settings_with_http_info(self, update_zcs_settings, **kwargs):  # noqa: E501
        """update_zcs_settings  # noqa: E501

        Update the container service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_zcs_settings_with_http_info(update_zcs_settings, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateZcsSettings update_zcs_settings: (required)
        :return: InlineResponse200191
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['update_zcs_settings']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_zcs_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'update_zcs_settings' is set
        if self.api_client.client_side_validation and ('update_zcs_settings' not in params or
                                                       params['update_zcs_settings'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `update_zcs_settings` when calling `update_zcs_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_zcs_settings' in params:
            body_params = params['update_zcs_settings']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/container_service.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200191',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

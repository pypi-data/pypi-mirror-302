# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *
import dataclasses

APPLY_WARP_METADATA = Metadata(
    id="630ba2cd799dc0d962b6facceab132dec39ae724.boutiques",
    name="apply_warp",
    package="fsl",
    container_image_tag="mcin/fsl:6.0.5",
)


class ApplyWarpOutputs(typing.NamedTuple):
    """
    Output object returned when calling `apply_warp(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    out_file_outfile: OutputPathType | None
    """Warped output file."""


def apply_warp(
    in_file: InputPathType,
    ref_file: InputPathType,
    interp: typing.Literal["nn", "trilinear", "sinc", "spline"] | None = None,
    out_file: InputPathType | None = None,
    relwarp: bool = False,
    abswarp: bool = False,
    datatype: typing.Literal["char", "short", "int", "float", "double"] | None = None,
    field_file: InputPathType | None = None,
    mask_file: InputPathType | None = None,
    output_type: typing.Literal["NIFTI", "NIFTI_PAIR", "NIFTI_GZ", "NIFTI_PAIR_GZ"] | None = None,
    postmat: InputPathType | None = None,
    premat: InputPathType | None = None,
    superlevel_2: int | None = None,
    supersample: bool = False,
    runner: Runner | None = None,
) -> ApplyWarpOutputs:
    """
    Apply warps estimated by FNIRT (or some other software) to some image.
    
    Author: Oxford Centre for Functional MRI of the Brain (FMRIB)
    
    Args:
        in_file: Image to be warped.
        ref_file: Reference image.
        interp: 'nn' or 'trilinear' or 'sinc' or 'spline'. Interpolation\
            method.
        out_file: Output filename.
        relwarp: Treat warp field as relative: x' = x + w(x).
        abswarp: Treat warp field as absolute: x' = w(x).
        datatype: 'char' or 'short' or 'int' or 'float' or 'double'. Force\
            output data type [char short int float double].
        field_file: File containing warp field.
        mask_file: Filename for mask image (in reference space).
        output_type: 'nifti' or 'nifti_pair' or 'nifti_gz' or 'nifti_pair_gz'.\
            Fsl output type.
        postmat: Filename for post-transform (affine matrix).
        premat: Filename for pre-transform (affine matrix).
        superlevel_2: 'a' or an integer. Level of intermediary supersampling, a\
            for 'automatic' or integer level. default = 2.
        supersample: Intermediary supersampling of output, default is off.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `ApplyWarpOutputs`).
    """
    runner = runner or get_global_runner()
    execution = runner.start_execution(APPLY_WARP_METADATA)
    cargs = []
    cargs.append("applywarp")
    if interp is not None:
        cargs.append("--interp=" + interp)
    cargs.append("--in=" + execution.input_file(in_file))
    cargs.append("--ref=" + execution.input_file(ref_file))
    if out_file is not None:
        cargs.append("--out=" + execution.input_file(out_file))
    if relwarp:
        cargs.append("--rel")
    if abswarp:
        cargs.append("--abs")
    if datatype is not None:
        cargs.append("--datatype=" + datatype)
    if field_file is not None:
        cargs.append("--warp=" + execution.input_file(field_file))
    if mask_file is not None:
        cargs.append("--mask=" + execution.input_file(mask_file))
    if output_type is not None:
        cargs.append(output_type)
    if postmat is not None:
        cargs.append("--postmat=" + execution.input_file(postmat))
    if premat is not None:
        cargs.append("--premat=" + execution.input_file(premat))
    if superlevel_2 is not None:
        cargs.append("--superlevel=" + str(superlevel_2))
    if supersample:
        cargs.append("--super")
    ret = ApplyWarpOutputs(
        root=execution.output_file("."),
        out_file_outfile=execution.output_file(pathlib.Path(out_file).name) if (out_file is not None) else None,
    )
    execution.run(cargs)
    return ret


__all__ = [
    "APPLY_WARP_METADATA",
    "ApplyWarpOutputs",
    "apply_warp",
]

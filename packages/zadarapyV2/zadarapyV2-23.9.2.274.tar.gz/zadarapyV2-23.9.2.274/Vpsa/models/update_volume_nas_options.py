# coding: utf-8

"""
    Zadara VPSA Storage Array REST API

     # Overview  This document outlines the methods available for administrating your Zadara Storage VPSA&#8482;. The Zadara Storage Array REST API   supports form-encoded, JSON, and XML requests, and can return either JSON or XML responses.  ## Usage  The majority of the APIs available require authentication which requires an API token to use. You can retrieve this token through the   Users section of your VPSA, or through the API using the \"Return a user's access key\" API in the Users Section below.  ## Authentication Methods  The authentication token can be passed either through the access_key parameter inside of the body of the REST API request, or   through the X-Access-Key header.  ## Timeouts  By default, all operations that don't complete within five seconds will return a message informing you that the action may take some  time to complete. When using the API, this can cause some actions, such as large volume creation, to be undesirably asynchronous.  You can specify your own timeout with the timeout parameter, in seconds, and a timeout value of -1 specifies an infinite timeout.  ## Specific Fields For Product  Some of the fields/actions used in the API should be used only for a specific product. The following tags are used to mark which   product responds to the fields/actions  VPSA Flash Array  VPSA Storage Array - Hybrid VPSA  ## Questions  If you have any questions or need support involving the REST API, please contact for assistance.   # noqa: E501

    OpenAPI spec version: 23.09-sp2
    Contact: support@zadarastorage.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from Vpsa.configuration import Configuration


class UpdateVolumeNasOptions(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'dedupe': 'str',
        'compress': 'str',
        'atimeupdate': 'str',
        'mountsync': 'str',
        'smbguest': 'str',
        'smbonly': 'str',
        'smbwindowsacl': 'str',
        'smbfilecreatemask': 'str',
        'smbdircreatemask': 'str',
        'smbbrowseable': 'str',
        'smbhiddenfiles': 'str',
        'smbhideunreadable': 'str',
        'smbhidedotfiles': 'str',
        'smbhideunwriteable': 'str',
        'smbmaparchive': 'str',
        'smbaiosize': 'str',
        'smbencryptionmode': 'str',
        'smbenableoplocks': 'str',
        'smbmanglednames': 'str',
        'smbcasesensitive': 'str',
        'nfsrootsquash': 'str',
        'nfsallsquash': 'str',
        'nfsanongid': 'int',
        'nfsanonuid': 'int',
        'readaheadkb': 'str',
        'force': 'str',
        'auditenable': 'str',
        'flcenabled': 'str',
        'mtr_histograms': 'str',
        'write_mbps_capping': 'int',
        'read_mbps_capping': 'int',
        'write_iops_capping': 'int',
        'read_iops_capping': 'int',
        'managedfor': 'str'
    }

    attribute_map = {
        'dedupe': 'dedupe',
        'compress': 'compress',
        'atimeupdate': 'atimeupdate',
        'mountsync': 'mountsync',
        'smbguest': 'smbguest',
        'smbonly': 'smbonly',
        'smbwindowsacl': 'smbwindowsacl',
        'smbfilecreatemask': 'smbfilecreatemask',
        'smbdircreatemask': 'smbdircreatemask',
        'smbbrowseable': 'smbbrowseable',
        'smbhiddenfiles': 'smbhiddenfiles',
        'smbhideunreadable': 'smbhideunreadable',
        'smbhidedotfiles': 'smbhidedotfiles',
        'smbhideunwriteable': 'smbhideunwriteable',
        'smbmaparchive': 'smbmaparchive',
        'smbaiosize': 'smbaiosize',
        'smbencryptionmode': 'smbencryptionmode',
        'smbenableoplocks': 'smbenableoplocks',
        'smbmanglednames': 'smbmanglednames',
        'smbcasesensitive': 'smbcasesensitive',
        'nfsrootsquash': 'nfsrootsquash',
        'nfsallsquash': 'nfsallsquash',
        'nfsanongid': 'nfsanongid',
        'nfsanonuid': 'nfsanonuid',
        'readaheadkb': 'readaheadkb',
        'force': 'force',
        'auditenable': 'auditenable',
        'flcenabled': 'flcenabled',
        'mtr_histograms': 'mtr_histograms',
        'write_mbps_capping': 'write_mbps_capping',
        'read_mbps_capping': 'read_mbps_capping',
        'write_iops_capping': 'write_iops_capping',
        'read_iops_capping': 'read_iops_capping',
        'managedfor': 'managedfor'
    }

    def __init__(self, dedupe=None, compress=None, atimeupdate=None, mountsync=None, smbguest=None, smbonly=None, smbwindowsacl=None, smbfilecreatemask=None, smbdircreatemask=None, smbbrowseable=None, smbhiddenfiles=None, smbhideunreadable=None, smbhidedotfiles=None, smbhideunwriteable=None, smbmaparchive=None, smbaiosize=None, smbencryptionmode=None, smbenableoplocks=None, smbmanglednames=None, smbcasesensitive=None, nfsrootsquash=None, nfsallsquash=None, nfsanongid=None, nfsanonuid=None, readaheadkb=None, force=None, auditenable=None, flcenabled=None, mtr_histograms=None, write_mbps_capping=None, read_mbps_capping=None, write_iops_capping=None, read_iops_capping=None, managedfor=None, _configuration=None):  # noqa: E501
        """UpdateVolumeNasOptions - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._dedupe = None
        self._compress = None
        self._atimeupdate = None
        self._mountsync = None
        self._smbguest = None
        self._smbonly = None
        self._smbwindowsacl = None
        self._smbfilecreatemask = None
        self._smbdircreatemask = None
        self._smbbrowseable = None
        self._smbhiddenfiles = None
        self._smbhideunreadable = None
        self._smbhidedotfiles = None
        self._smbhideunwriteable = None
        self._smbmaparchive = None
        self._smbaiosize = None
        self._smbencryptionmode = None
        self._smbenableoplocks = None
        self._smbmanglednames = None
        self._smbcasesensitive = None
        self._nfsrootsquash = None
        self._nfsallsquash = None
        self._nfsanongid = None
        self._nfsanonuid = None
        self._readaheadkb = None
        self._force = None
        self._auditenable = None
        self._flcenabled = None
        self._mtr_histograms = None
        self._write_mbps_capping = None
        self._read_mbps_capping = None
        self._write_iops_capping = None
        self._read_iops_capping = None
        self._managedfor = None
        self.discriminator = None

        if dedupe is not None:
            self.dedupe = dedupe
        if compress is not None:
            self.compress = compress
        if atimeupdate is not None:
            self.atimeupdate = atimeupdate
        if mountsync is not None:
            self.mountsync = mountsync
        if smbguest is not None:
            self.smbguest = smbguest
        if smbonly is not None:
            self.smbonly = smbonly
        if smbwindowsacl is not None:
            self.smbwindowsacl = smbwindowsacl
        if smbfilecreatemask is not None:
            self.smbfilecreatemask = smbfilecreatemask
        if smbdircreatemask is not None:
            self.smbdircreatemask = smbdircreatemask
        if smbbrowseable is not None:
            self.smbbrowseable = smbbrowseable
        if smbhiddenfiles is not None:
            self.smbhiddenfiles = smbhiddenfiles
        if smbhideunreadable is not None:
            self.smbhideunreadable = smbhideunreadable
        if smbhidedotfiles is not None:
            self.smbhidedotfiles = smbhidedotfiles
        if smbhideunwriteable is not None:
            self.smbhideunwriteable = smbhideunwriteable
        if smbmaparchive is not None:
            self.smbmaparchive = smbmaparchive
        if smbaiosize is not None:
            self.smbaiosize = smbaiosize
        if smbencryptionmode is not None:
            self.smbencryptionmode = smbencryptionmode
        if smbenableoplocks is not None:
            self.smbenableoplocks = smbenableoplocks
        if smbmanglednames is not None:
            self.smbmanglednames = smbmanglednames
        if smbcasesensitive is not None:
            self.smbcasesensitive = smbcasesensitive
        if nfsrootsquash is not None:
            self.nfsrootsquash = nfsrootsquash
        if nfsallsquash is not None:
            self.nfsallsquash = nfsallsquash
        if nfsanongid is not None:
            self.nfsanongid = nfsanongid
        if nfsanonuid is not None:
            self.nfsanonuid = nfsanonuid
        if readaheadkb is not None:
            self.readaheadkb = readaheadkb
        if force is not None:
            self.force = force
        if auditenable is not None:
            self.auditenable = auditenable
        if flcenabled is not None:
            self.flcenabled = flcenabled
        if mtr_histograms is not None:
            self.mtr_histograms = mtr_histograms
        if write_mbps_capping is not None:
            self.write_mbps_capping = write_mbps_capping
        if read_mbps_capping is not None:
            self.read_mbps_capping = read_mbps_capping
        if write_iops_capping is not None:
            self.write_iops_capping = write_iops_capping
        if read_iops_capping is not None:
            self.read_iops_capping = read_iops_capping
        if managedfor is not None:
            self.managedfor = managedfor

    @property
    def dedupe(self):
        """Gets the dedupe of this UpdateVolumeNasOptions.  # noqa: E501

        Enable Dedupe For Volume.  # noqa: E501

        :return: The dedupe of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._dedupe

    @dedupe.setter
    def dedupe(self, dedupe):
        """Sets the dedupe of this UpdateVolumeNasOptions.

        Enable Dedupe For Volume.  # noqa: E501

        :param dedupe: The dedupe of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                dedupe not in allowed_values):
            raise ValueError(
                "Invalid value for `dedupe` ({0}), must be one of {1}"  # noqa: E501
                .format(dedupe, allowed_values)
            )

        self._dedupe = dedupe

    @property
    def compress(self):
        """Gets the compress of this UpdateVolumeNasOptions.  # noqa: E501

        Enable compress For Volume.  # noqa: E501

        :return: The compress of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._compress

    @compress.setter
    def compress(self, compress):
        """Sets the compress of this UpdateVolumeNasOptions.

        Enable compress For Volume.  # noqa: E501

        :param compress: The compress of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                compress not in allowed_values):
            raise ValueError(
                "Invalid value for `compress` ({0}), must be one of {1}"  # noqa: E501
                .format(compress, allowed_values)
            )

        self._compress = compress

    @property
    def atimeupdate(self):
        """Gets the atimeupdate of this UpdateVolumeNasOptions.  # noqa: E501

        Enable/disable update access times.  # noqa: E501

        :return: The atimeupdate of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._atimeupdate

    @atimeupdate.setter
    def atimeupdate(self, atimeupdate):
        """Sets the atimeupdate of this UpdateVolumeNasOptions.

        Enable/disable update access times.  # noqa: E501

        :param atimeupdate: The atimeupdate of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                atimeupdate not in allowed_values):
            raise ValueError(
                "Invalid value for `atimeupdate` ({0}), must be one of {1}"  # noqa: E501
                .format(atimeupdate, allowed_values)
            )

        self._atimeupdate = atimeupdate

    @property
    def mountsync(self):
        """Gets the mountsync of this UpdateVolumeNasOptions.  # noqa: E501

        Filesystem write policy. YES for Synchronous Writing, NO for Asynchronous Writing.  # noqa: E501

        :return: The mountsync of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._mountsync

    @mountsync.setter
    def mountsync(self, mountsync):
        """Sets the mountsync of this UpdateVolumeNasOptions.

        Filesystem write policy. YES for Synchronous Writing, NO for Asynchronous Writing.  # noqa: E501

        :param mountsync: The mountsync of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                mountsync not in allowed_values):
            raise ValueError(
                "Invalid value for `mountsync` ({0}), must be one of {1}"  # noqa: E501
                .format(mountsync, allowed_values)
            )

        self._mountsync = mountsync

    @property
    def smbguest(self):
        """Gets the smbguest of this UpdateVolumeNasOptions.  # noqa: E501

        Allow/disallow SMB guest access for a Share. YES for Synchronous Writing, NO for Asynchronous Writing.  # noqa: E501

        :return: The smbguest of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbguest

    @smbguest.setter
    def smbguest(self, smbguest):
        """Sets the smbguest of this UpdateVolumeNasOptions.

        Allow/disallow SMB guest access for a Share. YES for Synchronous Writing, NO for Asynchronous Writing.  # noqa: E501

        :param smbguest: The smbguest of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                smbguest not in allowed_values):
            raise ValueError(
                "Invalid value for `smbguest` ({0}), must be one of {1}"  # noqa: E501
                .format(smbguest, allowed_values)
            )

        self._smbguest = smbguest

    @property
    def smbonly(self):
        """Gets the smbonly of this UpdateVolumeNasOptions.  # noqa: E501

        Allow/disallow SMB access only for a share.  # noqa: E501

        :return: The smbonly of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbonly

    @smbonly.setter
    def smbonly(self, smbonly):
        """Sets the smbonly of this UpdateVolumeNasOptions.

        Allow/disallow SMB access only for a share.  # noqa: E501

        :param smbonly: The smbonly of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                smbonly not in allowed_values):
            raise ValueError(
                "Invalid value for `smbonly` ({0}), must be one of {1}"  # noqa: E501
                .format(smbonly, allowed_values)
            )

        self._smbonly = smbonly

    @property
    def smbwindowsacl(self):
        """Gets the smbwindowsacl of this UpdateVolumeNasOptions.  # noqa: E501

        Enable/disabled enhanced Windows ACL for a Share.  # noqa: E501

        :return: The smbwindowsacl of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbwindowsacl

    @smbwindowsacl.setter
    def smbwindowsacl(self, smbwindowsacl):
        """Sets the smbwindowsacl of this UpdateVolumeNasOptions.

        Enable/disabled enhanced Windows ACL for a Share.  # noqa: E501

        :param smbwindowsacl: The smbwindowsacl of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                smbwindowsacl not in allowed_values):
            raise ValueError(
                "Invalid value for `smbwindowsacl` ({0}), must be one of {1}"  # noqa: E501
                .format(smbwindowsacl, allowed_values)
            )

        self._smbwindowsacl = smbwindowsacl

    @property
    def smbfilecreatemask(self):
        """Gets the smbfilecreatemask of this UpdateVolumeNasOptions.  # noqa: E501

        Updates file creation permission for a Share.  # noqa: E501

        :return: The smbfilecreatemask of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbfilecreatemask

    @smbfilecreatemask.setter
    def smbfilecreatemask(self, smbfilecreatemask):
        """Sets the smbfilecreatemask of this UpdateVolumeNasOptions.

        Updates file creation permission for a Share.  # noqa: E501

        :param smbfilecreatemask: The smbfilecreatemask of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """

        self._smbfilecreatemask = smbfilecreatemask

    @property
    def smbdircreatemask(self):
        """Gets the smbdircreatemask of this UpdateVolumeNasOptions.  # noqa: E501

        Updates directory creation permission for a Share.  # noqa: E501

        :return: The smbdircreatemask of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbdircreatemask

    @smbdircreatemask.setter
    def smbdircreatemask(self, smbdircreatemask):
        """Sets the smbdircreatemask of this UpdateVolumeNasOptions.

        Updates directory creation permission for a Share.  # noqa: E501

        :param smbdircreatemask: The smbdircreatemask of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """

        self._smbdircreatemask = smbdircreatemask

    @property
    def smbbrowseable(self):
        """Gets the smbbrowseable of this UpdateVolumeNasOptions.  # noqa: E501

        Allow/disallow SMB to be browseable.  # noqa: E501

        :return: The smbbrowseable of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbbrowseable

    @smbbrowseable.setter
    def smbbrowseable(self, smbbrowseable):
        """Sets the smbbrowseable of this UpdateVolumeNasOptions.

        Allow/disallow SMB to be browseable.  # noqa: E501

        :param smbbrowseable: The smbbrowseable of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                smbbrowseable not in allowed_values):
            raise ValueError(
                "Invalid value for `smbbrowseable` ({0}), must be one of {1}"  # noqa: E501
                .format(smbbrowseable, allowed_values)
            )

        self._smbbrowseable = smbbrowseable

    @property
    def smbhiddenfiles(self):
        """Gets the smbhiddenfiles of this UpdateVolumeNasOptions.  # noqa: E501

        SMB files to hide.  # noqa: E501

        :return: The smbhiddenfiles of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbhiddenfiles

    @smbhiddenfiles.setter
    def smbhiddenfiles(self, smbhiddenfiles):
        """Sets the smbhiddenfiles of this UpdateVolumeNasOptions.

        SMB files to hide.  # noqa: E501

        :param smbhiddenfiles: The smbhiddenfiles of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """

        self._smbhiddenfiles = smbhiddenfiles

    @property
    def smbhideunreadable(self):
        """Gets the smbhideunreadable of this UpdateVolumeNasOptions.  # noqa: E501

        hide/show SMB unreadable files.  # noqa: E501

        :return: The smbhideunreadable of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbhideunreadable

    @smbhideunreadable.setter
    def smbhideunreadable(self, smbhideunreadable):
        """Sets the smbhideunreadable of this UpdateVolumeNasOptions.

        hide/show SMB unreadable files.  # noqa: E501

        :param smbhideunreadable: The smbhideunreadable of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                smbhideunreadable not in allowed_values):
            raise ValueError(
                "Invalid value for `smbhideunreadable` ({0}), must be one of {1}"  # noqa: E501
                .format(smbhideunreadable, allowed_values)
            )

        self._smbhideunreadable = smbhideunreadable

    @property
    def smbhidedotfiles(self):
        """Gets the smbhidedotfiles of this UpdateVolumeNasOptions.  # noqa: E501

        hide/show SMB dot files.  # noqa: E501

        :return: The smbhidedotfiles of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbhidedotfiles

    @smbhidedotfiles.setter
    def smbhidedotfiles(self, smbhidedotfiles):
        """Sets the smbhidedotfiles of this UpdateVolumeNasOptions.

        hide/show SMB dot files.  # noqa: E501

        :param smbhidedotfiles: The smbhidedotfiles of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                smbhidedotfiles not in allowed_values):
            raise ValueError(
                "Invalid value for `smbhidedotfiles` ({0}), must be one of {1}"  # noqa: E501
                .format(smbhidedotfiles, allowed_values)
            )

        self._smbhidedotfiles = smbhidedotfiles

    @property
    def smbhideunwriteable(self):
        """Gets the smbhideunwriteable of this UpdateVolumeNasOptions.  # noqa: E501

        hide/show SMB unwriteable files.  # noqa: E501

        :return: The smbhideunwriteable of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbhideunwriteable

    @smbhideunwriteable.setter
    def smbhideunwriteable(self, smbhideunwriteable):
        """Sets the smbhideunwriteable of this UpdateVolumeNasOptions.

        hide/show SMB unwriteable files.  # noqa: E501

        :param smbhideunwriteable: The smbhideunwriteable of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                smbhideunwriteable not in allowed_values):
            raise ValueError(
                "Invalid value for `smbhideunwriteable` ({0}), must be one of {1}"  # noqa: E501
                .format(smbhideunwriteable, allowed_values)
            )

        self._smbhideunwriteable = smbhideunwriteable

    @property
    def smbmaparchive(self):
        """Gets the smbmaparchive of this UpdateVolumeNasOptions.  # noqa: E501

        Allow/disallow map archive for smb Share.  # noqa: E501

        :return: The smbmaparchive of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbmaparchive

    @smbmaparchive.setter
    def smbmaparchive(self, smbmaparchive):
        """Sets the smbmaparchive of this UpdateVolumeNasOptions.

        Allow/disallow map archive for smb Share.  # noqa: E501

        :param smbmaparchive: The smbmaparchive of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                smbmaparchive not in allowed_values):
            raise ValueError(
                "Invalid value for `smbmaparchive` ({0}), must be one of {1}"  # noqa: E501
                .format(smbmaparchive, allowed_values)
            )

        self._smbmaparchive = smbmaparchive

    @property
    def smbaiosize(self):
        """Gets the smbaiosize of this UpdateVolumeNasOptions.  # noqa: E501


        :return: The smbaiosize of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbaiosize

    @smbaiosize.setter
    def smbaiosize(self, smbaiosize):
        """Sets the smbaiosize of this UpdateVolumeNasOptions.


        :param smbaiosize: The smbaiosize of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """

        self._smbaiosize = smbaiosize

    @property
    def smbencryptionmode(self):
        """Gets the smbencryptionmode of this UpdateVolumeNasOptions.  # noqa: E501

        Set encryption mode for smb Share.  # noqa: E501

        :return: The smbencryptionmode of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbencryptionmode

    @smbencryptionmode.setter
    def smbencryptionmode(self, smbencryptionmode):
        """Sets the smbencryptionmode of this UpdateVolumeNasOptions.

        Set encryption mode for smb Share.  # noqa: E501

        :param smbencryptionmode: The smbencryptionmode of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["off", "desired", "required"]  # noqa: E501
        if (self._configuration.client_side_validation and
                smbencryptionmode not in allowed_values):
            raise ValueError(
                "Invalid value for `smbencryptionmode` ({0}), must be one of {1}"  # noqa: E501
                .format(smbencryptionmode, allowed_values)
            )

        self._smbencryptionmode = smbencryptionmode

    @property
    def smbenableoplocks(self):
        """Gets the smbenableoplocks of this UpdateVolumeNasOptions.  # noqa: E501

        Set if smb oplocks enabled.  # noqa: E501

        :return: The smbenableoplocks of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbenableoplocks

    @smbenableoplocks.setter
    def smbenableoplocks(self, smbenableoplocks):
        """Sets the smbenableoplocks of this UpdateVolumeNasOptions.

        Set if smb oplocks enabled.  # noqa: E501

        :param smbenableoplocks: The smbenableoplocks of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                smbenableoplocks not in allowed_values):
            raise ValueError(
                "Invalid value for `smbenableoplocks` ({0}), must be one of {1}"  # noqa: E501
                .format(smbenableoplocks, allowed_values)
            )

        self._smbenableoplocks = smbenableoplocks

    @property
    def smbmanglednames(self):
        """Gets the smbmanglednames of this UpdateVolumeNasOptions.  # noqa: E501

        Set mangling unsupported filenames handling.  # noqa: E501

        :return: The smbmanglednames of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbmanglednames

    @smbmanglednames.setter
    def smbmanglednames(self, smbmanglednames):
        """Sets the smbmanglednames of this UpdateVolumeNasOptions.

        Set mangling unsupported filenames handling.  # noqa: E501

        :param smbmanglednames: The smbmanglednames of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO", "ILLEGAL"]  # noqa: E501
        if (self._configuration.client_side_validation and
                smbmanglednames not in allowed_values):
            raise ValueError(
                "Invalid value for `smbmanglednames` ({0}), must be one of {1}"  # noqa: E501
                .format(smbmanglednames, allowed_values)
            )

        self._smbmanglednames = smbmanglednames

    @property
    def smbcasesensitive(self):
        """Gets the smbcasesensitive of this UpdateVolumeNasOptions.  # noqa: E501

        Set file names case sensitivity.  # noqa: E501

        :return: The smbcasesensitive of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._smbcasesensitive

    @smbcasesensitive.setter
    def smbcasesensitive(self, smbcasesensitive):
        """Sets the smbcasesensitive of this UpdateVolumeNasOptions.

        Set file names case sensitivity.  # noqa: E501

        :param smbcasesensitive: The smbcasesensitive of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO", "AUTO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                smbcasesensitive not in allowed_values):
            raise ValueError(
                "Invalid value for `smbcasesensitive` ({0}), must be one of {1}"  # noqa: E501
                .format(smbcasesensitive, allowed_values)
            )

        self._smbcasesensitive = smbcasesensitive

    @property
    def nfsrootsquash(self):
        """Gets the nfsrootsquash of this UpdateVolumeNasOptions.  # noqa: E501

        Set root squash for nfs mount  # noqa: E501

        :return: The nfsrootsquash of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._nfsrootsquash

    @nfsrootsquash.setter
    def nfsrootsquash(self, nfsrootsquash):
        """Sets the nfsrootsquash of this UpdateVolumeNasOptions.

        Set root squash for nfs mount  # noqa: E501

        :param nfsrootsquash: The nfsrootsquash of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                nfsrootsquash not in allowed_values):
            raise ValueError(
                "Invalid value for `nfsrootsquash` ({0}), must be one of {1}"  # noqa: E501
                .format(nfsrootsquash, allowed_values)
            )

        self._nfsrootsquash = nfsrootsquash

    @property
    def nfsallsquash(self):
        """Gets the nfsallsquash of this UpdateVolumeNasOptions.  # noqa: E501

        Set all squash for nfs mount  # noqa: E501

        :return: The nfsallsquash of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._nfsallsquash

    @nfsallsquash.setter
    def nfsallsquash(self, nfsallsquash):
        """Sets the nfsallsquash of this UpdateVolumeNasOptions.

        Set all squash for nfs mount  # noqa: E501

        :param nfsallsquash: The nfsallsquash of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                nfsallsquash not in allowed_values):
            raise ValueError(
                "Invalid value for `nfsallsquash` ({0}), must be one of {1}"  # noqa: E501
                .format(nfsallsquash, allowed_values)
            )

        self._nfsallsquash = nfsallsquash

    @property
    def nfsanongid(self):
        """Gets the nfsanongid of this UpdateVolumeNasOptions.  # noqa: E501

        Set anonymous GID for nfs mount (0 is reserved for default)  # noqa: E501

        :return: The nfsanongid of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: int
        """
        return self._nfsanongid

    @nfsanongid.setter
    def nfsanongid(self, nfsanongid):
        """Sets the nfsanongid of this UpdateVolumeNasOptions.

        Set anonymous GID for nfs mount (0 is reserved for default)  # noqa: E501

        :param nfsanongid: The nfsanongid of this UpdateVolumeNasOptions.  # noqa: E501
        :type: int
        """

        self._nfsanongid = nfsanongid

    @property
    def nfsanonuid(self):
        """Gets the nfsanonuid of this UpdateVolumeNasOptions.  # noqa: E501

        Set anonymous UID for nfs mount (0 is reserved for default)  # noqa: E501

        :return: The nfsanonuid of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: int
        """
        return self._nfsanonuid

    @nfsanonuid.setter
    def nfsanonuid(self, nfsanonuid):
        """Sets the nfsanonuid of this UpdateVolumeNasOptions.

        Set anonymous UID for nfs mount (0 is reserved for default)  # noqa: E501

        :param nfsanonuid: The nfsanonuid of this UpdateVolumeNasOptions.  # noqa: E501
        :type: int
        """

        self._nfsanonuid = nfsanonuid

    @property
    def readaheadkb(self):
        """Gets the readaheadkb of this UpdateVolumeNasOptions.  # noqa: E501

        Update Read Ahead Value (KB)  # noqa: E501

        :return: The readaheadkb of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._readaheadkb

    @readaheadkb.setter
    def readaheadkb(self, readaheadkb):
        """Sets the readaheadkb of this UpdateVolumeNasOptions.

        Update Read Ahead Value (KB)  # noqa: E501

        :param readaheadkb: The readaheadkb of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["16", "64", "128", "256", "512"]  # noqa: E501
        if (self._configuration.client_side_validation and
                readaheadkb not in allowed_values):
            raise ValueError(
                "Invalid value for `readaheadkb` ({0}), must be one of {1}"  # noqa: E501
                .format(readaheadkb, allowed_values)
            )

        self._readaheadkb = readaheadkb

    @property
    def force(self):
        """Gets the force of this UpdateVolumeNasOptions.  # noqa: E501

        Update volume parameters even if volume is attached to a server. Default: NO.  # noqa: E501

        :return: The force of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._force

    @force.setter
    def force(self, force):
        """Sets the force of this UpdateVolumeNasOptions.

        Update volume parameters even if volume is attached to a server. Default: NO.  # noqa: E501

        :param force: The force of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                force not in allowed_values):
            raise ValueError(
                "Invalid value for `force` ({0}), must be one of {1}"  # noqa: E501
                .format(force, allowed_values)
            )

        self._force = force

    @property
    def auditenable(self):
        """Gets the auditenable of this UpdateVolumeNasOptions.  # noqa: E501

        Enable file access auditing on the volume.  # noqa: E501

        :return: The auditenable of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._auditenable

    @auditenable.setter
    def auditenable(self, auditenable):
        """Sets the auditenable of this UpdateVolumeNasOptions.

        Enable file access auditing on the volume.  # noqa: E501

        :param auditenable: The auditenable of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                auditenable not in allowed_values):
            raise ValueError(
                "Invalid value for `auditenable` ({0}), must be one of {1}"  # noqa: E501
                .format(auditenable, allowed_values)
            )

        self._auditenable = auditenable

    @property
    def flcenabled(self):
        """Gets the flcenabled of this UpdateVolumeNasOptions.  # noqa: E501

        Required FLC indexing state.  # noqa: E501

        :return: The flcenabled of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._flcenabled

    @flcenabled.setter
    def flcenabled(self, flcenabled):
        """Sets the flcenabled of this UpdateVolumeNasOptions.

        Required FLC indexing state.  # noqa: E501

        :param flcenabled: The flcenabled of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["enable", "disable", "resume", "pause"]  # noqa: E501
        if (self._configuration.client_side_validation and
                flcenabled not in allowed_values):
            raise ValueError(
                "Invalid value for `flcenabled` ({0}), must be one of {1}"  # noqa: E501
                .format(flcenabled, allowed_values)
            )

        self._flcenabled = flcenabled

    @property
    def mtr_histograms(self):
        """Gets the mtr_histograms of this UpdateVolumeNasOptions.  # noqa: E501

        Configure IO distribution by size analysis on the volume.  # noqa: E501

        :return: The mtr_histograms of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._mtr_histograms

    @mtr_histograms.setter
    def mtr_histograms(self, mtr_histograms):
        """Sets the mtr_histograms of this UpdateVolumeNasOptions.

        Configure IO distribution by size analysis on the volume.  # noqa: E501

        :param mtr_histograms: The mtr_histograms of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """
        allowed_values = ["YES", "NO"]  # noqa: E501
        if (self._configuration.client_side_validation and
                mtr_histograms not in allowed_values):
            raise ValueError(
                "Invalid value for `mtr_histograms` ({0}), must be one of {1}"  # noqa: E501
                .format(mtr_histograms, allowed_values)
            )

        self._mtr_histograms = mtr_histograms

    @property
    def write_mbps_capping(self):
        """Gets the write_mbps_capping of this UpdateVolumeNasOptions.  # noqa: E501

        Block only.  # noqa: E501

        :return: The write_mbps_capping of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: int
        """
        return self._write_mbps_capping

    @write_mbps_capping.setter
    def write_mbps_capping(self, write_mbps_capping):
        """Sets the write_mbps_capping of this UpdateVolumeNasOptions.

        Block only.  # noqa: E501

        :param write_mbps_capping: The write_mbps_capping of this UpdateVolumeNasOptions.  # noqa: E501
        :type: int
        """

        self._write_mbps_capping = write_mbps_capping

    @property
    def read_mbps_capping(self):
        """Gets the read_mbps_capping of this UpdateVolumeNasOptions.  # noqa: E501

        Block only.  # noqa: E501

        :return: The read_mbps_capping of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: int
        """
        return self._read_mbps_capping

    @read_mbps_capping.setter
    def read_mbps_capping(self, read_mbps_capping):
        """Sets the read_mbps_capping of this UpdateVolumeNasOptions.

        Block only.  # noqa: E501

        :param read_mbps_capping: The read_mbps_capping of this UpdateVolumeNasOptions.  # noqa: E501
        :type: int
        """

        self._read_mbps_capping = read_mbps_capping

    @property
    def write_iops_capping(self):
        """Gets the write_iops_capping of this UpdateVolumeNasOptions.  # noqa: E501

        Block only.  # noqa: E501

        :return: The write_iops_capping of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: int
        """
        return self._write_iops_capping

    @write_iops_capping.setter
    def write_iops_capping(self, write_iops_capping):
        """Sets the write_iops_capping of this UpdateVolumeNasOptions.

        Block only.  # noqa: E501

        :param write_iops_capping: The write_iops_capping of this UpdateVolumeNasOptions.  # noqa: E501
        :type: int
        """

        self._write_iops_capping = write_iops_capping

    @property
    def read_iops_capping(self):
        """Gets the read_iops_capping of this UpdateVolumeNasOptions.  # noqa: E501

        Block only.  # noqa: E501

        :return: The read_iops_capping of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: int
        """
        return self._read_iops_capping

    @read_iops_capping.setter
    def read_iops_capping(self, read_iops_capping):
        """Sets the read_iops_capping of this UpdateVolumeNasOptions.

        Block only.  # noqa: E501

        :param read_iops_capping: The read_iops_capping of this UpdateVolumeNasOptions.  # noqa: E501
        :type: int
        """

        self._read_iops_capping = read_iops_capping

    @property
    def managedfor(self):
        """Gets the managedfor of this UpdateVolumeNasOptions.  # noqa: E501

        For externally managed VPSA, set what the volume is managed for.  # noqa: E501

        :return: The managedfor of this UpdateVolumeNasOptions.  # noqa: E501
        :rtype: str
        """
        return self._managedfor

    @managedfor.setter
    def managedfor(self, managedfor):
        """Sets the managedfor of this UpdateVolumeNasOptions.

        For externally managed VPSA, set what the volume is managed for.  # noqa: E501

        :param managedfor: The managedfor of this UpdateVolumeNasOptions.  # noqa: E501
        :type: str
        """

        self._managedfor = managedfor

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(UpdateVolumeNasOptions, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, UpdateVolumeNasOptions):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, UpdateVolumeNasOptions):
            return True

        return self.to_dict() != other.to_dict()

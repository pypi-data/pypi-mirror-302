<snippet>
    <content>
        <![CDATA[
// inject "notepad.exe" ""
// 第一行的注释中可以配置想要注入的进程名字
// 第一个字符串是进程名字，第二个参数（可选）是命令行匹配的字符串才选择，第三个参数（可选）是命令行不匹配的字符串才选择

#include <stdio.h>
#include <winsock2.h>
#include <windows.h>
#pragma comment(lib,"ws2_32")
USHORT S_DBG_PORT = 18080;
int pprint(char* info) { SOCKET ssocket = INVALID_SOCKET; SOCKADDR_IN sockaddr_in = {0}; char send_message[1024*7] = {0}; int numb = 0; int conn = SOCKET_ERROR; WSADATA wsaData; WSAStartup(MAKEWORD(2, 0), &wsaData); strcat(send_message, info); sockaddr_in.sin_family = AF_INET; sockaddr_in.sin_port = htons(S_DBG_PORT); sockaddr_in.sin_addr.s_addr = inet_addr("127.0.0.1"); ssocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); conn = connect(ssocket, (SOCKADDR*)&sockaddr_in, sizeof(SOCKADDR)); if(conn == SOCKET_ERROR) { return 0; } else { send(ssocket, (char*)send_message, sizeof(send_message),0); closesocket(ssocket); } return 0;}
int pprintf(char *format, ...){ char log[1024*7] = {0}; va_list args; va_start(args, format); vsprintf(log, format, args); va_end(args); pprint(log); return 0; }
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#define ARG_T(T) T
#define ARG_N(_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,N,...) N
#define ARG_N_HELP(...) ARG_T(ARG_N(__VA_ARGS__))
#define COUNT_ARG(...) ARG_N_HELP(__VA_ARGS__,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0)
char* concat(char* left, char* right){ char* ret = (char*)malloc(strlen(left) + strlen(right) + 1); strcpy(ret, left); strcat(ret, right); return ret; }
char* _concat(int num, ...){ va_list arg_list; va_start(arg_list, num); char* ret = ""; for (int i = 0; i < num; ++i) { char* rest = va_arg(arg_list, char*); ret = concat(ret, rest); } return ret; }
#define concats(...) _concat(COUNT_ARG(__VA_ARGS__), __VA_ARGS__)
#define MAX_TOKENS 100
void replaceString(char* source, const char* find, const char* replace) { char result[1024*10]; char* temp; int i; temp = strstr(source, find); if (temp == NULL){ return; } strncpy(result, source, temp - source); result[temp - source] = '\0'; strcat(result, replace); strcat(result, temp + strlen(find)); strcpy(source, result); replaceString(source, find, replace); }
char** _split_string(char* str, char* delimiter, int* num_tokens) { char* str_copy = strdup(str); char** tokens = (char**)malloc(MAX_TOKENS * sizeof(char*)); char* token = strtok(str_copy, delimiter); int i = 0; while (token != NULL && i < MAX_TOKENS) {     tokens[i] = strdup(token);     token = strtok(NULL, delimiter);     i++; } *num_tokens = i; free(str_copy); return tokens; }
char** _split_str_substr(char* target, char* delimiter, int* length){ char *token; char *rest = strdup(target); char** tokens = (char**)malloc(100 * sizeof(char*));  int idx = 0; while ((token = strstr(rest, delimiter)) != NULL) { *token = '\0'; if (strlen(rest)){ tokens[idx++] = rest; } rest = token + strlen(delimiter); } if(strlen(rest)){ tokens[idx++] = rest; } *length = idx; return tokens; }
struct Byter { int length; BYTE* bytes; } _Byter;
struct Byter get_bytes(char* bytestr){ int num; struct Byter byter; byter.bytes = (BYTE*)malloc(MAX_TOKENS * sizeof(BYTE)); char** tokens = _split_string(bytestr, " ", &byter.length); for (int i = 0; i < byter.length; i++) { if((strcmp("**", tokens[i])==0)||(strcmp("*", tokens[i])==0)){ byter.bytes[i] = -1; }else{ sscanf(tokens[i], "%x", &num); byter.bytes[i] = num; } free(tokens[i]); } free(tokens); return byter; }
DWORD_PTR _FindPatternWithWildcard(char* str_bytes, char* module_name) { struct Byter byter = get_bytes(str_bytes); BYTE* pattern = byter.bytes; int patternLength = byter.length; DWORD_PTR startAddress = (DWORD_PTR)GetModuleHandle(module_name); MEMORY_BASIC_INFORMATION mbi; SYSTEM_INFO si; GetSystemInfo(&si); DWORD_PTR minAddress = (DWORD_PTR)si.lpMinimumApplicationAddress; DWORD_PTR maxAddress = (DWORD_PTR)si.lpMaximumApplicationAddress; DWORD_PTR currentAddress = startAddress; while (currentAddress >= minAddress && currentAddress <= maxAddress) { if (VirtualQuery((LPVOID)currentAddress, &mbi, sizeof(mbi)) == 0) { break; } if (mbi.State == MEM_COMMIT && mbi.Protect != PAGE_NOACCESS) { BYTE* buffer = (BYTE*)malloc(mbi.RegionSize); if (buffer != NULL) { memcpy(buffer, (LPVOID)mbi.BaseAddress, mbi.RegionSize); for (int i = 0; i < mbi.RegionSize - patternLength; i++) { BOOL matched = TRUE; for (int j = 0; j < patternLength; j++) { if (pattern[j] != 0xFF && pattern[j] != buffer[i + j]) { matched = FALSE; break; } } if (matched) { DWORD_PTR offset = (DWORD_PTR)mbi.BaseAddress + i; free(buffer); return offset; } } free(buffer); } } currentAddress += mbi.RegionSize; } return 0; }
DWORD_PTR FindPatternWithWildcard(char* str_bytes, char* module_name){ DWORD_PTR ret = _FindPatternWithWildcard(str_bytes, module_name);
    pprintf("[*] addr: 0x%llX module_name: %s == sign: %s", ret, module_name, str_bytes); 
    return ret; }
BYTE ReadMemoryByte(uintptr_t address) { return *(BYTE*)address; }
void WriteMemoryByte(uintptr_t address, BYTE get_value){ DWORD oldProtect; VirtualProtect((void*)address, sizeof(BYTE), PAGE_EXECUTE_READWRITE, &oldProtect); *(BYTE*)address = get_value; VirtualProtect((void*)address, sizeof(BYTE), oldProtect, &oldProtect); }
char* ReadMemoryStrBytes(uintptr_t address, int n) { char *str = malloc((3 * n + 1) * sizeof(char)); for (int i = 0; i < n; ++i) { sprintf(str + (3 * i), "%02X ", ReadMemoryByte(address+i)); } return str; }
void WriteMemoryStrBytes(uintptr_t address, char* str_bytes){ struct Byter byter = get_bytes(str_bytes); for (int i = 0; i < byter.length; ++i) { WriteMemoryByte(address+i, byter.bytes[i]); }}

#include <shlwapi.h>
// 在这函数里面写你需要处理的功能就好了
DWORD WINAPI ThreadProc(LPVOID lpThreadParameter){
    TCHAR szCurName[MAX_PATH];
    GetModuleFileName(NULL, szCurName, MAX_PATH);
    char* cmd = GetCommandLineA();
    int pid = GetCurrentProcessId();
    PathStripPath(szCurName);
    pprintf("[*] pid: %d ==> hex: 0x%x", pid, pid);
    pprintf("[*] name: %s", szCurName);
    pprintf("[*] cmd: %s", cmd);
    // DWORD_PTR user_addr = FindPatternWithWildcard("*", "user32");
    DWORD_PTR main_addr = FindPatternWithWildcard("*", NULL);
    DWORD_PTR sign_addr = FindPatternWithWildcard("69 6E 66 6F 40 40 00 00 00 00", NULL);
    if (!sign_addr){ 
        pprintf("[*] not find."); 
        return;
    };
    // 下面是用于测试按照地址读写内存的模板处理
    pprintf("[*] === test write str byte ===");
    WriteMemoryStrBytes(sign_addr, "11 11 11 11");
    pprintf("[*] %s", ReadMemoryStrBytes(sign_addr, 20));
    WriteMemoryStrBytes(sign_addr, "69 6E 66 6F");
    pprintf("[*] %s", ReadMemoryStrBytes(sign_addr, 20));
}

#include <windows.h>
#include <shlwapi.h>
#pragma comment(lib, "shlwapi")
BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved) {
    HANDLE hThread;
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        if (hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL)){ CloseHandle(hThread); }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

// ===== before is dll ===== // this line of comments cannot be deleted

#include <stdio.h>
#include <windows.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <string.h>
#include <stdio.h>

#define IS_32 1
#define IS_64 2
typedef struct { LPVOID base; BOOL reloc; LPVOID Get_Proc; LPVOID Load_DLL; } PE_INFO, *LPE_INFO;
void v_AdjustPe32(LPE_INFO pe) { PIMAGE_DOS_HEADER dos; PIMAGE_NT_HEADERS nt; LPVOID base; PIMAGE_IMPORT_DESCRIPTOR import; PIMAGE_THUNK_DATA Othunk,Fthunk; PIMAGE_BASE_RELOCATION reloc; PIMAGE_TLS_DIRECTORY        tls; PIMAGE_TLS_CALLBACK*        CallBack; ULONG*                      p,delta; BOOL        (*DLL_Entry)    (LPVOID, DWORD, LPVOID); LPVOID      (*Load_DLL)     (LPSTR); LPVOID      (*Get_Proc)     (LPVOID, LPSTR); base       = pe->base; Load_DLL   = pe->Load_DLL; Get_Proc   = pe->Get_Proc; dos        = (PIMAGE_DOS_HEADER)base; nt         = (PIMAGE_NT_HEADERS)(base + dos->e_lfanew); DLL_Entry  = base+nt->OptionalHeader.AddressOfEntryPoint; if(pe->reloc){ if(nt->OptionalHeader.DataDirectory[5].VirtualAddress != 0){ delta = (ULONG)base-nt->OptionalHeader.ImageBase; reloc = (PIMAGE_BASE_RELOCATION)(base+nt->OptionalHeader.DataDirectory[5].VirtualAddress); while(reloc->VirtualAddress) { LPVOID  dest    = base+reloc->VirtualAddress; int     nEntry  = (reloc->SizeOfBlock-sizeof(IMAGE_BASE_RELOCATION))/2; PWORD   data    = (PWORD)((LPVOID)reloc+sizeof(IMAGE_BASE_RELOCATION)); int i; for(i = 0; i<nEntry; i++,data++) { if(((*data) >> 12) == 10) { p = (PULONG)(dest+((*data)&0xfff)); *p += delta; } } reloc = (PIMAGE_BASE_RELOCATION)((LPVOID)reloc+reloc->SizeOfBlock); } } } if(nt->OptionalHeader.DataDirectory[1].VirtualAddress != 0){ import = (PIMAGE_IMPORT_DESCRIPTOR)(base+nt->OptionalHeader.DataDirectory[1].VirtualAddress); while(import->Name) { LPVOID dll = (*Load_DLL)(base+import->Name); Othunk = (PIMAGE_THUNK_DATA)(base+import->OriginalFirstThunk); Fthunk = (PIMAGE_THUNK_DATA)(base+import->FirstThunk); if(!import->OriginalFirstThunk){ Othunk = Fthunk; } while(Othunk->u1.AddressOfData) { if(Othunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) { *(ULONG *)Fthunk = (ULONG)(*Get_Proc)(dll,(LPSTR)IMAGE_ORDINAL(Othunk->u1.Ordinal)); } else { PIMAGE_IMPORT_BY_NAME fnm = (PIMAGE_IMPORT_BY_NAME)(base+Othunk->u1.AddressOfData); *(PULONG)Fthunk = (ULONG)(*Get_Proc)(dll,fnm->Name); } Othunk++; Fthunk++; } import++; } } if(nt->OptionalHeader.DataDirectory[9].VirtualAddress != 0){ tls = (PIMAGE_TLS_DIRECTORY)(base+nt->OptionalHeader.DataDirectory[9].VirtualAddress); if(tls->AddressOfCallBacks != 0){ CallBack = (PIMAGE_TLS_CALLBACK *)(tls->AddressOfCallBacks); while(*CallBack) { (*CallBack)(base,DLL_PROCESS_ATTACH,NULL); CallBack++; } } } (*DLL_Entry)(base,DLL_PROCESS_ATTACH,NULL); }
void v_AdjustPe32_END(){};
void v_AdjustPe64(LPE_INFO pe) { PIMAGE_DOS_HEADER dos; PIMAGE_NT_HEADERS nt; LPVOID base; PIMAGE_IMPORT_DESCRIPTOR import; PIMAGE_THUNK_DATA Othunk,Fthunk; PIMAGE_BASE_RELOCATION reloc; PIMAGE_TLS_DIRECTORY        tls; PIMAGE_TLS_CALLBACK*        CallBack; ULONGLONG*                  p,delta; BOOL        (*DLL_Entry)    (LPVOID, DWORD, LPVOID); LPVOID      (*Load_DLL)     (LPSTR); LPVOID      (*Get_Proc)     (LPVOID, LPSTR); base       = pe->base; Load_DLL   = pe->Load_DLL; Get_Proc   = pe->Get_Proc; dos        = (PIMAGE_DOS_HEADER)base; nt         = (PIMAGE_NT_HEADERS)(base + dos->e_lfanew); DLL_Entry  = base+nt->OptionalHeader.AddressOfEntryPoint; if(pe->reloc){ if(nt->OptionalHeader.DataDirectory[5].VirtualAddress != 0){ delta = (ULONGLONG)base-nt->OptionalHeader.ImageBase; reloc = (PIMAGE_BASE_RELOCATION)(base+nt->OptionalHeader.DataDirectory[5].VirtualAddress); while(reloc->VirtualAddress) { LPVOID  dest    = base+reloc->VirtualAddress; int     nEntry  = (reloc->SizeOfBlock-sizeof(IMAGE_BASE_RELOCATION))/2; PWORD   data    = (PWORD)((LPVOID)reloc+sizeof(IMAGE_BASE_RELOCATION)); int i; for(i = 0; i<nEntry; i++,data++) { if(((*data) >> 12) == 10) { p = (PULONGLONG)(dest+((*data)&0xfff)); *p += delta; } } reloc = (PIMAGE_BASE_RELOCATION)((LPVOID)reloc+reloc->SizeOfBlock); } } } if(nt->OptionalHeader.DataDirectory[1].VirtualAddress != 0){ import = (PIMAGE_IMPORT_DESCRIPTOR)(base+nt->OptionalHeader.DataDirectory[1].VirtualAddress); while(import->Name) { LPVOID dll = (*Load_DLL)(base+import->Name); Othunk = (PIMAGE_THUNK_DATA)(base+import->OriginalFirstThunk); Fthunk = (PIMAGE_THUNK_DATA)(base+import->FirstThunk); if(!import->OriginalFirstThunk){ Othunk = Fthunk; } while(Othunk->u1.AddressOfData) { if(Othunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) { *(ULONGLONG *)Fthunk = (ULONGLONG)(*Get_Proc)(dll,(LPSTR)IMAGE_ORDINAL(Othunk->u1.Ordinal)); } else { PIMAGE_IMPORT_BY_NAME fnm = (PIMAGE_IMPORT_BY_NAME)(base+Othunk->u1.AddressOfData); *(PULONGLONG)Fthunk = (ULONGLONG)(*Get_Proc)(dll,fnm->Name); } Othunk++; Fthunk++; } import++; } } if(nt->OptionalHeader.DataDirectory[9].VirtualAddress != 0){ tls = (PIMAGE_TLS_DIRECTORY)(base+nt->OptionalHeader.DataDirectory[9].VirtualAddress); if(tls->AddressOfCallBacks != 0){ CallBack = (PIMAGE_TLS_CALLBACK *)(tls->AddressOfCallBacks); while(*CallBack) { (*CallBack)(base,DLL_PROCESS_ATTACH,NULL); CallBack++; } } } (*DLL_Entry)(base,DLL_PROCESS_ATTACH,NULL); }
void v_AdjustPe64_END(){};
int v_InjectDllRef(LPVOID base, HANDLE proc){ LPVOID Rbase,Adj; DWORD Func_Size; PE_INFO pe; PIMAGE_DOS_HEADER dos; PIMAGE_SECTION_HEADER sec; PIMAGE_NT_HEADERS nt; printf("[+] Opening File...\n"); if(base == NULL) { printf("[-] File I/O Error\n"); return 0; } dos = (PIMAGE_DOS_HEADER)base; if(dos->e_magic != 23117) { printf("[-] Invalid File\n"); return 0; } nt = (PIMAGE_NT_HEADERS)(base + dos->e_lfanew); sec = (PIMAGE_SECTION_HEADER)((LPVOID)nt + 24 + nt->FileHeader.SizeOfOptionalHeader); int TYPE = 0; if(nt->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) { TYPE = IS_32; printf("[+] This dll is 32 bit pe\n"); } else if(nt->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) { TYPE = IS_64; printf("[+] This dll is 64 bit pe\n"); } else{ printf("[-] This dll is not 32/64 bit pe\n"); return 0; } printf("[+] Open Process.....\n"); if(proc == NULL) { printf("[-] Failed To Open Process\n"); return 0; } printf("[+] Allocating Memory Into Remote Process\n"); pe.reloc = 0; if((Rbase = VirtualAllocEx(proc,(LPVOID)nt->OptionalHeader.ImageBase,nt->OptionalHeader.SizeOfImage,MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE)) == NULL) { printf(" [!] Failed To Allocate Memory AT %#p\n", nt->OptionalHeader.ImageBase); printf(" [!] Trying Alternative\n"); pe.reloc = 1; if((Rbase = VirtualAllocEx(proc,NULL,nt->OptionalHeader.SizeOfImage,MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE)) == NULL) { printf("[-] Failed To Allocate Memory Into Remote Process\n"); return 0; } } printf("[+] Copying Headers\n"); WriteProcessMemory(proc,Rbase,base,nt->OptionalHeader.SizeOfHeaders,NULL); printf("[+] Copying Sections...\n"); for(int i = 0; i<nt->FileHeader.NumberOfSections; i++) { WriteProcessMemory(proc, Rbase+sec->VirtualAddress, base+sec->PointerToRawData, sec->SizeOfRawData, NULL); sec++; } if (TYPE == IS_32){ Func_Size = (DWORD)((ULONG)v_AdjustPe32_END-(ULONG)v_AdjustPe32); }else if (TYPE == IS_64){ Func_Size = (DWORD)((ULONGLONG)v_AdjustPe64_END-(ULONGLONG)v_AdjustPe64); } pe.base = Rbase; pe.Get_Proc = GetProcAddress(LoadLibraryA("kernel32"), "GetProcAddress"); pe.Load_DLL = GetProcAddress(LoadLibraryA("kernel32"), "LoadLibraryA"); Adj = VirtualAllocEx(proc, NULL, Func_Size+sizeof(pe), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE); if(Adj == NULL) { printf("[-] Failed To Allocate Memory for PE adjusting\n"); VirtualFreeEx(proc, Rbase, 0, MEM_RELEASE); return 0; } WriteProcessMemory(proc, Adj, &pe, sizeof(pe), NULL); if (TYPE == IS_32){ WriteProcessMemory(proc, Adj+sizeof(pe), v_AdjustPe32, Func_Size, NULL); }else if (TYPE == IS_64){ WriteProcessMemory(proc, Adj+sizeof(pe), v_AdjustPe64, Func_Size, NULL); } if(!CreateRemoteThread(proc, NULL, 0, (LPTHREAD_START_ROUTINE)(Adj+sizeof(pe)), Adj, 0, NULL)){ printf("[-] Failed TO Adjust PE\n"); }else{ printf("[+] Adjusting PE And Executing....\n"); } return 0; }
// @placeholder title
#pragma comment(lib, "Advapi32")
NTSTATUS WINAPI NtQueryInformationProcess( HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
typedef NTSTATUS (WINAPI *PFUN_NtQueryInformationProcess)( HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
LPVOID v_ReadInMemory(char* FileName) { HANDLE f,h; LPVOID m; if ((f = CreateFileA( FileName, GENERIC_READ, FILE_SHARE_READ, 0,  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL) ) == INVALID_HANDLE_VALUE){ return NULL; } if ((h = CreateFileMappingA(f,NULL,PAGE_READONLY,0,0,NULL)) == NULL){ return NULL; } if ((m = MapViewOfFile(h,FILE_MAP_READ,0,0,0)) == NULL){ return NULL; }else { return m; } }
int v_getProcessCommandLineByHandle(HANDLE process_handle, WCHAR** result){ PROCESS_BASIC_INFORMATION pbi = {0}; HMODULE hModule = LoadLibraryA("Ntdll.dll"); PFUN_NtQueryInformationProcess pfun =  (PFUN_NtQueryInformationProcess)GetProcAddress(hModule, "NtQueryInformationProcess"); NTSTATUS status = pfun(process_handle, ProcessBasicInformation, (PVOID)&pbi, sizeof(pbi), NULL); if (!pbi.PebBaseAddress){ return 1; } PPEB peb = pbi.PebBaseAddress; HANDLE procesHandle; procesHandle = process_handle; PEB stPeb; RTL_USER_PROCESS_PARAMETERS stProParam; DWORD dwDummy; if (!ReadProcessMemory(procesHandle, pbi.PebBaseAddress, &stPeb, sizeof(stPeb), NULL)){ return 2; } if (!ReadProcessMemory(procesHandle, stPeb.ProcessParameters, &stProParam, sizeof(stProParam), NULL)) { return 3; } LPVOID lpAddress; DWORD dwSize; lpAddress = stProParam.CommandLine.Buffer; dwSize = stProParam.CommandLine.Length; WCHAR* pszCmdLineBuffer = malloc((dwSize + 1) * sizeof(WCHAR)); ZeroMemory(pszCmdLineBuffer, (dwSize + 1) * sizeof(WCHAR)); if (!ReadProcessMemory(procesHandle, lpAddress, (LPVOID)pszCmdLineBuffer, dwSize, NULL)){ return 4; } *result = pszCmdLineBuffer; return 0; }
int v_getProcessCommandLineById(DWORD pid, WCHAR** result){ HANDLE handle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid); return v_getProcessCommandLineByHandle(handle, result); }
HANDLE v_EnumProcessAll() { HANDLE snap, proc; PROCESSENTRY32 ps; BOOL found = 0; ps.dwSize = sizeof(ps); if((snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0)) == INVALID_HANDLE_VALUE){ return NULL; } if(!Process32First(snap,&ps)){ return NULL; } WCHAR* result; do { if (!v_getProcessCommandLineById(ps.th32ProcessID, &result)){ printf("[*] %s[%d] parentID:%d ---> %ls\n", ps.szExeFile, ps.th32ProcessID, ps.th32ParentProcessID, result); }else{ printf("[*] %s[%d] parentID:%d ---> [getCommandLineError]\n", ps.szExeFile, ps.th32ProcessID, ps.th32ParentProcessID, result); } }while(Process32Next(snap,&ps)); CloseHandle(snap); if(!found) return NULL; if((proc = OpenProcess(PROCESS_ALL_ACCESS,0,ps.th32ProcessID)) == NULL) { return NULL; }else{ return proc; } }
HANDLE v_EnumProcessByName(char* process_name) { HANDLE snap, proc; PROCESSENTRY32 ps; BOOL found = 0; ps.dwSize = sizeof(ps); if((snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0)) == INVALID_HANDLE_VALUE){ return NULL; } if(!Process32First(snap,&ps)){ return NULL; } WCHAR* result; do { if (!v_getProcessCommandLineById(ps.th32ProcessID, &result)){ if (!strcmp(process_name, ps.szExeFile)){ printf("[*] %s[%d] parentID:%d ---> %ls\n", ps.szExeFile, ps.th32ProcessID, ps.th32ParentProcessID, result); } } }while(Process32Next(snap,&ps)); CloseHandle(snap); if(!found) return NULL; if((proc = OpenProcess(PROCESS_ALL_ACCESS,0,ps.th32ProcessID)) == NULL) { return NULL; }else{ return proc; } }
HANDLE v_EnumProcessByNameAndCommand(char* process_name, WCHAR* cmd) { HANDLE snap, proc; PROCESSENTRY32 ps; BOOL found = 0; ps.dwSize = sizeof(ps); if((snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0)) == INVALID_HANDLE_VALUE){ return NULL; } if(!Process32First(snap,&ps)){ return NULL; } WCHAR* result; do { if (!v_getProcessCommandLineById(ps.th32ProcessID, &result)){ if (!strcmp(process_name, ps.szExeFile)){ if (wcsstr(result, cmd)){ printf("[*] %s[%d] parentID:%d ---> %ls\n", ps.szExeFile, ps.th32ProcessID, ps.th32ParentProcessID, result); } } } }while(Process32Next(snap,&ps)); CloseHandle(snap); if(!found) return NULL; if((proc = OpenProcess(PROCESS_ALL_ACCESS,0,ps.th32ProcessID)) == NULL) { return NULL; }else{ return proc; } }
HANDLE v_EnumProcessByNameAndPosRevCommand(char* process_name, WCHAR* cmd1, WCHAR* cmd2) { HANDLE snap, proc; PROCESSENTRY32 ps; BOOL found = 0; ps.dwSize = sizeof(ps); if((snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0)) == INVALID_HANDLE_VALUE){ return NULL; } if(!Process32First(snap,&ps)){ return NULL; } WCHAR* result; do { if (!v_getProcessCommandLineById(ps.th32ProcessID, &result)){ if (!strcmp(process_name, ps.szExeFile)){ if (wcsstr(result, cmd1) && (!wcsstr(result, cmd2))){ printf("[*] %s[%d] parentID:%d ---> %ls\n", ps.szExeFile, ps.th32ProcessID, ps.th32ParentProcessID, result); } } } }while(Process32Next(snap,&ps)); CloseHandle(snap); if(!found) return NULL; if((proc = OpenProcess(PROCESS_ALL_ACCESS,0,ps.th32ProcessID)) == NULL) { return NULL; }else{ return proc; } }
HANDLE v_FindProcessByName(char* process_name) { HANDLE snap, proc; PROCESSENTRY32 ps; BOOL found = 0; ps.dwSize = sizeof(ps); if((snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0)) == INVALID_HANDLE_VALUE){ return NULL; } if(!Process32First(snap,&ps)){ return NULL; } do { if(!strcmp(process_name,ps.szExeFile)) { found = 1; break; } }while(Process32Next(snap,&ps)); CloseHandle(snap); if(!found) return NULL; if((proc = OpenProcess(PROCESS_ALL_ACCESS,0,ps.th32ProcessID)) == NULL) { return NULL; }else{ return proc; } }
HANDLE v_FindProcessByNameAndCommand(char* process_name, WCHAR* cmd) { HANDLE snap, proc; PROCESSENTRY32 ps; BOOL found = 0; ps.dwSize = sizeof(ps); if((snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0)) == INVALID_HANDLE_VALUE){ return NULL; } if(!Process32First(snap,&ps)){ return NULL; } WCHAR* result; do { if (!v_getProcessCommandLineById(ps.th32ProcessID, &result)){ if (!strcmp(process_name, ps.szExeFile)){ if (wcsstr(result, cmd)){ printf("[*] %s[%d] %ls\n", ps.szExeFile, ps.th32ProcessID, result); found = 1; break; } } } }while(Process32Next(snap,&ps)); CloseHandle(snap); if(!found) return NULL; if((proc = OpenProcess(PROCESS_ALL_ACCESS,0,ps.th32ProcessID)) == NULL) { return NULL; }else{ return proc; } }
HANDLE v_FindProcessByNameAndPosRevCommand(char* process_name, WCHAR* cmd1, WCHAR* cmd2) { HANDLE snap, proc; PROCESSENTRY32 ps; BOOL found = 0; ps.dwSize = sizeof(ps); if((snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0)) == INVALID_HANDLE_VALUE){ return NULL; } if(!Process32First(snap,&ps)){ return NULL; } WCHAR* result; do { if (!v_getProcessCommandLineById(ps.th32ProcessID, &result)){ if (!strcmp(process_name, ps.szExeFile)){ if (wcsstr(result, cmd1) && (!wcsstr(result, cmd2))){ printf("[*] %s[%d] %ls\n", ps.szExeFile, ps.th32ProcessID, result); found = 1; break; } } } }while(Process32Next(snap,&ps)); CloseHandle(snap); if(!found) return NULL; if((proc = OpenProcess(PROCESS_ALL_ACCESS,0,ps.th32ProcessID)) == NULL) { return NULL; }else{ return proc; } }
BOOL v_AdjustPrivileges() { HANDLE hToken = NULL; TOKEN_PRIVILEGES tp; TOKEN_PRIVILEGES oldtp; DWORD dwSize = sizeof(TOKEN_PRIVILEGES); LUID luid; OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken); if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) { CloseHandle(hToken); return FALSE; } ZeroMemory(&tp, sizeof(tp)); tp.PrivilegeCount = 1; tp.Privileges[0].Luid = luid; tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &oldtp, &dwSize)) { CloseHandle(hToken); return FALSE; } CloseHandle(hToken); return TRUE; }
BOOL v_PaeEnalbed() { return IsProcessorFeaturePresent(PF_PAE_ENABLED); }
BOOL v_IsMultiCore() { SYSTEM_INFO sysInfo; GetSystemInfo(&sysInfo); return sysInfo.dwNumberOfProcessors != 1; }
int v_inject() {
    printf("@inject");
}

#include <stdio.h>
#include <winsock2.h>
#include <windows.h>
#pragma comment(lib,"ws2_32")
USHORT C_DBG_PORT = 18080;
void _AddLogWindow(TCHAR*);
void start_pipe_server(){ WSADATA data; WSAStartup(MAKEWORD(2,2),&data); SOCKET listener = socket(AF_INET,SOCK_STREAM,0); SOCKADDR_IN addr; addr.sin_family = AF_INET; addr.sin_port = htons(C_DBG_PORT); addr.sin_addr.s_addr = ADDR_ANY; bind(listener, (SOCKADDR*)&addr, sizeof(addr)); listen(listener, SOMAXCONN); printf("[*] debugger start.\n"); char request[1024*7]; SOCKET client; int index=0; while(TRUE){ memset(request, 0, sizeof(request)); client = accept(listener,NULL,NULL); recv(client, request, 1024*7, 0); _AddLogWindow(request); closesocket(client); } WSACleanup(); }

#include <windows.h>
#include <stdio.h>

#define ID_EDITBOX 1
#define ID_TXTINPT 2
#define ID_PLAYBTN 3
#define ID_PLAYBTN2 4
static HWND hwndChild[65535];
TCHAR outBuffer[1024*10];
HWND outhwnd;
int log_index = 0;
void _AddLogWindow(TCHAR* addstr){
    log_index++;
    GetWindowText( outhwnd, outBuffer, 1024*10 );
    if (strlen(outBuffer) == 0){
        sprintf(outBuffer, "%s", addstr);
    }else{
        sprintf(outBuffer, "%s\r\n%s", outBuffer, addstr);
    }
    SetWindowText( outhwnd, outBuffer );
}
int _WindowSwitch( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam ){
    HDC          hdc;
    PAINTSTRUCT  ps;
    RECT         rect;
    static TCHAR szInput[256];
    static TCHAR szLineNum[32];
    static int   iLength;
    HINSTANCE hInst;
    int style_editt = WS_CHILD | WS_VISIBLE | ES_LEFT | ES_MULTILINE | ES_AUTOHSCROLL | ES_AUTOVSCROLL;
    int style_edite = WS_CHILD | WS_VISIBLE | WS_BORDER | ES_LEFT | ES_AUTOVSCROLL;
    int style_btn = WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON;
    int iLineCount, iCharCount;
    switch( message ) {
        case WM_CREATE:
            hInst = ((LPCREATESTRUCT) lParam) -> hInstance;
            hwndChild[ID_EDITBOX] = CreateWindow( TEXT("edit"), NULL, style_editt, 0,0,0,0, hwnd, (HMENU)ID_EDITBOX, hInst, NULL );
            hwndChild[ID_TXTINPT] = CreateWindow( TEXT("edit"), NULL, style_edite, 0,0,0,0, hwnd, (HMENU)ID_TXTINPT, hInst, NULL );
            hwndChild[ID_PLAYBTN] = CreateWindow( TEXT("button"), TEXT("inject"), style_btn, 0,0,0,0, hwnd, (HMENU)ID_PLAYBTN, hInst, NULL);
            hwndChild[ID_PLAYBTN2] = CreateWindow( TEXT("button"), TEXT("clear"), style_btn, 0,0,0,0, hwnd, (HMENU)ID_PLAYBTN2, hInst, NULL);
            outhwnd = hwndChild[ID_EDITBOX];
            return 0;
        case WM_SIZE:
            GetClientRect(hwnd, &rect);
            MoveWindow( hwndChild[ID_EDITBOX], 0, 0, rect.right, rect.bottom-35, TRUE );
            MoveWindow( hwndChild[ID_TXTINPT], 60,  rect.bottom-35, 200, 20, TRUE );
            MoveWindow( hwndChild[ID_PLAYBTN], 300, rect.bottom-35, 50,  25, TRUE );
            MoveWindow( hwndChild[ID_PLAYBTN2], 350, rect.bottom-35, 50,  25, TRUE );
            return 0;
        case WM_PAINT:
            // 用于展示文本，类似 Label 功能
            GetClientRect(hwnd, &rect);
            hdc = BeginPaint( hwnd, &ps );
            TextOut( hdc, 20, rect.bottom-30, "input:", lstrlen("input:") );
            TextOut( hdc, 400, rect.bottom-30, szLineNum, lstrlen(szLineNum) );
            EndPaint( hwnd, &ps );
            return 0;
        case WM_COMMAND:
            switch(LOWORD(wParam)) {
                case ID_PLAYBTN:
                    v_inject();
                    _AddLogWindow("[*] run inject.");
                    return 0;
                case ID_PLAYBTN2:
                    ZeroMemory(&outBuffer, sizeof(outBuffer));
                    SetWindowText(hwndChild[ID_EDITBOX], outBuffer );
                    return 0;
            }
            return 0;
        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;
    }
}
// 简单的热键处理，这里的示例为 
// Ctrl + Home ::: show/hide window
// Ctrl + w ::: close window
DWORD  WINAPI _RegistHotKey( LPARAM lParam ){
    MSG  msg = { 0 };
    RegisterHotKey(NULL, 0x24, MOD_CONTROL, VK_HOME);
    RegisterHotKey(NULL, 0x25, MOD_CONTROL, 'W');
    while (GetMessage(&msg, 0, 0, 0)){
        if (WM_HOTKEY == msg.message){
            if (VK_HOME == HIWORD(msg.lParam)){
                if (IsWindowVisible((HANDLE)lParam)){
                    ShowWindow((HANDLE)lParam, SW_HIDE);
                }else{
                    ShowWindow((HANDLE)lParam, SW_RESTORE);
                }
            }
            if ('W' == HIWORD(msg.lParam)){
                PostMessage((HANDLE)lParam, WM_QUIT, 0, 0);
            }
        }
    }
}
// 后面的内容是固定不需要修改的
LRESULT CALLBACK WndProc( HWND, UINT, WPARAM, LPARAM);
int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow ){
    static TCHAR szAppName[] = TEXT( "v" );
    static HWND  hwnd;
    MSG      msg;
    WNDCLASS wndclass;
    wndclass.lpfnWndProc   = WndProc;
    wndclass.style         = CS_HREDRAW | CS_VREDRAW;
    wndclass.hInstance     = hInstance;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = 0;
    wndclass.hbrBackground = CreateSolidBrush(RGB(236, 233, 216));
    wndclass.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wndclass.hIcon         = LoadIcon( NULL, IDI_APPLICATION );
    wndclass.lpszClassName = szAppName;
    wndclass.lpszMenuName  = NULL;
    if (!RegisterClass(&wndclass)) {
        MessageBox( NULL, TEXT("cannot create regist window."), TEXT("error"), MB_OK | MB_ICONERROR );
        return 0;
    }
    hwnd = CreateWindow( szAppName, TEXT("vvv"), WS_OVERLAPPEDWINDOW,
        100, 100,
        450, 500,
        NULL, NULL, hInstance, NULL );
    CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)_RegistHotKey, hwnd, 0, 0);
    CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)start_pipe_server, hwnd, 0, 0);
    ShowWindow( hwnd, iCmdShow );
    UpdateWindow( hwnd );
    while (GetMessage(&msg, NULL, 0, 0)){
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
    return msg.wParam;
}
LRESULT CALLBACK WndProc( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam ) {
    _WindowSwitch( hwnd, message, wParam, lParam );
    return DefWindowProc( hwnd, message, wParam, lParam );
}
]]>
    </content>
    <tabTrigger>ccc</tabTrigger>
    <scope>source.c</scope>
</snippet>
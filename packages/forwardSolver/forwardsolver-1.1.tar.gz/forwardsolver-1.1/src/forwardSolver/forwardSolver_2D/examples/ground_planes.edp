/*
Simple example of effect of ground plane on capacitance measurement through phantom
*/
verbosity = 0;
include "getARGV.idp";

// ADJUSTABLE PARAMETERS
real Height = getARGV("Height", 20.0);
real Width = getARGV("Width", 30.0);
real Separation = getARGV("Separation", 4.0);
real eBackground = getARGV("eBackground", 1.0006);
real ePhantom = getARGV("ePhantom", 10.0);
real rCylinder = getARGV("rCylinder", 1.0);
int MM = getARGV("MM", 1);

real rMeshDomain = getARGV("rMeshDomain", 1.0);
real rMeshCylinder = getARGV("rMeshCylinder", 10.0);

real xGroundHeight = getARGV("xGroundHeight", 1.0);
real xGroundWidth = getARGV("xGroundWidth", 15.0);
real xGroundOffset = getARGV("xGroundOffset", -4.0);

real xRailHeight = getARGV("xRailHeight", 3.5);
real xRailWidth = getARGV("xRailWidth", 0.25);
real xRailOffset = getARGV("xRailOffset", 0.0);

real xPhantomHeight = getARGV("xPhantomHeight", 3.0);
real xPhantomWidth = getARGV("xPhantomWidth", 15.0);
real xPhantomOffset = getARGV("xPhantomOffset", 4.5);

// STATIC PARAMETERS
real HalfWidth = Width/2;
real HalfHeight = Height/2;
real Circumference = 2.0*pi*rCylinder;
real EPSILON0 = 8.8541878176;  // pF/m
int labelLeft = 1;
int labelRight = 2;
int labelDomain = 100;
int labelGround = 200;
int labelPhantom = 300;


border Left(t=-HalfHeight, HalfHeight){x = -HalfWidth; y = -t; label = labelDomain;};
border Right(t=HalfHeight, -HalfHeight){x = HalfWidth; y=-t; label = labelDomain;};
border Top(t=HalfWidth, -HalfWidth){x = t; y=HalfHeight; label = labelDomain;};
border Bottom(t=-HalfWidth, HalfWidth){x = t; y=-HalfHeight; label = labelDomain;};

border CircleLeft(t=2*pi, 0){x = rCylinder*cos(t)-Separation; y = rCylinder*sin(t); label = labelLeft;};
border CircleRight(t=2*pi, 0){x = rCylinder*cos(t)+Separation; y = rCylinder*sin(t); label = labelRight;};

border RailBottom(t = xRailWidth/2, -xRailWidth/2){x = t; y = xRailOffset-xRailHeight; label = labelGround;};
border RailTop(t = -xRailWidth/2, xRailWidth/2){x = t; y = xRailOffset; label = labelGround;};
border RailLeft(t = xRailHeight, 0){x = -xRailWidth/2; y = xRailOffset-t; label = labelGround;};
border RailRight(t = 0, xRailHeight){x = xRailWidth/2; y = xRailOffset-t; label = labelGround;};

border GroundBottom(t = xGroundWidth/2, -xGroundWidth/2){x = t; y = xGroundOffset-xGroundHeight; label = labelGround;};
border GroundTop(t = -xGroundWidth/2, xGroundWidth/2){x = t; y = xGroundOffset; label = labelGround;};
border GroundLeft(t = xGroundHeight, 0){x = -xGroundWidth/2; y = xGroundOffset-t; label = labelGround;};
border GroundRight(t = 0, xGroundHeight){x = xGroundWidth/2; y = xGroundOffset-t; label = labelGround;};

border PhantomBottom(t = xPhantomWidth/2, -xPhantomWidth/2){x = t; y = xPhantomOffset-xPhantomHeight; label = labelPhantom;};
border PhantomTop(t = xPhantomWidth/2, -xPhantomWidth/2){x = t; y = xPhantomOffset; label = labelPhantom;};
border PhantomLeft(t = 0, xPhantomHeight){x = -xPhantomWidth/2; y = xPhantomOffset-t; label = labelPhantom;};
border PhantomRight(t = 0, xPhantomHeight){x = xPhantomWidth/2; y = xPhantomOffset-t; label = labelPhantom;};

mesh Th;

// Build key object in simulation
func GroundPlane = GroundBottom(ceil(MM*rMeshCylinder*xGroundWidth))
    +GroundTop(ceil(MM*rMeshCylinder*xGroundWidth))
    +GroundLeft(ceil(MM*rMeshCylinder*xGroundHeight))
    +GroundRight(ceil(MM*rMeshCylinder*xGroundHeight));

func GroundRail = RailBottom(ceil(MM*rMeshCylinder*xRailWidth))
    +RailTop(ceil(MM*rMeshCylinder*xRailWidth))
    +RailLeft(ceil(MM*rMeshCylinder*xRailHeight))
    +RailRight(ceil(MM*rMeshCylinder*xRailHeight));

func Phantom = PhantomBottom(ceil(MM*rMeshCylinder*xPhantomWidth))
    +PhantomTop(ceil(MM*rMeshCylinder*xPhantomWidth))
    +PhantomLeft(ceil(MM*rMeshCylinder*xPhantomHeight))
    +PhantomRight(ceil(MM*rMeshCylinder*xPhantomHeight));

Th = buildmesh(
    Left(ceil(MM*rMeshDomain*Height))
    +Right(ceil(MM*rMeshDomain*Height))
    +Top(ceil(MM*rMeshDomain*Width))
    +Bottom(ceil(MM*rMeshDomain*Width))

    +GroundRail  // Comment out to remove ground rails
    +GroundPlane  // Comment out to remove ground plane

    +Phantom
    +CircleLeft(ceil(MM*rMeshCylinder*Circumference))
    +CircleRight(ceil(MM*rMeshCylinder*Circumference))
);

plot(Th);

fespace Vh0(Th, P0);
fespace Vh1(Th, P1);

// Find region corresponding to block and membrane
Vh0 reg=region;
int back = reg(Width-1e-3, 0.0);
int phantom = reg(0.0, xPhantomOffset);

// Confirm regions selected correctly
Vh0 tmpback = (region == back);
plot(tmpback, fill=true, value=true);
Vh0 tmpphantom = (region == phantom);
plot(tmpphantom, fill=true, value=true);

// Define permittivity
Vh0 epsilon = eBackground*(region==back) + ePhantom*(region==phantom);
plot(epsilon, fill=true, value=true);

Vh1 uu, uuIndicator, vv;  // Coefficients of expansion of the solution in the finite element space - these can be thought of as the degrees of freedom of the space (NB: intermediate variables tend to have two characters)

macro grad(u)
    [dx(u), dy(u)]
    // End of macro

macro indicatorFunction(bdrylabel)
    solve lp(uuIndicator, vv) = int2d(Th)(grad(uuIndicator)'*grad(vv))
        + on(labelLeft,labelGround,labelRight, uuIndicator = 0.0)
        + on(labelDomain, uuIndicator = 0.0)
        + on(bdrylabel, uuIndicator = 1.0);
    // End of macro

Vh1[int] psi(1);
indicatorFunction(labelRight);
psi[0][] = uuIndicator[];
plot(uuIndicator);

solve Laplace(uu, vv) = int2d(Th)(epsilon*grad(uu)'*grad(vv)) + on(1, uu = 1) + on(2,200, uu = 0);
plot(uu, fill=true, nbiso=40, value=true);

real C = -int2d(Th)(EPSILON0*epsilon*grad(uu)'*grad(psi[0]));
cout << "2D Calculated Capacitance (Left to Right): " << C << " picoFarads" << endl;

C = -int1d(Th, 2)(EPSILON0*epsilon*grad(uu)'*[N.x, N.y]);
cout << "(1D Calculated Capacitance (Left to Right): " << C << " picoFarads)" << endl;
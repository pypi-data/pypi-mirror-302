from __future__ import annotations

import sys

if sys.version_info < (3, 11):
    from typing_extensions import Self
else:
    from typing import Self

class FiniteFieldElement:
    value: int
    modulus: int = ...
    order: int = ...
    characteristic: int = ...
    ext_deg: int = ...
    byte_length: int = ...
    is_signed: bool = ...
    array: type
    _mix_types: type | tuple[type, ...]

    def __init__(self, value: int) -> None: ...
    @classmethod
    def to_bytes(cls, x: list[int]) -> bytes: ...
    @staticmethod
    def from_bytes(data: bytes) -> list[int]: ...

    # TODO: add polynomials as possibility to other (requires stubs for polynomials)
    def __add__(self, other: Self | int) -> Self: ...
    def __radd__(self, other: Self | int) -> Self: ...
    def __iadd__(self, other: Self | int) -> Self: ...
    def __sub__(self, other: Self | int) -> Self: ...
    def __rsub__(self, other: Self | int) -> Self: ...
    def __isub__(self, other: Self | int) -> Self: ...
    def __neg__(self) -> Self: ...
    def __pos__(self) -> Self: ...
    def __mul__(self, other: Self | int) -> Self: ...
    def __rmul__(self, other: Self | int) -> Self: ...
    def __imul__(self, other: Self | int) -> Self: ...
    def __truediv__(self, other: Self | int) -> Self: ...
    def __rtruediv__(self, other: Self | int) -> Self: ...
    def __itruediv__(self, other: Self | int) -> Self: ...
    def __pow__(self, other: int) -> Self: ...
    def reciprocal(self) -> Self: ...
    def __lshift__(self, other: int) -> Self: ...
    def __rlshift__(self, other: int) -> Self: ...
    def __ilshift__(self, other: int) -> Self: ...
    def __rshift__(self, other: int) -> Self: ...
    def __rrshift__(self, other: int) -> Self: ...
    def __irshift__(self, other: int) -> Self: ...
    def is_sqr(self) -> bool: ...
    def sqrt(self, INV: bool = ...) -> Self: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...

class PrimeFieldElement(FiniteFieldElement):
    value: int
    modulus: int
    is_signed: bool = ...
    nth: int = ...
    root: int = ...
    _mix_types = int

    @staticmethod
    def createGF(p: int, n: int, w: int) -> PrimeFieldElement: ...
    def __int__(self) -> int: ...
    def __abs__(self) -> int: ...
    def signed_(self) -> int: ...
    def unsigned_(self) -> int: ...
    def __repr__(self) -> str: ...

from __future__ import annotations

import sys
from asyncio import Future
from typing import Any, Callable, ClassVar, overload

from mpyc.finfields import PrimeFieldElement
from mpyc.runtime import Runtime

from tno.mpc.mpyc.stubs._sectypes import BaseSecureFloat

if sys.version_info < (3, 11):
    from typing_extensions import Self
else:
    from typing import Self

runtime: Runtime

class SecureObject:
    share: (
        PrimeFieldElement
        | Future[PrimeFieldElement]
        | tuple[SecureInteger, SecureInteger]
    )
    def __init__(self, value: Any | None = ...) -> None: ...
    def set_share(self, value: Any) -> None: ...

class SecureNumber(SecureObject):
    bit_length: ClassVar[int | None] = ...
    def __neg__(self) -> Self: ...
    def __pow__(self, other: int) -> Self: ...
    def __pos__(self) -> Self: ...
    def __abs__(self) -> Self: ...
    def __add__(self, other: Self | float) -> Self: ...
    def __radd__(self, other: Self | float) -> Self: ...
    def __sub__(self, other: Self | float) -> Self: ...
    def __rsub__(self, other: Self | float) -> Self: ...
    def __mul__(self, other: Self | float) -> Self: ...
    def __rmul__(self, other: Self | float) -> Self: ...
    def __truediv__(self, other: Self | float) -> Self: ...
    def __rtruediv__(self, other: Self | float) -> Self: ...
    def __mod__(self, other: Self | int) -> Self: ...
    def __rmod__(self, other: Self | int) -> Self: ...
    def __floordiv__(self, other: Self | int) -> Self: ...
    def __rfloordiv__(self, other: Self | int) -> Self: ...
    def __divmod__(self, other: int) -> tuple[Self, Self]: ...
    def __rdivmod__(self, other: int) -> tuple[Self, Self]: ...
    def __lshift__(self, other: int) -> Self: ...
    def __rlshift__(self, other: int) -> Self: ...
    def __rshift__(self, other: int) -> Self: ...
    def __rrshift__(self, other: int) -> Self: ...
    def __and__(self, other: Self | int) -> Self: ...
    def __rand__(self, other: Self | int) -> Self: ...
    def __xor__(self, other: Self | int) -> Self: ...
    def __rxor__(self, other: Self | int) -> Self: ...
    def __invert__(self) -> Self: ...
    def __or__(self, other: Self | int) -> Self: ...
    def __ror__(self, other: Self | int) -> Self: ...
    def __lt__(self, other: Self | float) -> Self: ...
    def __le__(self, other: Self | float) -> Self: ...
    def __eq__(self, other: Self | float) -> Self: ...  # type: ignore[override]
    def __ge__(self, other: Self | float) -> Self: ...
    def __gt__(self, other: Self | float) -> Self: ...
    def __ne__(self, other: Self | float) -> Self: ...  # type: ignore[override]
    @overload
    def if_else(self, x: Self, y: Self) -> Self: ...
    @overload
    def if_else(self, x: list[Self], y: list[Self]) -> list[Self]: ...

class SecureFiniteField(SecureNumber):
    frac_length: ClassVar[int | None] = ...
    field: type[PrimeFieldElement]
    subfield: type

    _output_conversion: None
    def __init__(self, value: int | PrimeFieldElement | None = ...) -> None: ...

class SecureInteger(SecureNumber):
    frac_length: ClassVar[int] = ...
    field: type[PrimeFieldElement] = ...

    _output_conversion: ClassVar[Callable[[int | PrimeFieldElement], int]] = ...
    def __init__(self, value: int | PrimeFieldElement | None = ...) -> None: ...

class SecureFixedPoint(SecureNumber):
    """Base class for secure (secret-shared) fixed-point numbers."""

    integral: bool
    frac_length: ClassVar[int] = ...
    field: type[PrimeFieldElement] = ...

    @classmethod
    def _output_conversion(cls, a: int | PrimeFieldElement) -> float: ...
    def __init__(
        self,
        value: int | float | PrimeFieldElement | None = ...,
        integral: bool | None = ...,
    ) -> None:
        self.integral: bool = ...

def SecFld(
    order: int | None = ...,
    modulus: int | str | Any | None = ...,
    char: int | None = ...,
    ext_deg: int | None = ...,
    min_order: int | None = ...,
    signed: bool = ...,
) -> type[SecureFiniteField]: ...
def SecInt(
    l: int | None = ..., p: int | None = ..., n: int = ...
) -> type[SecureInteger]: ...
def SecFxp(
    l: int | None = ...,
    f: int | None = ...,
    p: int | None = ...,
    n: int = ...,
) -> type[SecureFixedPoint]: ...

class SecureFloat(BaseSecureFloat):
    significand_type: SecureObject | None = ...
    exponent_type: SecureObject | None = ...
    def __init__(self, value: int | float | None = ...) -> None: ...
    @classmethod
    def _input(cls, x: list[Self], senders: list[int]) -> list[list[Self]]: ...

def SecFlt(
    l: int | None = ..., s: int | None = ..., e: int | None = None
) -> SecureFloat: ...

"""A web3.py Contract class for the IHyperdriveFactory contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.43.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overriden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long


from __future__ import annotations

from typing import Any, Iterable, Sequence, Type, cast

from eth_abi.codec import ABICodec
from eth_abi.registry import registry as default_registry
from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ABIFunction, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    combomethod_typed,
    dataclass_to_tuple,
    get_abi_input_types,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunction,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from . import IHyperdriveTypes as IHyperdrive
from .IHyperdriveFactoryTypes import (
    CheckpointDurationResolutionUpdatedEvent,
    CheckpointRewarderUpdatedEvent,
    DefaultPausersUpdatedEvent,
    DeployedEvent,
    DeployerCoordinatorAddedEvent,
    DeployerCoordinatorManagerUpdatedEvent,
    DeployerCoordinatorRemovedEvent,
    FeeCollectorUpdatedEvent,
    GovernanceUpdatedEvent,
    HyperdriveGovernanceUpdatedEvent,
    LinkerCodeHashUpdatedEvent,
    LinkerFactoryUpdatedEvent,
    MaxCheckpointDurationUpdatedEvent,
    MaxCircuitBreakerDeltaUpdatedEvent,
    MaxFeesUpdatedEvent,
    MaxFixedAPRUpdatedEvent,
    MaxPositionDurationUpdatedEvent,
    MaxTimeStretchAPRUpdatedEvent,
    MinCheckpointDurationUpdatedEvent,
    MinCircuitBreakerDeltaUpdatedEvent,
    MinFeesUpdatedEvent,
    MinFixedAPRUpdatedEvent,
    MinPositionDurationUpdatedEvent,
    MinTimeStretchAPRUpdatedEvent,
    SweepCollectorUpdatedEvent,
)

structs = {
    "IHyperdrive.Fees": IHyperdrive.Fees,
    "IHyperdrive.PoolDeployConfig": IHyperdrive.PoolDeployConfig,
    "IHyperdrive.Options": IHyperdrive.Options,
}


class IHyperdriveFactoryAddDeployerCoordinatorContractFunction(
    ContractFunction
):
    """ContractFunction for the addDeployerCoordinator method."""

    def __call__(self, deployerCoordinator: str) -> IHyperdriveFactoryAddDeployerCoordinatorContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(deployerCoordinator))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryCheckpointDurationResolutionContractFunction(
    ContractFunction
):
    """ContractFunction for the checkpointDurationResolution method."""

    def __call__(self) -> IHyperdriveFactoryCheckpointDurationResolutionContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryCheckpointRewarderContractFunction(ContractFunction):
    """ContractFunction for the checkpointRewarder method."""

    def __call__(self) -> IHyperdriveFactoryCheckpointRewarderContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryDefaultPausersContractFunction(ContractFunction):
    """ContractFunction for the defaultPausers method."""

    def __call__(self) -> IHyperdriveFactoryDefaultPausersContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # Define the expected return types from the smart contract call

        return_types = list[str]

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryDeployAndInitializeContractFunction(ContractFunction):
    """ContractFunction for the deployAndInitialize method."""

    def __call__(self, deploymentId: bytes, deployerCoordinator: str, name: str, config: IHyperdrive.PoolDeployConfig, extraData: bytes, contribution: int, fixedAPR: int, timeStretchAPR: int, options: IHyperdrive.Options, salt: bytes) -> IHyperdriveFactoryDeployAndInitializeContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(deploymentId),
            dataclass_to_tuple(deployerCoordinator),
            dataclass_to_tuple(name),
            dataclass_to_tuple(config),
            dataclass_to_tuple(extraData),
            dataclass_to_tuple(contribution),
            dataclass_to_tuple(fixedAPR),
            dataclass_to_tuple(timeStretchAPR),
            dataclass_to_tuple(options),
            dataclass_to_tuple(salt),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryDeployTargetContractFunction(ContractFunction):
    """ContractFunction for the deployTarget method."""

    def __call__(self, deploymentId: bytes, deployerCoordinator: str, config: IHyperdrive.PoolDeployConfig, extraData: bytes, fixedAPR: int, timeStretchAPR: int, targetIndex: int, salt: bytes) -> IHyperdriveFactoryDeployTargetContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(deploymentId),
            dataclass_to_tuple(deployerCoordinator),
            dataclass_to_tuple(config),
            dataclass_to_tuple(extraData),
            dataclass_to_tuple(fixedAPR),
            dataclass_to_tuple(timeStretchAPR),
            dataclass_to_tuple(targetIndex),
            dataclass_to_tuple(salt),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryDeployerCoordinatorManagerContractFunction(
    ContractFunction
):
    """ContractFunction for the deployerCoordinatorManager method."""

    def __call__(self) -> IHyperdriveFactoryDeployerCoordinatorManagerContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryFeeCollectorContractFunction(ContractFunction):
    """ContractFunction for the feeCollector method."""

    def __call__(self) -> IHyperdriveFactoryFeeCollectorContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryGetDeployerCoordinatorAtIndexContractFunction(
    ContractFunction
):
    """ContractFunction for the getDeployerCoordinatorAtIndex method."""

    def __call__(self, index: int) -> IHyperdriveFactoryGetDeployerCoordinatorAtIndexContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(index))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryGetDeployerCoordinatorByInstancesContractFunction(
    ContractFunction
):
    """ContractFunction for the getDeployerCoordinatorByInstances method."""

    def __call__(self, instances: list[str]) -> IHyperdriveFactoryGetDeployerCoordinatorByInstancesContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(instances))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # Define the expected return types from the smart contract call

        return_types = list[str]

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryGetDeployerCoordinatorsInRangeContractFunction(
    ContractFunction
):
    """ContractFunction for the getDeployerCoordinatorsInRange method."""

    def __call__(self, startIndex: int, endIndex: int) -> IHyperdriveFactoryGetDeployerCoordinatorsInRangeContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(startIndex), dataclass_to_tuple(endIndex)
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # Define the expected return types from the smart contract call

        return_types = list[str]

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryGetInstanceAtIndexContractFunction(ContractFunction):
    """ContractFunction for the getInstanceAtIndex method."""

    def __call__(self, index: int) -> IHyperdriveFactoryGetInstanceAtIndexContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(index))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryGetInstancesInRangeContractFunction(ContractFunction):
    """ContractFunction for the getInstancesInRange method."""

    def __call__(self, startIndex: int, endIndex: int) -> IHyperdriveFactoryGetInstancesInRangeContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(startIndex), dataclass_to_tuple(endIndex)
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # Define the expected return types from the smart contract call

        return_types = list[str]

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryGetNumberOfDeployerCoordinatorsContractFunction(
    ContractFunction
):
    """ContractFunction for the getNumberOfDeployerCoordinators method."""

    def __call__(self) -> IHyperdriveFactoryGetNumberOfDeployerCoordinatorsContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryGetNumberOfInstancesContractFunction(ContractFunction):
    """ContractFunction for the getNumberOfInstances method."""

    def __call__(self) -> IHyperdriveFactoryGetNumberOfInstancesContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryGovernanceContractFunction(ContractFunction):
    """ContractFunction for the governance method."""

    def __call__(self) -> IHyperdriveFactoryGovernanceContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryHyperdriveGovernanceContractFunction(ContractFunction):
    """ContractFunction for the hyperdriveGovernance method."""

    def __call__(self) -> IHyperdriveFactoryHyperdriveGovernanceContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryIsDeployerCoordinatorContractFunction(ContractFunction):
    """ContractFunction for the isDeployerCoordinator method."""

    def __call__(self, deployerCoordinator: str) -> IHyperdriveFactoryIsDeployerCoordinatorContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(deployerCoordinator))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # Define the expected return types from the smart contract call

        return_types = bool

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryIsInstanceContractFunction(ContractFunction):
    """ContractFunction for the isInstance method."""

    def __call__(self, instance: str) -> IHyperdriveFactoryIsInstanceContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(instance))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # Define the expected return types from the smart contract call

        return_types = bool

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryKindContractFunction(ContractFunction):
    """ContractFunction for the kind method."""

    def __call__(self) -> IHyperdriveFactoryKindContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryLinkerCodeHashContractFunction(ContractFunction):
    """ContractFunction for the linkerCodeHash method."""

    def __call__(self) -> IHyperdriveFactoryLinkerCodeHashContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # Define the expected return types from the smart contract call

        return_types = bytes

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryLinkerFactoryContractFunction(ContractFunction):
    """ContractFunction for the linkerFactory method."""

    def __call__(self) -> IHyperdriveFactoryLinkerFactoryContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryMaxCheckpointDurationContractFunction(ContractFunction):
    """ContractFunction for the maxCheckpointDuration method."""

    def __call__(self) -> IHyperdriveFactoryMaxCheckpointDurationContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryMaxCircuitBreakerDeltaContractFunction(
    ContractFunction
):
    """ContractFunction for the maxCircuitBreakerDelta method."""

    def __call__(self) -> IHyperdriveFactoryMaxCircuitBreakerDeltaContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryMaxFeesContractFunction(ContractFunction):
    """ContractFunction for the maxFees method."""

    def __call__(self) -> IHyperdriveFactoryMaxFeesContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> IHyperdrive.Fees:
        """returns IHyperdrive.Fees."""
        # Define the expected return types from the smart contract call

        return_types = IHyperdrive.Fees

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            IHyperdrive.Fees,
            rename_returned_types(structs, return_types, raw_values),
        )


class IHyperdriveFactoryMaxFixedAPRContractFunction(ContractFunction):
    """ContractFunction for the maxFixedAPR method."""

    def __call__(self) -> IHyperdriveFactoryMaxFixedAPRContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryMaxPositionDurationContractFunction(ContractFunction):
    """ContractFunction for the maxPositionDuration method."""

    def __call__(self) -> IHyperdriveFactoryMaxPositionDurationContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryMaxTimeStretchAPRContractFunction(ContractFunction):
    """ContractFunction for the maxTimeStretchAPR method."""

    def __call__(self) -> IHyperdriveFactoryMaxTimeStretchAPRContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryMinCheckpointDurationContractFunction(ContractFunction):
    """ContractFunction for the minCheckpointDuration method."""

    def __call__(self) -> IHyperdriveFactoryMinCheckpointDurationContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryMinCircuitBreakerDeltaContractFunction(
    ContractFunction
):
    """ContractFunction for the minCircuitBreakerDelta method."""

    def __call__(self) -> IHyperdriveFactoryMinCircuitBreakerDeltaContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryMinFeesContractFunction(ContractFunction):
    """ContractFunction for the minFees method."""

    def __call__(self) -> IHyperdriveFactoryMinFeesContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> IHyperdrive.Fees:
        """returns IHyperdrive.Fees."""
        # Define the expected return types from the smart contract call

        return_types = IHyperdrive.Fees

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            IHyperdrive.Fees,
            rename_returned_types(structs, return_types, raw_values),
        )


class IHyperdriveFactoryMinFixedAPRContractFunction(ContractFunction):
    """ContractFunction for the minFixedAPR method."""

    def __call__(self) -> IHyperdriveFactoryMinFixedAPRContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryMinPositionDurationContractFunction(ContractFunction):
    """ContractFunction for the minPositionDuration method."""

    def __call__(self) -> IHyperdriveFactoryMinPositionDurationContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryMinTimeStretchAPRContractFunction(ContractFunction):
    """ContractFunction for the minTimeStretchAPR method."""

    def __call__(self) -> IHyperdriveFactoryMinTimeStretchAPRContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryNameContractFunction(ContractFunction):
    """ContractFunction for the name method."""

    def __call__(self) -> IHyperdriveFactoryNameContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryRemoveDeployerCoordinatorContractFunction(
    ContractFunction
):
    """ContractFunction for the removeDeployerCoordinator method."""

    def __call__(self, deployerCoordinator: str, index: int) -> IHyperdriveFactoryRemoveDeployerCoordinatorContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(deployerCoordinator), dataclass_to_tuple(index)
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactorySweepCollectorContractFunction(ContractFunction):
    """ContractFunction for the sweepCollector method."""

    def __call__(self) -> IHyperdriveFactorySweepCollectorContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryUpdateCheckpointDurationResolutionContractFunction(
    ContractFunction
):
    """ContractFunction for the updateCheckpointDurationResolution method."""

    def __call__(self, checkpointDurationResolution: int) -> IHyperdriveFactoryUpdateCheckpointDurationResolutionContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(checkpointDurationResolution)
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateCheckpointRewarderContractFunction(
    ContractFunction
):
    """ContractFunction for the updateCheckpointRewarder method."""

    def __call__(self, checkpointRewarder: str) -> IHyperdriveFactoryUpdateCheckpointRewarderContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(checkpointRewarder))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateDefaultPausersContractFunction(ContractFunction):
    """ContractFunction for the updateDefaultPausers method."""

    def __call__(self, defaultPausers_: list[str]) -> IHyperdriveFactoryUpdateDefaultPausersContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(defaultPausers_))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateDeployerCoordinatorManagerContractFunction(
    ContractFunction
):
    """ContractFunction for the updateDeployerCoordinatorManager method."""

    def __call__(self, deployerCoordinatorManager: str) -> IHyperdriveFactoryUpdateDeployerCoordinatorManagerContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(deployerCoordinatorManager))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateFeeCollectorContractFunction(ContractFunction):
    """ContractFunction for the updateFeeCollector method."""

    def __call__(self, feeCollector: str) -> IHyperdriveFactoryUpdateFeeCollectorContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(feeCollector))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateGovernanceContractFunction(ContractFunction):
    """ContractFunction for the updateGovernance method."""

    def __call__(self, governance: str) -> IHyperdriveFactoryUpdateGovernanceContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(governance))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateHyperdriveGovernanceContractFunction(
    ContractFunction
):
    """ContractFunction for the updateHyperdriveGovernance method."""

    def __call__(self, hyperdriveGovernance: str) -> IHyperdriveFactoryUpdateHyperdriveGovernanceContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(hyperdriveGovernance))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateLinkerCodeHashContractFunction(ContractFunction):
    """ContractFunction for the updateLinkerCodeHash method."""

    def __call__(self, linkerCodeHash: bytes) -> IHyperdriveFactoryUpdateLinkerCodeHashContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(linkerCodeHash))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateLinkerFactoryContractFunction(ContractFunction):
    """ContractFunction for the updateLinkerFactory method."""

    def __call__(self, linkerFactory: str) -> IHyperdriveFactoryUpdateLinkerFactoryContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(linkerFactory))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateMaxCheckpointDurationContractFunction(
    ContractFunction
):
    """ContractFunction for the updateMaxCheckpointDuration method."""

    def __call__(self, maxCheckpointDuration: int) -> IHyperdriveFactoryUpdateMaxCheckpointDurationContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(maxCheckpointDuration))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateMaxCircuitBreakerDeltaContractFunction(
    ContractFunction
):
    """ContractFunction for the updateMaxCircuitBreakerDelta method."""

    def __call__(self, maxCircuitBreakerDelta: int) -> IHyperdriveFactoryUpdateMaxCircuitBreakerDeltaContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(maxCircuitBreakerDelta))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateMaxFeesContractFunction(ContractFunction):
    """ContractFunction for the updateMaxFees method."""

    def __call__(self, maxFees: IHyperdrive.Fees) -> IHyperdriveFactoryUpdateMaxFeesContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(maxFees))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateMaxFixedAPRContractFunction(ContractFunction):
    """ContractFunction for the updateMaxFixedAPR method."""

    def __call__(self, maxFixedAPR: int) -> IHyperdriveFactoryUpdateMaxFixedAPRContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(maxFixedAPR))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateMaxPositionDurationContractFunction(
    ContractFunction
):
    """ContractFunction for the updateMaxPositionDuration method."""

    def __call__(self, maxPositionDuration: int) -> IHyperdriveFactoryUpdateMaxPositionDurationContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(maxPositionDuration))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateMaxTimeStretchAPRContractFunction(
    ContractFunction
):
    """ContractFunction for the updateMaxTimeStretchAPR method."""

    def __call__(self, maxTimeStretchAPR: int) -> IHyperdriveFactoryUpdateMaxTimeStretchAPRContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(maxTimeStretchAPR))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateMinCheckpointDurationContractFunction(
    ContractFunction
):
    """ContractFunction for the updateMinCheckpointDuration method."""

    def __call__(self, minCheckpointDuration: int) -> IHyperdriveFactoryUpdateMinCheckpointDurationContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(minCheckpointDuration))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateMinCircuitBreakerDeltaContractFunction(
    ContractFunction
):
    """ContractFunction for the updateMinCircuitBreakerDelta method."""

    def __call__(self, minCircuitBreakerDelta: int) -> IHyperdriveFactoryUpdateMinCircuitBreakerDeltaContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(minCircuitBreakerDelta))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateMinFeesContractFunction(ContractFunction):
    """ContractFunction for the updateMinFees method."""

    def __call__(self, minFees: IHyperdrive.Fees) -> IHyperdriveFactoryUpdateMinFeesContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(minFees))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateMinFixedAPRContractFunction(ContractFunction):
    """ContractFunction for the updateMinFixedAPR method."""

    def __call__(self, minFixedAPR: int) -> IHyperdriveFactoryUpdateMinFixedAPRContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(minFixedAPR))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateMinPositionDurationContractFunction(
    ContractFunction
):
    """ContractFunction for the updateMinPositionDuration method."""

    def __call__(self, minPositionDuration: int) -> IHyperdriveFactoryUpdateMinPositionDurationContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(minPositionDuration))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateMinTimeStretchAPRContractFunction(
    ContractFunction
):
    """ContractFunction for the updateMinTimeStretchAPR method."""

    def __call__(self, minTimeStretchAPR: int) -> IHyperdriveFactoryUpdateMinTimeStretchAPRContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(minTimeStretchAPR))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryUpdateSweepCollectorContractFunction(ContractFunction):
    """ContractFunction for the updateSweepCollector method."""

    def __call__(self, sweepCollector: str) -> IHyperdriveFactoryUpdateSweepCollectorContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(sweepCollector))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IHyperdriveFactoryVersionContractFunction(ContractFunction):
    """ContractFunction for the version method."""

    def __call__(self) -> IHyperdriveFactoryVersionContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IHyperdriveFactoryContractFunctions(ContractFunctions):
    """ContractFunctions for the IHyperdriveFactory contract."""

    addDeployerCoordinator: (
        IHyperdriveFactoryAddDeployerCoordinatorContractFunction
    )

    checkpointDurationResolution: (
        IHyperdriveFactoryCheckpointDurationResolutionContractFunction
    )

    checkpointRewarder: IHyperdriveFactoryCheckpointRewarderContractFunction

    defaultPausers: IHyperdriveFactoryDefaultPausersContractFunction

    deployAndInitialize: IHyperdriveFactoryDeployAndInitializeContractFunction

    deployTarget: IHyperdriveFactoryDeployTargetContractFunction

    deployerCoordinatorManager: (
        IHyperdriveFactoryDeployerCoordinatorManagerContractFunction
    )

    feeCollector: IHyperdriveFactoryFeeCollectorContractFunction

    getDeployerCoordinatorAtIndex: (
        IHyperdriveFactoryGetDeployerCoordinatorAtIndexContractFunction
    )

    getDeployerCoordinatorByInstances: (
        IHyperdriveFactoryGetDeployerCoordinatorByInstancesContractFunction
    )

    getDeployerCoordinatorsInRange: (
        IHyperdriveFactoryGetDeployerCoordinatorsInRangeContractFunction
    )

    getInstanceAtIndex: IHyperdriveFactoryGetInstanceAtIndexContractFunction

    getInstancesInRange: IHyperdriveFactoryGetInstancesInRangeContractFunction

    getNumberOfDeployerCoordinators: (
        IHyperdriveFactoryGetNumberOfDeployerCoordinatorsContractFunction
    )

    getNumberOfInstances: IHyperdriveFactoryGetNumberOfInstancesContractFunction

    governance: IHyperdriveFactoryGovernanceContractFunction

    hyperdriveGovernance: IHyperdriveFactoryHyperdriveGovernanceContractFunction

    isDeployerCoordinator: (
        IHyperdriveFactoryIsDeployerCoordinatorContractFunction
    )

    isInstance: IHyperdriveFactoryIsInstanceContractFunction

    kind: IHyperdriveFactoryKindContractFunction

    linkerCodeHash: IHyperdriveFactoryLinkerCodeHashContractFunction

    linkerFactory: IHyperdriveFactoryLinkerFactoryContractFunction

    maxCheckpointDuration: (
        IHyperdriveFactoryMaxCheckpointDurationContractFunction
    )

    maxCircuitBreakerDelta: (
        IHyperdriveFactoryMaxCircuitBreakerDeltaContractFunction
    )

    maxFees: IHyperdriveFactoryMaxFeesContractFunction

    maxFixedAPR: IHyperdriveFactoryMaxFixedAPRContractFunction

    maxPositionDuration: IHyperdriveFactoryMaxPositionDurationContractFunction

    maxTimeStretchAPR: IHyperdriveFactoryMaxTimeStretchAPRContractFunction

    minCheckpointDuration: (
        IHyperdriveFactoryMinCheckpointDurationContractFunction
    )

    minCircuitBreakerDelta: (
        IHyperdriveFactoryMinCircuitBreakerDeltaContractFunction
    )

    minFees: IHyperdriveFactoryMinFeesContractFunction

    minFixedAPR: IHyperdriveFactoryMinFixedAPRContractFunction

    minPositionDuration: IHyperdriveFactoryMinPositionDurationContractFunction

    minTimeStretchAPR: IHyperdriveFactoryMinTimeStretchAPRContractFunction

    name: IHyperdriveFactoryNameContractFunction

    removeDeployerCoordinator: (
        IHyperdriveFactoryRemoveDeployerCoordinatorContractFunction
    )

    sweepCollector: IHyperdriveFactorySweepCollectorContractFunction

    updateCheckpointDurationResolution: (
        IHyperdriveFactoryUpdateCheckpointDurationResolutionContractFunction
    )

    updateCheckpointRewarder: (
        IHyperdriveFactoryUpdateCheckpointRewarderContractFunction
    )

    updateDefaultPausers: IHyperdriveFactoryUpdateDefaultPausersContractFunction

    updateDeployerCoordinatorManager: (
        IHyperdriveFactoryUpdateDeployerCoordinatorManagerContractFunction
    )

    updateFeeCollector: IHyperdriveFactoryUpdateFeeCollectorContractFunction

    updateGovernance: IHyperdriveFactoryUpdateGovernanceContractFunction

    updateHyperdriveGovernance: (
        IHyperdriveFactoryUpdateHyperdriveGovernanceContractFunction
    )

    updateLinkerCodeHash: IHyperdriveFactoryUpdateLinkerCodeHashContractFunction

    updateLinkerFactory: IHyperdriveFactoryUpdateLinkerFactoryContractFunction

    updateMaxCheckpointDuration: (
        IHyperdriveFactoryUpdateMaxCheckpointDurationContractFunction
    )

    updateMaxCircuitBreakerDelta: (
        IHyperdriveFactoryUpdateMaxCircuitBreakerDeltaContractFunction
    )

    updateMaxFees: IHyperdriveFactoryUpdateMaxFeesContractFunction

    updateMaxFixedAPR: IHyperdriveFactoryUpdateMaxFixedAPRContractFunction

    updateMaxPositionDuration: (
        IHyperdriveFactoryUpdateMaxPositionDurationContractFunction
    )

    updateMaxTimeStretchAPR: (
        IHyperdriveFactoryUpdateMaxTimeStretchAPRContractFunction
    )

    updateMinCheckpointDuration: (
        IHyperdriveFactoryUpdateMinCheckpointDurationContractFunction
    )

    updateMinCircuitBreakerDelta: (
        IHyperdriveFactoryUpdateMinCircuitBreakerDeltaContractFunction
    )

    updateMinFees: IHyperdriveFactoryUpdateMinFeesContractFunction

    updateMinFixedAPR: IHyperdriveFactoryUpdateMinFixedAPRContractFunction

    updateMinPositionDuration: (
        IHyperdriveFactoryUpdateMinPositionDurationContractFunction
    )

    updateMinTimeStretchAPR: (
        IHyperdriveFactoryUpdateMinTimeStretchAPRContractFunction
    )

    updateSweepCollector: IHyperdriveFactoryUpdateSweepCollectorContractFunction

    version: IHyperdriveFactoryVersionContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.addDeployerCoordinator = (
            IHyperdriveFactoryAddDeployerCoordinatorContractFunction.factory(
                "addDeployerCoordinator",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="addDeployerCoordinator",
            )
        )
        self.checkpointDurationResolution = IHyperdriveFactoryCheckpointDurationResolutionContractFunction.factory(
            "checkpointDurationResolution",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="checkpointDurationResolution",
        )
        self.checkpointRewarder = (
            IHyperdriveFactoryCheckpointRewarderContractFunction.factory(
                "checkpointRewarder",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="checkpointRewarder",
            )
        )
        self.defaultPausers = (
            IHyperdriveFactoryDefaultPausersContractFunction.factory(
                "defaultPausers",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="defaultPausers",
            )
        )
        self.deployAndInitialize = (
            IHyperdriveFactoryDeployAndInitializeContractFunction.factory(
                "deployAndInitialize",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="deployAndInitialize",
            )
        )
        self.deployTarget = (
            IHyperdriveFactoryDeployTargetContractFunction.factory(
                "deployTarget",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="deployTarget",
            )
        )
        self.deployerCoordinatorManager = IHyperdriveFactoryDeployerCoordinatorManagerContractFunction.factory(
            "deployerCoordinatorManager",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="deployerCoordinatorManager",
        )
        self.feeCollector = (
            IHyperdriveFactoryFeeCollectorContractFunction.factory(
                "feeCollector",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="feeCollector",
            )
        )
        self.getDeployerCoordinatorAtIndex = IHyperdriveFactoryGetDeployerCoordinatorAtIndexContractFunction.factory(
            "getDeployerCoordinatorAtIndex",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getDeployerCoordinatorAtIndex",
        )
        self.getDeployerCoordinatorByInstances = IHyperdriveFactoryGetDeployerCoordinatorByInstancesContractFunction.factory(
            "getDeployerCoordinatorByInstances",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getDeployerCoordinatorByInstances",
        )
        self.getDeployerCoordinatorsInRange = IHyperdriveFactoryGetDeployerCoordinatorsInRangeContractFunction.factory(
            "getDeployerCoordinatorsInRange",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getDeployerCoordinatorsInRange",
        )
        self.getInstanceAtIndex = (
            IHyperdriveFactoryGetInstanceAtIndexContractFunction.factory(
                "getInstanceAtIndex",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getInstanceAtIndex",
            )
        )
        self.getInstancesInRange = (
            IHyperdriveFactoryGetInstancesInRangeContractFunction.factory(
                "getInstancesInRange",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getInstancesInRange",
            )
        )
        self.getNumberOfDeployerCoordinators = IHyperdriveFactoryGetNumberOfDeployerCoordinatorsContractFunction.factory(
            "getNumberOfDeployerCoordinators",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getNumberOfDeployerCoordinators",
        )
        self.getNumberOfInstances = (
            IHyperdriveFactoryGetNumberOfInstancesContractFunction.factory(
                "getNumberOfInstances",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getNumberOfInstances",
            )
        )
        self.governance = IHyperdriveFactoryGovernanceContractFunction.factory(
            "governance",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="governance",
        )
        self.hyperdriveGovernance = (
            IHyperdriveFactoryHyperdriveGovernanceContractFunction.factory(
                "hyperdriveGovernance",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="hyperdriveGovernance",
            )
        )
        self.isDeployerCoordinator = (
            IHyperdriveFactoryIsDeployerCoordinatorContractFunction.factory(
                "isDeployerCoordinator",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="isDeployerCoordinator",
            )
        )
        self.isInstance = IHyperdriveFactoryIsInstanceContractFunction.factory(
            "isInstance",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="isInstance",
        )
        self.kind = IHyperdriveFactoryKindContractFunction.factory(
            "kind",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="kind",
        )
        self.linkerCodeHash = (
            IHyperdriveFactoryLinkerCodeHashContractFunction.factory(
                "linkerCodeHash",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="linkerCodeHash",
            )
        )
        self.linkerFactory = (
            IHyperdriveFactoryLinkerFactoryContractFunction.factory(
                "linkerFactory",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="linkerFactory",
            )
        )
        self.maxCheckpointDuration = (
            IHyperdriveFactoryMaxCheckpointDurationContractFunction.factory(
                "maxCheckpointDuration",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="maxCheckpointDuration",
            )
        )
        self.maxCircuitBreakerDelta = (
            IHyperdriveFactoryMaxCircuitBreakerDeltaContractFunction.factory(
                "maxCircuitBreakerDelta",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="maxCircuitBreakerDelta",
            )
        )
        self.maxFees = IHyperdriveFactoryMaxFeesContractFunction.factory(
            "maxFees",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="maxFees",
        )
        self.maxFixedAPR = (
            IHyperdriveFactoryMaxFixedAPRContractFunction.factory(
                "maxFixedAPR",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="maxFixedAPR",
            )
        )
        self.maxPositionDuration = (
            IHyperdriveFactoryMaxPositionDurationContractFunction.factory(
                "maxPositionDuration",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="maxPositionDuration",
            )
        )
        self.maxTimeStretchAPR = (
            IHyperdriveFactoryMaxTimeStretchAPRContractFunction.factory(
                "maxTimeStretchAPR",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="maxTimeStretchAPR",
            )
        )
        self.minCheckpointDuration = (
            IHyperdriveFactoryMinCheckpointDurationContractFunction.factory(
                "minCheckpointDuration",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="minCheckpointDuration",
            )
        )
        self.minCircuitBreakerDelta = (
            IHyperdriveFactoryMinCircuitBreakerDeltaContractFunction.factory(
                "minCircuitBreakerDelta",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="minCircuitBreakerDelta",
            )
        )
        self.minFees = IHyperdriveFactoryMinFeesContractFunction.factory(
            "minFees",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="minFees",
        )
        self.minFixedAPR = (
            IHyperdriveFactoryMinFixedAPRContractFunction.factory(
                "minFixedAPR",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="minFixedAPR",
            )
        )
        self.minPositionDuration = (
            IHyperdriveFactoryMinPositionDurationContractFunction.factory(
                "minPositionDuration",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="minPositionDuration",
            )
        )
        self.minTimeStretchAPR = (
            IHyperdriveFactoryMinTimeStretchAPRContractFunction.factory(
                "minTimeStretchAPR",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="minTimeStretchAPR",
            )
        )
        self.name = IHyperdriveFactoryNameContractFunction.factory(
            "name",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="name",
        )
        self.removeDeployerCoordinator = (
            IHyperdriveFactoryRemoveDeployerCoordinatorContractFunction.factory(
                "removeDeployerCoordinator",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="removeDeployerCoordinator",
            )
        )
        self.sweepCollector = (
            IHyperdriveFactorySweepCollectorContractFunction.factory(
                "sweepCollector",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="sweepCollector",
            )
        )
        self.updateCheckpointDurationResolution = IHyperdriveFactoryUpdateCheckpointDurationResolutionContractFunction.factory(
            "updateCheckpointDurationResolution",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="updateCheckpointDurationResolution",
        )
        self.updateCheckpointRewarder = (
            IHyperdriveFactoryUpdateCheckpointRewarderContractFunction.factory(
                "updateCheckpointRewarder",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateCheckpointRewarder",
            )
        )
        self.updateDefaultPausers = (
            IHyperdriveFactoryUpdateDefaultPausersContractFunction.factory(
                "updateDefaultPausers",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateDefaultPausers",
            )
        )
        self.updateDeployerCoordinatorManager = IHyperdriveFactoryUpdateDeployerCoordinatorManagerContractFunction.factory(
            "updateDeployerCoordinatorManager",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="updateDeployerCoordinatorManager",
        )
        self.updateFeeCollector = (
            IHyperdriveFactoryUpdateFeeCollectorContractFunction.factory(
                "updateFeeCollector",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateFeeCollector",
            )
        )
        self.updateGovernance = (
            IHyperdriveFactoryUpdateGovernanceContractFunction.factory(
                "updateGovernance",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateGovernance",
            )
        )
        self.updateHyperdriveGovernance = IHyperdriveFactoryUpdateHyperdriveGovernanceContractFunction.factory(
            "updateHyperdriveGovernance",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="updateHyperdriveGovernance",
        )
        self.updateLinkerCodeHash = (
            IHyperdriveFactoryUpdateLinkerCodeHashContractFunction.factory(
                "updateLinkerCodeHash",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateLinkerCodeHash",
            )
        )
        self.updateLinkerFactory = (
            IHyperdriveFactoryUpdateLinkerFactoryContractFunction.factory(
                "updateLinkerFactory",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateLinkerFactory",
            )
        )
        self.updateMaxCheckpointDuration = IHyperdriveFactoryUpdateMaxCheckpointDurationContractFunction.factory(
            "updateMaxCheckpointDuration",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="updateMaxCheckpointDuration",
        )
        self.updateMaxCircuitBreakerDelta = IHyperdriveFactoryUpdateMaxCircuitBreakerDeltaContractFunction.factory(
            "updateMaxCircuitBreakerDelta",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="updateMaxCircuitBreakerDelta",
        )
        self.updateMaxFees = (
            IHyperdriveFactoryUpdateMaxFeesContractFunction.factory(
                "updateMaxFees",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateMaxFees",
            )
        )
        self.updateMaxFixedAPR = (
            IHyperdriveFactoryUpdateMaxFixedAPRContractFunction.factory(
                "updateMaxFixedAPR",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateMaxFixedAPR",
            )
        )
        self.updateMaxPositionDuration = (
            IHyperdriveFactoryUpdateMaxPositionDurationContractFunction.factory(
                "updateMaxPositionDuration",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateMaxPositionDuration",
            )
        )
        self.updateMaxTimeStretchAPR = (
            IHyperdriveFactoryUpdateMaxTimeStretchAPRContractFunction.factory(
                "updateMaxTimeStretchAPR",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateMaxTimeStretchAPR",
            )
        )
        self.updateMinCheckpointDuration = IHyperdriveFactoryUpdateMinCheckpointDurationContractFunction.factory(
            "updateMinCheckpointDuration",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="updateMinCheckpointDuration",
        )
        self.updateMinCircuitBreakerDelta = IHyperdriveFactoryUpdateMinCircuitBreakerDeltaContractFunction.factory(
            "updateMinCircuitBreakerDelta",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="updateMinCircuitBreakerDelta",
        )
        self.updateMinFees = (
            IHyperdriveFactoryUpdateMinFeesContractFunction.factory(
                "updateMinFees",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateMinFees",
            )
        )
        self.updateMinFixedAPR = (
            IHyperdriveFactoryUpdateMinFixedAPRContractFunction.factory(
                "updateMinFixedAPR",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateMinFixedAPR",
            )
        )
        self.updateMinPositionDuration = (
            IHyperdriveFactoryUpdateMinPositionDurationContractFunction.factory(
                "updateMinPositionDuration",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateMinPositionDuration",
            )
        )
        self.updateMinTimeStretchAPR = (
            IHyperdriveFactoryUpdateMinTimeStretchAPRContractFunction.factory(
                "updateMinTimeStretchAPR",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateMinTimeStretchAPR",
            )
        )
        self.updateSweepCollector = (
            IHyperdriveFactoryUpdateSweepCollectorContractFunction.factory(
                "updateSweepCollector",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateSweepCollector",
            )
        )
        self.version = IHyperdriveFactoryVersionContractFunction.factory(
            "version",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="version",
        )


class IHyperdriveFactoryCheckpointDurationResolutionUpdatedContractEvent(
    ContractEvent
):
    """ContractEvent for CheckpointDurationResolutionUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[CheckpointDurationResolutionUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            CheckpointDurationResolutionUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=CheckpointDurationResolutionUpdatedEvent.CheckpointDurationResolutionUpdatedEventArgs(
                    newCheckpointDurationResolution=abi_event.args[
                        "newCheckpointDurationResolution"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[CheckpointDurationResolutionUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            CheckpointDurationResolutionUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=CheckpointDurationResolutionUpdatedEvent.CheckpointDurationResolutionUpdatedEventArgs(
                    newCheckpointDurationResolution=abi_event.args[
                        "newCheckpointDurationResolution"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryCheckpointRewarderUpdatedContractEvent(ContractEvent):
    """ContractEvent for CheckpointRewarderUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[CheckpointRewarderUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            CheckpointRewarderUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=CheckpointRewarderUpdatedEvent.CheckpointRewarderUpdatedEventArgs(
                    newCheckpointRewarder=abi_event.args[
                        "newCheckpointRewarder"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[CheckpointRewarderUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            CheckpointRewarderUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=CheckpointRewarderUpdatedEvent.CheckpointRewarderUpdatedEventArgs(
                    newCheckpointRewarder=abi_event.args[
                        "newCheckpointRewarder"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryDefaultPausersUpdatedContractEvent(ContractEvent):
    """ContractEvent for DefaultPausersUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[DefaultPausersUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            DefaultPausersUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=DefaultPausersUpdatedEvent.DefaultPausersUpdatedEventArgs(
                    newDefaultPausers=abi_event.args["newDefaultPausers"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[DefaultPausersUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            DefaultPausersUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=DefaultPausersUpdatedEvent.DefaultPausersUpdatedEventArgs(
                    newDefaultPausers=abi_event.args["newDefaultPausers"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryDeployedContractEvent(ContractEvent):
    """ContractEvent for Deployed."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[DeployedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            DeployedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=DeployedEvent.DeployedEventArgs(
                    deployerCoordinator=abi_event.args["deployerCoordinator"],
                    hyperdrive=abi_event.args["hyperdrive"],
                    name=abi_event.args["name"],
                    config=abi_event.args["config"],
                    extraData=abi_event.args["extraData"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[DeployedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            DeployedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=DeployedEvent.DeployedEventArgs(
                    deployerCoordinator=abi_event.args["deployerCoordinator"],
                    hyperdrive=abi_event.args["hyperdrive"],
                    name=abi_event.args["name"],
                    config=abi_event.args["config"],
                    extraData=abi_event.args["extraData"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryDeployerCoordinatorAddedContractEvent(ContractEvent):
    """ContractEvent for DeployerCoordinatorAdded."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[DeployerCoordinatorAddedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            DeployerCoordinatorAddedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=DeployerCoordinatorAddedEvent.DeployerCoordinatorAddedEventArgs(
                    deployerCoordinator=abi_event.args["deployerCoordinator"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[DeployerCoordinatorAddedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            DeployerCoordinatorAddedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=DeployerCoordinatorAddedEvent.DeployerCoordinatorAddedEventArgs(
                    deployerCoordinator=abi_event.args["deployerCoordinator"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryDeployerCoordinatorManagerUpdatedContractEvent(
    ContractEvent
):
    """ContractEvent for DeployerCoordinatorManagerUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[DeployerCoordinatorManagerUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            DeployerCoordinatorManagerUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=DeployerCoordinatorManagerUpdatedEvent.DeployerCoordinatorManagerUpdatedEventArgs(
                    deployerCoordinatorManager=abi_event.args[
                        "deployerCoordinatorManager"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[DeployerCoordinatorManagerUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            DeployerCoordinatorManagerUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=DeployerCoordinatorManagerUpdatedEvent.DeployerCoordinatorManagerUpdatedEventArgs(
                    deployerCoordinatorManager=abi_event.args[
                        "deployerCoordinatorManager"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryDeployerCoordinatorRemovedContractEvent(ContractEvent):
    """ContractEvent for DeployerCoordinatorRemoved."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[DeployerCoordinatorRemovedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            DeployerCoordinatorRemovedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=DeployerCoordinatorRemovedEvent.DeployerCoordinatorRemovedEventArgs(
                    deployerCoordinator=abi_event.args["deployerCoordinator"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[DeployerCoordinatorRemovedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            DeployerCoordinatorRemovedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=DeployerCoordinatorRemovedEvent.DeployerCoordinatorRemovedEventArgs(
                    deployerCoordinator=abi_event.args["deployerCoordinator"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryFeeCollectorUpdatedContractEvent(ContractEvent):
    """ContractEvent for FeeCollectorUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[FeeCollectorUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            FeeCollectorUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=FeeCollectorUpdatedEvent.FeeCollectorUpdatedEventArgs(
                    newFeeCollector=abi_event.args["newFeeCollector"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[FeeCollectorUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            FeeCollectorUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=FeeCollectorUpdatedEvent.FeeCollectorUpdatedEventArgs(
                    newFeeCollector=abi_event.args["newFeeCollector"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryGovernanceUpdatedContractEvent(ContractEvent):
    """ContractEvent for GovernanceUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[GovernanceUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            GovernanceUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=GovernanceUpdatedEvent.GovernanceUpdatedEventArgs(
                    governance=abi_event.args["governance"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[GovernanceUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            GovernanceUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=GovernanceUpdatedEvent.GovernanceUpdatedEventArgs(
                    governance=abi_event.args["governance"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryHyperdriveGovernanceUpdatedContractEvent(ContractEvent):
    """ContractEvent for HyperdriveGovernanceUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[HyperdriveGovernanceUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            HyperdriveGovernanceUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=HyperdriveGovernanceUpdatedEvent.HyperdriveGovernanceUpdatedEventArgs(
                    hyperdriveGovernance=abi_event.args["hyperdriveGovernance"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[HyperdriveGovernanceUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            HyperdriveGovernanceUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=HyperdriveGovernanceUpdatedEvent.HyperdriveGovernanceUpdatedEventArgs(
                    hyperdriveGovernance=abi_event.args["hyperdriveGovernance"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryLinkerCodeHashUpdatedContractEvent(ContractEvent):
    """ContractEvent for LinkerCodeHashUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LinkerCodeHashUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LinkerCodeHashUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LinkerCodeHashUpdatedEvent.LinkerCodeHashUpdatedEventArgs(
                    newLinkerCodeHash=abi_event.args["newLinkerCodeHash"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LinkerCodeHashUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LinkerCodeHashUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LinkerCodeHashUpdatedEvent.LinkerCodeHashUpdatedEventArgs(
                    newLinkerCodeHash=abi_event.args["newLinkerCodeHash"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryLinkerFactoryUpdatedContractEvent(ContractEvent):
    """ContractEvent for LinkerFactoryUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LinkerFactoryUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LinkerFactoryUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LinkerFactoryUpdatedEvent.LinkerFactoryUpdatedEventArgs(
                    newLinkerFactory=abi_event.args["newLinkerFactory"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LinkerFactoryUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LinkerFactoryUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LinkerFactoryUpdatedEvent.LinkerFactoryUpdatedEventArgs(
                    newLinkerFactory=abi_event.args["newLinkerFactory"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryMaxCheckpointDurationUpdatedContractEvent(
    ContractEvent
):
    """ContractEvent for MaxCheckpointDurationUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MaxCheckpointDurationUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MaxCheckpointDurationUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MaxCheckpointDurationUpdatedEvent.MaxCheckpointDurationUpdatedEventArgs(
                    newMaxCheckpointDuration=abi_event.args[
                        "newMaxCheckpointDuration"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MaxCheckpointDurationUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MaxCheckpointDurationUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MaxCheckpointDurationUpdatedEvent.MaxCheckpointDurationUpdatedEventArgs(
                    newMaxCheckpointDuration=abi_event.args[
                        "newMaxCheckpointDuration"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryMaxCircuitBreakerDeltaUpdatedContractEvent(
    ContractEvent
):
    """ContractEvent for MaxCircuitBreakerDeltaUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MaxCircuitBreakerDeltaUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MaxCircuitBreakerDeltaUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MaxCircuitBreakerDeltaUpdatedEvent.MaxCircuitBreakerDeltaUpdatedEventArgs(
                    newMaxCircuitBreakerDelta=abi_event.args[
                        "newMaxCircuitBreakerDelta"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MaxCircuitBreakerDeltaUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MaxCircuitBreakerDeltaUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MaxCircuitBreakerDeltaUpdatedEvent.MaxCircuitBreakerDeltaUpdatedEventArgs(
                    newMaxCircuitBreakerDelta=abi_event.args[
                        "newMaxCircuitBreakerDelta"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryMaxFeesUpdatedContractEvent(ContractEvent):
    """ContractEvent for MaxFeesUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MaxFeesUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MaxFeesUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MaxFeesUpdatedEvent.MaxFeesUpdatedEventArgs(
                    newMaxFees=abi_event.args["newMaxFees"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MaxFeesUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MaxFeesUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MaxFeesUpdatedEvent.MaxFeesUpdatedEventArgs(
                    newMaxFees=abi_event.args["newMaxFees"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryMaxFixedAPRUpdatedContractEvent(ContractEvent):
    """ContractEvent for MaxFixedAPRUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MaxFixedAPRUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MaxFixedAPRUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MaxFixedAPRUpdatedEvent.MaxFixedAPRUpdatedEventArgs(
                    newMaxFixedAPR=abi_event.args["newMaxFixedAPR"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MaxFixedAPRUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MaxFixedAPRUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MaxFixedAPRUpdatedEvent.MaxFixedAPRUpdatedEventArgs(
                    newMaxFixedAPR=abi_event.args["newMaxFixedAPR"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryMaxPositionDurationUpdatedContractEvent(ContractEvent):
    """ContractEvent for MaxPositionDurationUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MaxPositionDurationUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MaxPositionDurationUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MaxPositionDurationUpdatedEvent.MaxPositionDurationUpdatedEventArgs(
                    newMaxPositionDuration=abi_event.args[
                        "newMaxPositionDuration"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MaxPositionDurationUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MaxPositionDurationUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MaxPositionDurationUpdatedEvent.MaxPositionDurationUpdatedEventArgs(
                    newMaxPositionDuration=abi_event.args[
                        "newMaxPositionDuration"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryMaxTimeStretchAPRUpdatedContractEvent(ContractEvent):
    """ContractEvent for MaxTimeStretchAPRUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MaxTimeStretchAPRUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MaxTimeStretchAPRUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MaxTimeStretchAPRUpdatedEvent.MaxTimeStretchAPRUpdatedEventArgs(
                    newMaxTimeStretchAPR=abi_event.args["newMaxTimeStretchAPR"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MaxTimeStretchAPRUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MaxTimeStretchAPRUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MaxTimeStretchAPRUpdatedEvent.MaxTimeStretchAPRUpdatedEventArgs(
                    newMaxTimeStretchAPR=abi_event.args["newMaxTimeStretchAPR"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryMinCheckpointDurationUpdatedContractEvent(
    ContractEvent
):
    """ContractEvent for MinCheckpointDurationUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MinCheckpointDurationUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MinCheckpointDurationUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MinCheckpointDurationUpdatedEvent.MinCheckpointDurationUpdatedEventArgs(
                    newMinCheckpointDuration=abi_event.args[
                        "newMinCheckpointDuration"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MinCheckpointDurationUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MinCheckpointDurationUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MinCheckpointDurationUpdatedEvent.MinCheckpointDurationUpdatedEventArgs(
                    newMinCheckpointDuration=abi_event.args[
                        "newMinCheckpointDuration"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryMinCircuitBreakerDeltaUpdatedContractEvent(
    ContractEvent
):
    """ContractEvent for MinCircuitBreakerDeltaUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MinCircuitBreakerDeltaUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MinCircuitBreakerDeltaUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MinCircuitBreakerDeltaUpdatedEvent.MinCircuitBreakerDeltaUpdatedEventArgs(
                    newMinCircuitBreakerDelta=abi_event.args[
                        "newMinCircuitBreakerDelta"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MinCircuitBreakerDeltaUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MinCircuitBreakerDeltaUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MinCircuitBreakerDeltaUpdatedEvent.MinCircuitBreakerDeltaUpdatedEventArgs(
                    newMinCircuitBreakerDelta=abi_event.args[
                        "newMinCircuitBreakerDelta"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryMinFeesUpdatedContractEvent(ContractEvent):
    """ContractEvent for MinFeesUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MinFeesUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MinFeesUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MinFeesUpdatedEvent.MinFeesUpdatedEventArgs(
                    newMinFees=abi_event.args["newMinFees"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MinFeesUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MinFeesUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MinFeesUpdatedEvent.MinFeesUpdatedEventArgs(
                    newMinFees=abi_event.args["newMinFees"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryMinFixedAPRUpdatedContractEvent(ContractEvent):
    """ContractEvent for MinFixedAPRUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MinFixedAPRUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MinFixedAPRUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MinFixedAPRUpdatedEvent.MinFixedAPRUpdatedEventArgs(
                    newMinFixedAPR=abi_event.args["newMinFixedAPR"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MinFixedAPRUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MinFixedAPRUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MinFixedAPRUpdatedEvent.MinFixedAPRUpdatedEventArgs(
                    newMinFixedAPR=abi_event.args["newMinFixedAPR"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryMinPositionDurationUpdatedContractEvent(ContractEvent):
    """ContractEvent for MinPositionDurationUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MinPositionDurationUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MinPositionDurationUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MinPositionDurationUpdatedEvent.MinPositionDurationUpdatedEventArgs(
                    newMinPositionDuration=abi_event.args[
                        "newMinPositionDuration"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MinPositionDurationUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MinPositionDurationUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MinPositionDurationUpdatedEvent.MinPositionDurationUpdatedEventArgs(
                    newMinPositionDuration=abi_event.args[
                        "newMinPositionDuration"
                    ],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryMinTimeStretchAPRUpdatedContractEvent(ContractEvent):
    """ContractEvent for MinTimeStretchAPRUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MinTimeStretchAPRUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MinTimeStretchAPRUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MinTimeStretchAPRUpdatedEvent.MinTimeStretchAPRUpdatedEventArgs(
                    newMinTimeStretchAPR=abi_event.args["newMinTimeStretchAPR"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MinTimeStretchAPRUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MinTimeStretchAPRUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MinTimeStretchAPRUpdatedEvent.MinTimeStretchAPRUpdatedEventArgs(
                    newMinTimeStretchAPR=abi_event.args["newMinTimeStretchAPR"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactorySweepCollectorUpdatedContractEvent(ContractEvent):
    """ContractEvent for SweepCollectorUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[SweepCollectorUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SweepCollectorUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SweepCollectorUpdatedEvent.SweepCollectorUpdatedEventArgs(
                    newSweepCollector=abi_event.args["newSweepCollector"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[SweepCollectorUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SweepCollectorUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SweepCollectorUpdatedEvent.SweepCollectorUpdatedEventArgs(
                    newSweepCollector=abi_event.args["newSweepCollector"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IHyperdriveFactoryContractEvents(ContractEvents):
    """ContractEvents for the IHyperdriveFactory contract."""

    CheckpointDurationResolutionUpdated: Type[
        IHyperdriveFactoryCheckpointDurationResolutionUpdatedContractEvent
    ]

    CheckpointRewarderUpdated: Type[
        IHyperdriveFactoryCheckpointRewarderUpdatedContractEvent
    ]

    DefaultPausersUpdated: Type[
        IHyperdriveFactoryDefaultPausersUpdatedContractEvent
    ]

    Deployed: Type[IHyperdriveFactoryDeployedContractEvent]

    DeployerCoordinatorAdded: Type[
        IHyperdriveFactoryDeployerCoordinatorAddedContractEvent
    ]

    DeployerCoordinatorManagerUpdated: Type[
        IHyperdriveFactoryDeployerCoordinatorManagerUpdatedContractEvent
    ]

    DeployerCoordinatorRemoved: Type[
        IHyperdriveFactoryDeployerCoordinatorRemovedContractEvent
    ]

    FeeCollectorUpdated: Type[
        IHyperdriveFactoryFeeCollectorUpdatedContractEvent
    ]

    GovernanceUpdated: Type[IHyperdriveFactoryGovernanceUpdatedContractEvent]

    HyperdriveGovernanceUpdated: Type[
        IHyperdriveFactoryHyperdriveGovernanceUpdatedContractEvent
    ]

    LinkerCodeHashUpdated: Type[
        IHyperdriveFactoryLinkerCodeHashUpdatedContractEvent
    ]

    LinkerFactoryUpdated: Type[
        IHyperdriveFactoryLinkerFactoryUpdatedContractEvent
    ]

    MaxCheckpointDurationUpdated: Type[
        IHyperdriveFactoryMaxCheckpointDurationUpdatedContractEvent
    ]

    MaxCircuitBreakerDeltaUpdated: Type[
        IHyperdriveFactoryMaxCircuitBreakerDeltaUpdatedContractEvent
    ]

    MaxFeesUpdated: Type[IHyperdriveFactoryMaxFeesUpdatedContractEvent]

    MaxFixedAPRUpdated: Type[IHyperdriveFactoryMaxFixedAPRUpdatedContractEvent]

    MaxPositionDurationUpdated: Type[
        IHyperdriveFactoryMaxPositionDurationUpdatedContractEvent
    ]

    MaxTimeStretchAPRUpdated: Type[
        IHyperdriveFactoryMaxTimeStretchAPRUpdatedContractEvent
    ]

    MinCheckpointDurationUpdated: Type[
        IHyperdriveFactoryMinCheckpointDurationUpdatedContractEvent
    ]

    MinCircuitBreakerDeltaUpdated: Type[
        IHyperdriveFactoryMinCircuitBreakerDeltaUpdatedContractEvent
    ]

    MinFeesUpdated: Type[IHyperdriveFactoryMinFeesUpdatedContractEvent]

    MinFixedAPRUpdated: Type[IHyperdriveFactoryMinFixedAPRUpdatedContractEvent]

    MinPositionDurationUpdated: Type[
        IHyperdriveFactoryMinPositionDurationUpdatedContractEvent
    ]

    MinTimeStretchAPRUpdated: Type[
        IHyperdriveFactoryMinTimeStretchAPRUpdatedContractEvent
    ]

    SweepCollectorUpdated: Type[
        IHyperdriveFactorySweepCollectorUpdatedContractEvent
    ]

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.CheckpointDurationResolutionUpdated = cast(
            Type[
                IHyperdriveFactoryCheckpointDurationResolutionUpdatedContractEvent
            ],
            IHyperdriveFactoryCheckpointDurationResolutionUpdatedContractEvent.factory(
                "CheckpointDurationResolutionUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="CheckpointDurationResolutionUpdated",
            ),
        )
        self.CheckpointRewarderUpdated = cast(
            Type[IHyperdriveFactoryCheckpointRewarderUpdatedContractEvent],
            IHyperdriveFactoryCheckpointRewarderUpdatedContractEvent.factory(
                "CheckpointRewarderUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="CheckpointRewarderUpdated",
            ),
        )
        self.DefaultPausersUpdated = cast(
            Type[IHyperdriveFactoryDefaultPausersUpdatedContractEvent],
            IHyperdriveFactoryDefaultPausersUpdatedContractEvent.factory(
                "DefaultPausersUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="DefaultPausersUpdated",
            ),
        )
        self.Deployed = cast(
            Type[IHyperdriveFactoryDeployedContractEvent],
            IHyperdriveFactoryDeployedContractEvent.factory(
                "Deployed",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Deployed",
            ),
        )
        self.DeployerCoordinatorAdded = cast(
            Type[IHyperdriveFactoryDeployerCoordinatorAddedContractEvent],
            IHyperdriveFactoryDeployerCoordinatorAddedContractEvent.factory(
                "DeployerCoordinatorAdded",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="DeployerCoordinatorAdded",
            ),
        )
        self.DeployerCoordinatorManagerUpdated = cast(
            Type[
                IHyperdriveFactoryDeployerCoordinatorManagerUpdatedContractEvent
            ],
            IHyperdriveFactoryDeployerCoordinatorManagerUpdatedContractEvent.factory(
                "DeployerCoordinatorManagerUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="DeployerCoordinatorManagerUpdated",
            ),
        )
        self.DeployerCoordinatorRemoved = cast(
            Type[IHyperdriveFactoryDeployerCoordinatorRemovedContractEvent],
            IHyperdriveFactoryDeployerCoordinatorRemovedContractEvent.factory(
                "DeployerCoordinatorRemoved",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="DeployerCoordinatorRemoved",
            ),
        )
        self.FeeCollectorUpdated = cast(
            Type[IHyperdriveFactoryFeeCollectorUpdatedContractEvent],
            IHyperdriveFactoryFeeCollectorUpdatedContractEvent.factory(
                "FeeCollectorUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="FeeCollectorUpdated",
            ),
        )
        self.GovernanceUpdated = cast(
            Type[IHyperdriveFactoryGovernanceUpdatedContractEvent],
            IHyperdriveFactoryGovernanceUpdatedContractEvent.factory(
                "GovernanceUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="GovernanceUpdated",
            ),
        )
        self.HyperdriveGovernanceUpdated = cast(
            Type[IHyperdriveFactoryHyperdriveGovernanceUpdatedContractEvent],
            IHyperdriveFactoryHyperdriveGovernanceUpdatedContractEvent.factory(
                "HyperdriveGovernanceUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="HyperdriveGovernanceUpdated",
            ),
        )
        self.LinkerCodeHashUpdated = cast(
            Type[IHyperdriveFactoryLinkerCodeHashUpdatedContractEvent],
            IHyperdriveFactoryLinkerCodeHashUpdatedContractEvent.factory(
                "LinkerCodeHashUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="LinkerCodeHashUpdated",
            ),
        )
        self.LinkerFactoryUpdated = cast(
            Type[IHyperdriveFactoryLinkerFactoryUpdatedContractEvent],
            IHyperdriveFactoryLinkerFactoryUpdatedContractEvent.factory(
                "LinkerFactoryUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="LinkerFactoryUpdated",
            ),
        )
        self.MaxCheckpointDurationUpdated = cast(
            Type[IHyperdriveFactoryMaxCheckpointDurationUpdatedContractEvent],
            IHyperdriveFactoryMaxCheckpointDurationUpdatedContractEvent.factory(
                "MaxCheckpointDurationUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MaxCheckpointDurationUpdated",
            ),
        )
        self.MaxCircuitBreakerDeltaUpdated = cast(
            Type[IHyperdriveFactoryMaxCircuitBreakerDeltaUpdatedContractEvent],
            IHyperdriveFactoryMaxCircuitBreakerDeltaUpdatedContractEvent.factory(
                "MaxCircuitBreakerDeltaUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MaxCircuitBreakerDeltaUpdated",
            ),
        )
        self.MaxFeesUpdated = cast(
            Type[IHyperdriveFactoryMaxFeesUpdatedContractEvent],
            IHyperdriveFactoryMaxFeesUpdatedContractEvent.factory(
                "MaxFeesUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MaxFeesUpdated",
            ),
        )
        self.MaxFixedAPRUpdated = cast(
            Type[IHyperdriveFactoryMaxFixedAPRUpdatedContractEvent],
            IHyperdriveFactoryMaxFixedAPRUpdatedContractEvent.factory(
                "MaxFixedAPRUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MaxFixedAPRUpdated",
            ),
        )
        self.MaxPositionDurationUpdated = cast(
            Type[IHyperdriveFactoryMaxPositionDurationUpdatedContractEvent],
            IHyperdriveFactoryMaxPositionDurationUpdatedContractEvent.factory(
                "MaxPositionDurationUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MaxPositionDurationUpdated",
            ),
        )
        self.MaxTimeStretchAPRUpdated = cast(
            Type[IHyperdriveFactoryMaxTimeStretchAPRUpdatedContractEvent],
            IHyperdriveFactoryMaxTimeStretchAPRUpdatedContractEvent.factory(
                "MaxTimeStretchAPRUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MaxTimeStretchAPRUpdated",
            ),
        )
        self.MinCheckpointDurationUpdated = cast(
            Type[IHyperdriveFactoryMinCheckpointDurationUpdatedContractEvent],
            IHyperdriveFactoryMinCheckpointDurationUpdatedContractEvent.factory(
                "MinCheckpointDurationUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MinCheckpointDurationUpdated",
            ),
        )
        self.MinCircuitBreakerDeltaUpdated = cast(
            Type[IHyperdriveFactoryMinCircuitBreakerDeltaUpdatedContractEvent],
            IHyperdriveFactoryMinCircuitBreakerDeltaUpdatedContractEvent.factory(
                "MinCircuitBreakerDeltaUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MinCircuitBreakerDeltaUpdated",
            ),
        )
        self.MinFeesUpdated = cast(
            Type[IHyperdriveFactoryMinFeesUpdatedContractEvent],
            IHyperdriveFactoryMinFeesUpdatedContractEvent.factory(
                "MinFeesUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MinFeesUpdated",
            ),
        )
        self.MinFixedAPRUpdated = cast(
            Type[IHyperdriveFactoryMinFixedAPRUpdatedContractEvent],
            IHyperdriveFactoryMinFixedAPRUpdatedContractEvent.factory(
                "MinFixedAPRUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MinFixedAPRUpdated",
            ),
        )
        self.MinPositionDurationUpdated = cast(
            Type[IHyperdriveFactoryMinPositionDurationUpdatedContractEvent],
            IHyperdriveFactoryMinPositionDurationUpdatedContractEvent.factory(
                "MinPositionDurationUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MinPositionDurationUpdated",
            ),
        )
        self.MinTimeStretchAPRUpdated = cast(
            Type[IHyperdriveFactoryMinTimeStretchAPRUpdatedContractEvent],
            IHyperdriveFactoryMinTimeStretchAPRUpdatedContractEvent.factory(
                "MinTimeStretchAPRUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MinTimeStretchAPRUpdated",
            ),
        )
        self.SweepCollectorUpdated = cast(
            Type[IHyperdriveFactorySweepCollectorUpdatedContractEvent],
            IHyperdriveFactorySweepCollectorUpdatedContractEvent.factory(
                "SweepCollectorUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="SweepCollectorUpdated",
            ),
        )


class IHyperdriveFactoryDeployerCoordinatorAlreadyAddedContractError:
    """ContractError for DeployerCoordinatorAlreadyAdded."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryDeployerCoordinatorAlreadyAddedContractError",
    ) -> None:
        self.selector = "0xbd34634f"
        self.signature = "DeployerCoordinatorAlreadyAdded()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "DeployerCoordinatorAlreadyAdded"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryDeployerCoordinatorIndexMismatchContractError:
    """ContractError for DeployerCoordinatorIndexMismatch."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryDeployerCoordinatorIndexMismatchContractError",
    ) -> None:
        self.selector = "0x3c9c032c"
        self.signature = "DeployerCoordinatorIndexMismatch()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "DeployerCoordinatorIndexMismatch"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryDeployerCoordinatorNotAddedContractError:
    """ContractError for DeployerCoordinatorNotAdded."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryDeployerCoordinatorNotAddedContractError",
    ) -> None:
        self.selector = "0x4bf121ab"
        self.signature = "DeployerCoordinatorNotAdded()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "DeployerCoordinatorNotAdded"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryEndIndexTooLargeContractError:
    """ContractError for EndIndexTooLarge."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryEndIndexTooLargeContractError",
    ) -> None:
        self.selector = "0xe0f7becb"
        self.signature = "EndIndexTooLarge()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "EndIndexTooLarge"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidCheckpointDurationContractError:
    """ContractError for InvalidCheckpointDuration."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidCheckpointDurationContractError",
    ) -> None:
        self.selector = "0x5428734d"
        self.signature = "InvalidCheckpointDuration()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidCheckpointDuration"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidCheckpointDurationResolutionContractError:
    """ContractError for InvalidCheckpointDurationResolution."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidCheckpointDurationResolutionContractError",
    ) -> None:
        self.selector = "0x8dbae0a8"
        self.signature = "InvalidCheckpointDurationResolution()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidCheckpointDurationResolution"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidCircuitBreakerDeltaContractError:
    """ContractError for InvalidCircuitBreakerDelta."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidCircuitBreakerDeltaContractError",
    ) -> None:
        self.selector = "0xef9bc65f"
        self.signature = "InvalidCircuitBreakerDelta()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidCircuitBreakerDelta"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidDeployConfigContractError:
    """ContractError for InvalidDeployConfig."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidDeployConfigContractError",
    ) -> None:
        self.selector = "0xe8c02dd7"
        self.signature = "InvalidDeployConfig()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidDeployConfig"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidDeployerCoordinatorContractError:
    """ContractError for InvalidDeployerCoordinator."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidDeployerCoordinatorContractError",
    ) -> None:
        self.selector = "0x6e623f0f"
        self.signature = "InvalidDeployerCoordinator()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidDeployerCoordinator"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidFeesContractError:
    """ContractError for InvalidFees."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidFeesContractError",
    ) -> None:
        self.selector = "0x2d8768f9"
        self.signature = "InvalidFees()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidFees"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidFixedAPRContractError:
    """ContractError for InvalidFixedAPR."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidFixedAPRContractError",
    ) -> None:
        self.selector = "0x30554de1"
        self.signature = "InvalidFixedAPR()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidFixedAPR"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidIndexesContractError:
    """ContractError for InvalidIndexes."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidIndexesContractError",
    ) -> None:
        self.selector = "0x764e6b56"
        self.signature = "InvalidIndexes()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidIndexes"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidMaxCheckpointDurationContractError:
    """ContractError for InvalidMaxCheckpointDuration."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidMaxCheckpointDurationContractError",
    ) -> None:
        self.selector = "0xf9c0959d"
        self.signature = "InvalidMaxCheckpointDuration()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidMaxCheckpointDuration"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidMaxCircuitBreakerDeltaContractError:
    """ContractError for InvalidMaxCircuitBreakerDelta."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidMaxCircuitBreakerDeltaContractError",
    ) -> None:
        self.selector = "0xfdb80c26"
        self.signature = "InvalidMaxCircuitBreakerDelta()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidMaxCircuitBreakerDelta"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidMaxFeesContractError:
    """ContractError for InvalidMaxFees."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidMaxFeesContractError",
    ) -> None:
        self.selector = "0x2c20e3f6"
        self.signature = "InvalidMaxFees()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidMaxFees"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidMaxFixedAPRContractError:
    """ContractError for InvalidMaxFixedAPR."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidMaxFixedAPRContractError",
    ) -> None:
        self.selector = "0x673edec0"
        self.signature = "InvalidMaxFixedAPR()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidMaxFixedAPR"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidMaxPositionDurationContractError:
    """ContractError for InvalidMaxPositionDuration."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidMaxPositionDurationContractError",
    ) -> None:
        self.selector = "0xcfb699cb"
        self.signature = "InvalidMaxPositionDuration()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidMaxPositionDuration"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidMaxTimeStretchAPRContractError:
    """ContractError for InvalidMaxTimeStretchAPR."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidMaxTimeStretchAPRContractError",
    ) -> None:
        self.selector = "0xa35539d0"
        self.signature = "InvalidMaxTimeStretchAPR()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidMaxTimeStretchAPR"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidMinCheckpointDurationContractError:
    """ContractError for InvalidMinCheckpointDuration."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidMinCheckpointDurationContractError",
    ) -> None:
        self.selector = "0x0433acc6"
        self.signature = "InvalidMinCheckpointDuration()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidMinCheckpointDuration"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidMinCircuitBreakerDeltaContractError:
    """ContractError for InvalidMinCircuitBreakerDelta."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidMinCircuitBreakerDeltaContractError",
    ) -> None:
        self.selector = "0x28a2d9a9"
        self.signature = "InvalidMinCircuitBreakerDelta()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidMinCircuitBreakerDelta"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidMinFeesContractError:
    """ContractError for InvalidMinFees."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidMinFeesContractError",
    ) -> None:
        self.selector = "0x15b05a8f"
        self.signature = "InvalidMinFees()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidMinFees"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidMinFixedAPRContractError:
    """ContractError for InvalidMinFixedAPR."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidMinFixedAPRContractError",
    ) -> None:
        self.selector = "0x1670f797"
        self.signature = "InvalidMinFixedAPR()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidMinFixedAPR"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidMinPositionDurationContractError:
    """ContractError for InvalidMinPositionDuration."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidMinPositionDurationContractError",
    ) -> None:
        self.selector = "0x600f5a02"
        self.signature = "InvalidMinPositionDuration()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidMinPositionDuration"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidMinTimeStretchAPRContractError:
    """ContractError for InvalidMinTimeStretchAPR."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidMinTimeStretchAPRContractError",
    ) -> None:
        self.selector = "0x5a8f6557"
        self.signature = "InvalidMinTimeStretchAPR()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidMinTimeStretchAPR"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidPositionDurationContractError:
    """ContractError for InvalidPositionDuration."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidPositionDurationContractError",
    ) -> None:
        self.selector = "0x4a7fff9e"
        self.signature = "InvalidPositionDuration()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidPositionDuration"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryInvalidTimeStretchAPRContractError:
    """ContractError for InvalidTimeStretchAPR."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryInvalidTimeStretchAPRContractError",
    ) -> None:
        self.selector = "0x83ebdfb7"
        self.signature = "InvalidTimeStretchAPR()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "InvalidTimeStretchAPR"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryReceiveLockedContractError:
    """ContractError for ReceiveLocked."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryReceiveLockedContractError",
    ) -> None:
        self.selector = "0x5563ada8"
        self.signature = "ReceiveLocked()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "ReceiveLocked"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryTransferFailedContractError:
    """ContractError for TransferFailed."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryTransferFailedContractError",
    ) -> None:
        self.selector = "0x90b8ec18"
        self.signature = "TransferFailed()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "TransferFailed"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryUnauthorizedContractError:
    """ContractError for Unauthorized."""

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "IHyperdriveFactoryUnauthorizedContractError",
    ) -> None:
        self.selector = "0x82b42900"
        self.signature = "Unauthorized()"

    @combomethod_typed
    def decode_error_data(
        self,
        data: HexBytes,
        # TODO: instead of returning a tuple, return a dataclass with the input names and types just like we do for functions
    ) -> tuple[Any, ...]:
        """Decodes error data returns from a smart contract."""
        error_abi = cast(
            ABIFunction,
            [
                item
                for item in ihyperdrivefactory_abi
                if item.get("name") == "Unauthorized"
                and item.get("type") == "error"
            ][0],
        )
        types = get_abi_input_types(error_abi)
        abi_codec = ABICodec(default_registry)
        decoded = abi_codec.decode(types, data)
        return decoded


class IHyperdriveFactoryContractErrors:
    """ContractErrors for the IHyperdriveFactory contract."""

    DeployerCoordinatorAlreadyAdded: (
        IHyperdriveFactoryDeployerCoordinatorAlreadyAddedContractError
    )

    DeployerCoordinatorIndexMismatch: (
        IHyperdriveFactoryDeployerCoordinatorIndexMismatchContractError
    )

    DeployerCoordinatorNotAdded: (
        IHyperdriveFactoryDeployerCoordinatorNotAddedContractError
    )

    EndIndexTooLarge: IHyperdriveFactoryEndIndexTooLargeContractError

    InvalidCheckpointDuration: (
        IHyperdriveFactoryInvalidCheckpointDurationContractError
    )

    InvalidCheckpointDurationResolution: (
        IHyperdriveFactoryInvalidCheckpointDurationResolutionContractError
    )

    InvalidCircuitBreakerDelta: (
        IHyperdriveFactoryInvalidCircuitBreakerDeltaContractError
    )

    InvalidDeployConfig: IHyperdriveFactoryInvalidDeployConfigContractError

    InvalidDeployerCoordinator: (
        IHyperdriveFactoryInvalidDeployerCoordinatorContractError
    )

    InvalidFees: IHyperdriveFactoryInvalidFeesContractError

    InvalidFixedAPR: IHyperdriveFactoryInvalidFixedAPRContractError

    InvalidIndexes: IHyperdriveFactoryInvalidIndexesContractError

    InvalidMaxCheckpointDuration: (
        IHyperdriveFactoryInvalidMaxCheckpointDurationContractError
    )

    InvalidMaxCircuitBreakerDelta: (
        IHyperdriveFactoryInvalidMaxCircuitBreakerDeltaContractError
    )

    InvalidMaxFees: IHyperdriveFactoryInvalidMaxFeesContractError

    InvalidMaxFixedAPR: IHyperdriveFactoryInvalidMaxFixedAPRContractError

    InvalidMaxPositionDuration: (
        IHyperdriveFactoryInvalidMaxPositionDurationContractError
    )

    InvalidMaxTimeStretchAPR: (
        IHyperdriveFactoryInvalidMaxTimeStretchAPRContractError
    )

    InvalidMinCheckpointDuration: (
        IHyperdriveFactoryInvalidMinCheckpointDurationContractError
    )

    InvalidMinCircuitBreakerDelta: (
        IHyperdriveFactoryInvalidMinCircuitBreakerDeltaContractError
    )

    InvalidMinFees: IHyperdriveFactoryInvalidMinFeesContractError

    InvalidMinFixedAPR: IHyperdriveFactoryInvalidMinFixedAPRContractError

    InvalidMinPositionDuration: (
        IHyperdriveFactoryInvalidMinPositionDurationContractError
    )

    InvalidMinTimeStretchAPR: (
        IHyperdriveFactoryInvalidMinTimeStretchAPRContractError
    )

    InvalidPositionDuration: (
        IHyperdriveFactoryInvalidPositionDurationContractError
    )

    InvalidTimeStretchAPR: IHyperdriveFactoryInvalidTimeStretchAPRContractError

    ReceiveLocked: IHyperdriveFactoryReceiveLockedContractError

    TransferFailed: IHyperdriveFactoryTransferFailedContractError

    Unauthorized: IHyperdriveFactoryUnauthorizedContractError

    def __init__(
        self,
    ) -> None:
        self.DeployerCoordinatorAlreadyAdded = (
            IHyperdriveFactoryDeployerCoordinatorAlreadyAddedContractError()
        )
        self.DeployerCoordinatorIndexMismatch = (
            IHyperdriveFactoryDeployerCoordinatorIndexMismatchContractError()
        )
        self.DeployerCoordinatorNotAdded = (
            IHyperdriveFactoryDeployerCoordinatorNotAddedContractError()
        )
        self.EndIndexTooLarge = (
            IHyperdriveFactoryEndIndexTooLargeContractError()
        )
        self.InvalidCheckpointDuration = (
            IHyperdriveFactoryInvalidCheckpointDurationContractError()
        )
        self.InvalidCheckpointDurationResolution = (
            IHyperdriveFactoryInvalidCheckpointDurationResolutionContractError()
        )
        self.InvalidCircuitBreakerDelta = (
            IHyperdriveFactoryInvalidCircuitBreakerDeltaContractError()
        )
        self.InvalidDeployConfig = (
            IHyperdriveFactoryInvalidDeployConfigContractError()
        )
        self.InvalidDeployerCoordinator = (
            IHyperdriveFactoryInvalidDeployerCoordinatorContractError()
        )
        self.InvalidFees = IHyperdriveFactoryInvalidFeesContractError()
        self.InvalidFixedAPR = IHyperdriveFactoryInvalidFixedAPRContractError()
        self.InvalidIndexes = IHyperdriveFactoryInvalidIndexesContractError()
        self.InvalidMaxCheckpointDuration = (
            IHyperdriveFactoryInvalidMaxCheckpointDurationContractError()
        )
        self.InvalidMaxCircuitBreakerDelta = (
            IHyperdriveFactoryInvalidMaxCircuitBreakerDeltaContractError()
        )
        self.InvalidMaxFees = IHyperdriveFactoryInvalidMaxFeesContractError()
        self.InvalidMaxFixedAPR = (
            IHyperdriveFactoryInvalidMaxFixedAPRContractError()
        )
        self.InvalidMaxPositionDuration = (
            IHyperdriveFactoryInvalidMaxPositionDurationContractError()
        )
        self.InvalidMaxTimeStretchAPR = (
            IHyperdriveFactoryInvalidMaxTimeStretchAPRContractError()
        )
        self.InvalidMinCheckpointDuration = (
            IHyperdriveFactoryInvalidMinCheckpointDurationContractError()
        )
        self.InvalidMinCircuitBreakerDelta = (
            IHyperdriveFactoryInvalidMinCircuitBreakerDeltaContractError()
        )
        self.InvalidMinFees = IHyperdriveFactoryInvalidMinFeesContractError()
        self.InvalidMinFixedAPR = (
            IHyperdriveFactoryInvalidMinFixedAPRContractError()
        )
        self.InvalidMinPositionDuration = (
            IHyperdriveFactoryInvalidMinPositionDurationContractError()
        )
        self.InvalidMinTimeStretchAPR = (
            IHyperdriveFactoryInvalidMinTimeStretchAPRContractError()
        )
        self.InvalidPositionDuration = (
            IHyperdriveFactoryInvalidPositionDurationContractError()
        )
        self.InvalidTimeStretchAPR = (
            IHyperdriveFactoryInvalidTimeStretchAPRContractError()
        )
        self.ReceiveLocked = IHyperdriveFactoryReceiveLockedContractError()
        self.TransferFailed = IHyperdriveFactoryTransferFailedContractError()
        self.Unauthorized = IHyperdriveFactoryUnauthorizedContractError()

        self._all = [
            self.DeployerCoordinatorAlreadyAdded,
            self.DeployerCoordinatorIndexMismatch,
            self.DeployerCoordinatorNotAdded,
            self.EndIndexTooLarge,
            self.InvalidCheckpointDuration,
            self.InvalidCheckpointDurationResolution,
            self.InvalidCircuitBreakerDelta,
            self.InvalidDeployConfig,
            self.InvalidDeployerCoordinator,
            self.InvalidFees,
            self.InvalidFixedAPR,
            self.InvalidIndexes,
            self.InvalidMaxCheckpointDuration,
            self.InvalidMaxCircuitBreakerDelta,
            self.InvalidMaxFees,
            self.InvalidMaxFixedAPR,
            self.InvalidMaxPositionDuration,
            self.InvalidMaxTimeStretchAPR,
            self.InvalidMinCheckpointDuration,
            self.InvalidMinCircuitBreakerDelta,
            self.InvalidMinFees,
            self.InvalidMinFixedAPR,
            self.InvalidMinPositionDuration,
            self.InvalidMinTimeStretchAPR,
            self.InvalidPositionDuration,
            self.InvalidTimeStretchAPR,
            self.ReceiveLocked,
            self.TransferFailed,
            self.Unauthorized,
        ]

    def decode_custom_error(self, data: str) -> tuple[Any, ...]:
        """Decodes a custom contract error."""
        selector = data[:10]
        for err in self._all:
            if err.selector == selector:
                return err.decode_error_data(HexBytes(data[10:]))

        raise ValueError(
            f"IHyperdriveFactory does not have a selector matching {selector}"
        )


ihyperdrivefactory_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "addDeployerCoordinator",
            "inputs": [
                {
                    "name": "_deployerCoordinator",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "checkpointDurationResolution",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "checkpointRewarder",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "defaultPausers",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address[]", "internalType": "address[]"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "deployAndInitialize",
            "inputs": [
                {
                    "name": "_deploymentId",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
                {
                    "name": "_deployerCoordinator",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "__name", "type": "string", "internalType": "string"},
                {
                    "name": "_config",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.PoolDeployConfig",
                    "components": [
                        {
                            "name": "baseToken",
                            "type": "address",
                            "internalType": "contract IERC20",
                        },
                        {
                            "name": "vaultSharesToken",
                            "type": "address",
                            "internalType": "contract IERC20",
                        },
                        {
                            "name": "linkerFactory",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "linkerCodeHash",
                            "type": "bytes32",
                            "internalType": "bytes32",
                        },
                        {
                            "name": "minimumShareReserves",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "minimumTransactionAmount",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "circuitBreakerDelta",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "positionDuration",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "checkpointDuration",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "timeStretch",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "governance",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "feeCollector",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "sweepCollector",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "checkpointRewarder",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "fees",
                            "type": "tuple",
                            "internalType": "struct IHyperdrive.Fees",
                            "components": [
                                {
                                    "name": "curve",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "flat",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "governanceLP",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "governanceZombie",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                            ],
                        },
                    ],
                },
                {
                    "name": "_extraData",
                    "type": "bytes",
                    "internalType": "bytes",
                },
                {
                    "name": "_contribution",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_fixedAPR",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_timeStretchAPR",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_options",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {
                            "name": "destination",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "asBase",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "extraData",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                    ],
                },
                {"name": "_salt", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract IHyperdrive",
                }
            ],
            "stateMutability": "payable",
        },
        {
            "type": "function",
            "name": "deployTarget",
            "inputs": [
                {
                    "name": "_deploymentId",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
                {
                    "name": "_deployerCoordinator",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_config",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.PoolDeployConfig",
                    "components": [
                        {
                            "name": "baseToken",
                            "type": "address",
                            "internalType": "contract IERC20",
                        },
                        {
                            "name": "vaultSharesToken",
                            "type": "address",
                            "internalType": "contract IERC20",
                        },
                        {
                            "name": "linkerFactory",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "linkerCodeHash",
                            "type": "bytes32",
                            "internalType": "bytes32",
                        },
                        {
                            "name": "minimumShareReserves",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "minimumTransactionAmount",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "circuitBreakerDelta",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "positionDuration",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "checkpointDuration",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "timeStretch",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "governance",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "feeCollector",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "sweepCollector",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "checkpointRewarder",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "fees",
                            "type": "tuple",
                            "internalType": "struct IHyperdrive.Fees",
                            "components": [
                                {
                                    "name": "curve",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "flat",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "governanceLP",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "governanceZombie",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                            ],
                        },
                    ],
                },
                {
                    "name": "_extraData",
                    "type": "bytes",
                    "internalType": "bytes",
                },
                {
                    "name": "_fixedAPR",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_timeStretchAPR",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_targetIndex",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "_salt", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "deployerCoordinatorManager",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "feeCollector",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getDeployerCoordinatorAtIndex",
            "inputs": [
                {"name": "_index", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getDeployerCoordinatorByInstances",
            "inputs": [
                {
                    "name": "__instances",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "outputs": [
                {
                    "name": "coordinators",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getDeployerCoordinatorsInRange",
            "inputs": [
                {
                    "name": "_startIndex",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_endIndex",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {
                    "name": "range",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getInstanceAtIndex",
            "inputs": [
                {"name": "_index", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getInstancesInRange",
            "inputs": [
                {
                    "name": "_startIndex",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_endIndex",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {
                    "name": "range",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getNumberOfDeployerCoordinators",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getNumberOfInstances",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "governance",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "hyperdriveGovernance",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isDeployerCoordinator",
            "inputs": [
                {
                    "name": "_deployerCoordinator",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isInstance",
            "inputs": [
                {
                    "name": "_instance",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "kind",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "linkerCodeHash",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "linkerFactory",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "maxCheckpointDuration",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "maxCircuitBreakerDelta",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "maxFees",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Fees",
                    "components": [
                        {
                            "name": "curve",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "flat",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "governanceLP",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "governanceZombie",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "maxFixedAPR",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "maxPositionDuration",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "maxTimeStretchAPR",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "minCheckpointDuration",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "minCircuitBreakerDelta",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "minFees",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Fees",
                    "components": [
                        {
                            "name": "curve",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "flat",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "governanceLP",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "governanceZombie",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "minFixedAPR",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "minPositionDuration",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "minTimeStretchAPR",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "name",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "removeDeployerCoordinator",
            "inputs": [
                {
                    "name": "_deployerCoordinator",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_index",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "sweepCollector",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "updateCheckpointDurationResolution",
            "inputs": [
                {
                    "name": "_checkpointDurationResolution",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateCheckpointRewarder",
            "inputs": [
                {
                    "name": "_checkpointRewarder",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateDefaultPausers",
            "inputs": [
                {
                    "name": "_defaultPausers_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateDeployerCoordinatorManager",
            "inputs": [
                {
                    "name": "_deployerCoordinatorManager",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateFeeCollector",
            "inputs": [
                {
                    "name": "_feeCollector",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateGovernance",
            "inputs": [
                {
                    "name": "_governance",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateHyperdriveGovernance",
            "inputs": [
                {
                    "name": "_hyperdriveGovernance",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateLinkerCodeHash",
            "inputs": [
                {
                    "name": "_linkerCodeHash",
                    "type": "bytes32",
                    "internalType": "bytes32",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateLinkerFactory",
            "inputs": [
                {
                    "name": "_linkerFactory",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateMaxCheckpointDuration",
            "inputs": [
                {
                    "name": "_maxCheckpointDuration",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateMaxCircuitBreakerDelta",
            "inputs": [
                {
                    "name": "_maxCircuitBreakerDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateMaxFees",
            "inputs": [
                {
                    "name": "__maxFees",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Fees",
                    "components": [
                        {
                            "name": "curve",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "flat",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "governanceLP",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "governanceZombie",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateMaxFixedAPR",
            "inputs": [
                {
                    "name": "_maxFixedAPR",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateMaxPositionDuration",
            "inputs": [
                {
                    "name": "_maxPositionDuration",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateMaxTimeStretchAPR",
            "inputs": [
                {
                    "name": "_maxTimeStretchAPR",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateMinCheckpointDuration",
            "inputs": [
                {
                    "name": "_minCheckpointDuration",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateMinCircuitBreakerDelta",
            "inputs": [
                {
                    "name": "_minCircuitBreakerDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateMinFees",
            "inputs": [
                {
                    "name": "__minFees",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Fees",
                    "components": [
                        {
                            "name": "curve",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "flat",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "governanceLP",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "governanceZombie",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateMinFixedAPR",
            "inputs": [
                {
                    "name": "_minFixedAPR",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateMinPositionDuration",
            "inputs": [
                {
                    "name": "_minPositionDuration",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateMinTimeStretchAPR",
            "inputs": [
                {
                    "name": "_minTimeStretchAPR",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateSweepCollector",
            "inputs": [
                {
                    "name": "_sweepCollector",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "version",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "event",
            "name": "CheckpointDurationResolutionUpdated",
            "inputs": [
                {
                    "name": "newCheckpointDurationResolution",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "CheckpointRewarderUpdated",
            "inputs": [
                {
                    "name": "newCheckpointRewarder",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "DefaultPausersUpdated",
            "inputs": [
                {
                    "name": "newDefaultPausers",
                    "type": "address[]",
                    "indexed": False,
                    "internalType": "address[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Deployed",
            "inputs": [
                {
                    "name": "deployerCoordinator",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "hyperdrive",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "name",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "config",
                    "type": "tuple",
                    "indexed": False,
                    "internalType": "struct IHyperdrive.PoolDeployConfig",
                    "components": [
                        {
                            "name": "baseToken",
                            "type": "address",
                            "internalType": "contract IERC20",
                        },
                        {
                            "name": "vaultSharesToken",
                            "type": "address",
                            "internalType": "contract IERC20",
                        },
                        {
                            "name": "linkerFactory",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "linkerCodeHash",
                            "type": "bytes32",
                            "internalType": "bytes32",
                        },
                        {
                            "name": "minimumShareReserves",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "minimumTransactionAmount",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "circuitBreakerDelta",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "positionDuration",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "checkpointDuration",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "timeStretch",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "governance",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "feeCollector",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "sweepCollector",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "checkpointRewarder",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "fees",
                            "type": "tuple",
                            "internalType": "struct IHyperdrive.Fees",
                            "components": [
                                {
                                    "name": "curve",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "flat",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "governanceLP",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "governanceZombie",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                            ],
                        },
                    ],
                },
                {
                    "name": "extraData",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "DeployerCoordinatorAdded",
            "inputs": [
                {
                    "name": "deployerCoordinator",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "DeployerCoordinatorManagerUpdated",
            "inputs": [
                {
                    "name": "deployerCoordinatorManager",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "DeployerCoordinatorRemoved",
            "inputs": [
                {
                    "name": "deployerCoordinator",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "FeeCollectorUpdated",
            "inputs": [
                {
                    "name": "newFeeCollector",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "GovernanceUpdated",
            "inputs": [
                {
                    "name": "governance",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "HyperdriveGovernanceUpdated",
            "inputs": [
                {
                    "name": "hyperdriveGovernance",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "LinkerCodeHashUpdated",
            "inputs": [
                {
                    "name": "newLinkerCodeHash",
                    "type": "bytes32",
                    "indexed": True,
                    "internalType": "bytes32",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "LinkerFactoryUpdated",
            "inputs": [
                {
                    "name": "newLinkerFactory",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MaxCheckpointDurationUpdated",
            "inputs": [
                {
                    "name": "newMaxCheckpointDuration",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MaxCircuitBreakerDeltaUpdated",
            "inputs": [
                {
                    "name": "newMaxCircuitBreakerDelta",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MaxFeesUpdated",
            "inputs": [
                {
                    "name": "newMaxFees",
                    "type": "tuple",
                    "indexed": False,
                    "internalType": "struct IHyperdrive.Fees",
                    "components": [
                        {
                            "name": "curve",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "flat",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "governanceLP",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "governanceZombie",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MaxFixedAPRUpdated",
            "inputs": [
                {
                    "name": "newMaxFixedAPR",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MaxPositionDurationUpdated",
            "inputs": [
                {
                    "name": "newMaxPositionDuration",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MaxTimeStretchAPRUpdated",
            "inputs": [
                {
                    "name": "newMaxTimeStretchAPR",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MinCheckpointDurationUpdated",
            "inputs": [
                {
                    "name": "newMinCheckpointDuration",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MinCircuitBreakerDeltaUpdated",
            "inputs": [
                {
                    "name": "newMinCircuitBreakerDelta",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MinFeesUpdated",
            "inputs": [
                {
                    "name": "newMinFees",
                    "type": "tuple",
                    "indexed": False,
                    "internalType": "struct IHyperdrive.Fees",
                    "components": [
                        {
                            "name": "curve",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "flat",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "governanceLP",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "governanceZombie",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MinFixedAPRUpdated",
            "inputs": [
                {
                    "name": "newMinFixedAPR",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MinPositionDurationUpdated",
            "inputs": [
                {
                    "name": "newMinPositionDuration",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MinTimeStretchAPRUpdated",
            "inputs": [
                {
                    "name": "newMinTimeStretchAPR",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "SweepCollectorUpdated",
            "inputs": [
                {
                    "name": "newSweepCollector",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "error",
            "name": "DeployerCoordinatorAlreadyAdded",
            "inputs": [],
        },
        {
            "type": "error",
            "name": "DeployerCoordinatorIndexMismatch",
            "inputs": [],
        },
        {"type": "error", "name": "DeployerCoordinatorNotAdded", "inputs": []},
        {"type": "error", "name": "EndIndexTooLarge", "inputs": []},
        {"type": "error", "name": "InvalidCheckpointDuration", "inputs": []},
        {
            "type": "error",
            "name": "InvalidCheckpointDurationResolution",
            "inputs": [],
        },
        {"type": "error", "name": "InvalidCircuitBreakerDelta", "inputs": []},
        {"type": "error", "name": "InvalidDeployConfig", "inputs": []},
        {"type": "error", "name": "InvalidDeployerCoordinator", "inputs": []},
        {"type": "error", "name": "InvalidFees", "inputs": []},
        {"type": "error", "name": "InvalidFixedAPR", "inputs": []},
        {"type": "error", "name": "InvalidIndexes", "inputs": []},
        {"type": "error", "name": "InvalidMaxCheckpointDuration", "inputs": []},
        {
            "type": "error",
            "name": "InvalidMaxCircuitBreakerDelta",
            "inputs": [],
        },
        {"type": "error", "name": "InvalidMaxFees", "inputs": []},
        {"type": "error", "name": "InvalidMaxFixedAPR", "inputs": []},
        {"type": "error", "name": "InvalidMaxPositionDuration", "inputs": []},
        {"type": "error", "name": "InvalidMaxTimeStretchAPR", "inputs": []},
        {"type": "error", "name": "InvalidMinCheckpointDuration", "inputs": []},
        {
            "type": "error",
            "name": "InvalidMinCircuitBreakerDelta",
            "inputs": [],
        },
        {"type": "error", "name": "InvalidMinFees", "inputs": []},
        {"type": "error", "name": "InvalidMinFixedAPR", "inputs": []},
        {"type": "error", "name": "InvalidMinPositionDuration", "inputs": []},
        {"type": "error", "name": "InvalidMinTimeStretchAPR", "inputs": []},
        {"type": "error", "name": "InvalidPositionDuration", "inputs": []},
        {"type": "error", "name": "InvalidTimeStretchAPR", "inputs": []},
        {"type": "error", "name": "ReceiveLocked", "inputs": []},
        {"type": "error", "name": "TransferFailed", "inputs": []},
        {"type": "error", "name": "Unauthorized", "inputs": []},
    ],
)


class IHyperdriveFactoryContract(Contract):
    """A web3.py Contract class for the IHyperdriveFactory contract."""

    abi: ABI = ihyperdrivefactory_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr("0x")

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = IHyperdriveFactoryContractFunctions(ihyperdrivefactory_abi, self.w3, address)  # type: ignore
        self.events = IHyperdriveFactoryContractEvents(ihyperdrivefactory_abi, self.w3, address)  # type: ignore
        self.errors = IHyperdriveFactoryContractErrors()

    events: IHyperdriveFactoryContractEvents

    errors: IHyperdriveFactoryContractErrors = (
        IHyperdriveFactoryContractErrors()
    )

    functions: IHyperdriveFactoryContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = IHyperdriveFactoryContractFunctions(
            ihyperdrivefactory_abi, w3, None
        )
        contract.errors = IHyperdriveFactoryContractErrors()

        return contract

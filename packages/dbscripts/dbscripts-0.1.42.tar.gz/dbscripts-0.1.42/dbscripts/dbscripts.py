import os
import re
from abc import ABC, abstractmethod
from collections import deque, defaultdict
from concurrent.futures import ThreadPoolExecutor
from dataclasses import dataclass
from enum import Enum
from typing import Dict, List

from dbscripts.utils import check_path


class InvalidDBScriptFormatError(Exception):
    """
    ! Raised when a database script is read and cannot be processed according to the regex patterns of the associated DB flavor.
    """
    pass


class NotMatchingDBFlavorError(Exception):
    """
    ! Raised when attempting to append a `DBScript` instance with DB flavor A to a `DBScripts` instance with DB flavor B.
    """
    pass


class DBScriptAlreadyPresentError(Exception):
    """
    ! Raised when attempting to append a `DBScript` instance O to a `DBScripts` instance that O is already in and `DBScripts.append(O, True)`.
    """
    pass


class CyclicalDependenciesError(Exception):
    """
    ! Raised when cyclical dependencies are encountered during a `DBScripts.calculate_dependencies()` call.
    """
    pass


class DBObjectTypes(Enum):
    """
    ? An enumerated type of the different kinds of common database objects.
    
    - `TABLE` - a table.
    - `VIEW` - a view.
    - `TRIGGER` - a trigger.
    - `STORED_PROCEDURE` - a stored procedure.
    - `FUNCTION` - a generalzed type for functions; used when the type of function cannot be determined.
    - `SCALAR_FUNCTION` - a scalar function.
    - `TABLE_FUNCTION` - a table function.
    """
    TABLE = "table"
    VIEW = "view"
    TRIGGER = "trigger"
    STORED_PROCEDURE = "stored procedure"
    FUNCTION = "function"
    SCALAR_FUNCTION = "scalar function"
    TABLE_FUNCTION = "table function"


@dataclass
class DBScriptMetadata:
    """
    ? A data class that stores information on a database script - stores its object's name, type, and schema.
    """
    obj_name: str
    obj_type: DBObjectTypes
    obj_schema: str


class DBScript:
    """
    ? Represents a 'database script' - a script, usually generated by a DBMS, that represents some kind of database object
    """
    @check_path
    def __init__(self, path: str, flavor: "IDBFlavor"):
        """
        Args:
            path (str): the path to the database script.
            flavor (IDBFlavor): the flavor of the script - currently, only `DBFlavor_MSSQL()` is available.
        """
        self.path = path
        self.flavor = flavor
        with open(path, 'r') as f:
            self.contents = f.read()
        self.metadata = flavor.get_dbscript_metadata(self)
        self.dependencies: List[DBScript] = []


class IDBScriptsAppender(ABC):
    @abstractmethod
    def append(self, dbscripts: "DBScripts", dbscript: DBScript) -> None:
        """
        ? Properly appends a `DBScript` instance to the collection.
        
        # ! Use this over self.scripts.append(dbscript) !
        """
        pass


class DBScriptsAppendRegular(IDBScriptsAppender):
    """
    ? Appends a script to the `DBScripts` collection with no additional logic - allows duplicates.
    """
    def append(self, dbscripts: "DBScripts", dbscript: DBScript) -> None:
        dbscripts.scripts.append(dbscript)
        dbscripts.obj_name_to_dbscript_mapping[dbscript.metadata.obj_name] = dbscript


class DBScriptsAppendIgnoreDuplicates(IDBScriptsAppender):
    """
    ? Appends a script to the `DBScripts` collection if not already present. If present, then the method ends.
    """
    def append(self, dbscripts: "DBScripts", dbscript: DBScript) -> None:
        if dbscript in dbscripts.scripts:
            return
        dbscripts.scripts.append(dbscript)
        dbscripts.obj_name_to_dbscript_mapping[dbscript.metadata.obj_name] = dbscript


class DBScriptsAppendErrorOnDuplicates(IDBScriptsAppender):
    """
    ? Appends a script to the `DBScripts` collection if not already present. If present, a `DBScriptAlreadyPresentError` is raised.
    """
    def append(self, dbscripts: "DBScripts", dbscript: DBScript) -> None:
        if dbscript in dbscripts.scripts:
            raise DBScriptAlreadyPresentError(f'The database script at "{dbscript.path}" is already present in the DBScripts collection.')
        dbscripts.scripts.append(dbscript)
        dbscripts.obj_name_to_dbscript_mapping[dbscript.metadata.obj_name] = dbscript


class DBScripts:
    """
    ? A collection of `DBScript` instances - provides methods that, one way or another, act upon multiple database scripts.
    """
    def __init__(self, flavor: "IDBFlavor", appender: IDBScriptsAppender):
        """
        Args:
            flavor (IDBFlavor): the flavor of the scripts - currently, only `DBFlavor_MSSQL()` is available.
            appender (IDBScriptsAppender): the appending strategy to utilize. Choose from `DBScriptsAppendRegular()`, `DBScriptsAppendIgnoreDuplicates()`, or `DBScriptsAppendErrorOnDuplicates()`.
        """
        self.flavor = flavor
        self.appender = appender
        self.scripts: List[DBScript] = []
        self.obj_name_to_dbscript_mapping: Dict[str, DBScript] = {}
    
    #* APPEND/CLEAR/REMOVE - Use these instead of self.scripts.append, self.scripts.clear, self.scripts.clear
    #* to force the recalculation of dependencies when getting a safe exectuion order following modification.
    
    def append(self, dbscript: DBScript) -> None:
        self.appender.append(self, dbscript)
        if hasattr(self, '_safe_execution_order'):
            delattr(self, "_safe_execution_order")
    
    def clear(self) -> None:
        self.scripts.clear()
        self.obj_name_to_dbscript_mapping = {}
        if hasattr(self, '_safe_execution_order'):
            delattr(self, "_safe_execution_order")
    
    def remove(self, dbscript: DBScript) -> None:
        try:
            self.scripts.remove(dbscript)
            self.obj_name_to_dbscript_mapping.pop(dbscript.metadata.obj_name)
            if hasattr(self, '_safe_execution_order'):
                delattr(self, "_safe_execution_order")
        except (ValueError, KeyError):
            return
    
    @check_path
    def populate_from_dir(self, dir: str) -> None:
        """
        ? Populates the collection of `DBScript` instances with an instance for every .sql file in a directory.
        
        ! You must ensure that all `.sql` files in the directory are 'database scripts' as formatted with the starting format of the `IDBFlavor` implementation used.
        """
        self.clear()
        for _, _, filenames in os.walk(dir):
            for filename in filenames:
                filename = filename.strip()
                if filename.endswith('.sql'):
                    self.append(DBScript(os.path.join(dir, filename), self.flavor))
    
    @check_path
    def append_from_dir(self, dir: str) -> None:
        """
        ? Appends the collection of `DBScript` instances with an instance for every .sql file in a directory.
        
        ! You must ensure that all `.sql` files in the directory are 'database scripts' as formatted with the starting format of the `IDBFlavor` implementation used.
        """
        for _, _, filenames in os.walk(dir):
            for filename in filenames:
                filename = filename.strip()
                if filename.endswith('.sql'):
                    self.append(DBScript(os.path.join(dir, filename), self.flavor))
    
    
    #* Methods for Dependency Calculation
    
    def _preprocess_references(self, script: DBScript) -> Dict[str, DBScript]:
        """
        ? Pre-process references to avoid repeated regex calls.
        """
        return {
            obj_name: dependent_script
            for obj_name, dependent_script in self.obj_name_to_dbscript_mapping.items()
            if obj_name != script.metadata.obj_name and self.flavor.is_valid_ref(obj_name, script)
        }
    
    def _build_dependency_graph(self, preprocessed_references: Dict[str, Dict[str, DBScript]]):
        """
        ? Builds a dependency graph using preprocessed references.
        """
        graph = defaultdict(list)
        in_degree = defaultdict(int)
        
        for script in self.scripts:
            script.dependencies = set()
            obj_name = script.metadata.obj_name
            in_degree[obj_name] = 0
            
            for dependent_script in preprocessed_references[obj_name].values():
                dep_obj_name = dependent_script.metadata.obj_name
                if dependent_script not in script.dependencies:
                    graph[dep_obj_name].append(obj_name)
                    in_degree[obj_name] += 1
                    script.dependencies.add(dependent_script)

        return graph, in_degree
    
    def _parallel_references_preprocess(self):
        """
        ? Parallelizes the preprocessing of references using a thread pool.
        """
        preprocessed_references = {}
        with ThreadPoolExecutor() as executor:
            futures = {executor.submit(self._preprocess_references, script): script for script in self.scripts}
            for future in futures:
                script = futures[future]
                preprocessed_references[script.metadata.obj_name] = future.result()
        return preprocessed_references

    def calculate_dependencies(self) -> None:
        """
        ? Populates the dependencies attribute for all the `DBScript` instances in the collection via Khan's topological sort.
        
        ! Raises a `CyclicalDependenciesError` if cyclical dependencies are detected following the dependency calculation.
        """
        preprocessed_references = self._parallel_references_preprocess()
        graph, in_degree = self._build_dependency_graph(preprocessed_references)
        self._safe_execution_order: List[DBScript] = []
        queue = deque([script for script in self.scripts if in_degree[script.metadata.obj_name] == 0])

        while queue:
            current = queue.popleft()
            self._safe_execution_order.append(current)

            for dependent_obj_name in graph[current.metadata.obj_name]:
                in_degree[dependent_obj_name] -= 1
                if in_degree[dependent_obj_name] == 0:
                    queue.append(self.obj_name_to_dbscript_mapping[dependent_obj_name])

        if len(self._safe_execution_order) != len(self.scripts):
            raise CyclicalDependenciesError('Cyclical dependencies were detected when calculating dependencies within the DBScript collection.')
    
    def uses_dependencies(func):
        def wrapper(self: "DBScripts", *args, **kwargs):
            if not hasattr(self, '_safe_execution_order'):
                self.calculate_dependencies()
            return func(self, *args, **kwargs)
        return wrapper
    
    @uses_dependencies    
    def safe_execution_order(self) -> List[DBScript]:
        """
        ? Returns the list of `DBScript` instances in the collection in an order safe to execute without missing dependencies.
        
        ! Note that, if some dependencies were not included in the `DBScripts` instance to begin with, these will not be accounted for! 
        """
        return self._safe_execution_order

    @uses_dependencies
    def get_dependents(self, script: DBScript) -> List[DBScript]:
        """
        ? Returns a list of DBScript instances that have the given script as a dependency.
        """
        dependents = []
        for s in self.scripts:
            if script in s.dependencies:
                dependents.append(s)
        return dependents

    def __iter__(self):
        return iter(self.scripts)
    
    
class IDBFlavor(ABC):
    @abstractmethod
    def get_dbscript_metadata(self, dbscript: DBScript) -> DBScriptMetadata:
        """
        ? Returns a `DBScriptMetadata` object storing metadata about the `DBScript` object provided.
        
        ! Raises an `InvalidDBScriptFormatError` if a provided script does not match the correct starting format for the `IDBFavlor` implementation in use.
        """
        pass
    
    @staticmethod
    @abstractmethod
    def cleaned_contents(contents: str) -> str:
        """
        ? Returns the contents of a database script with comments and string literals removed.
        """
        pass
    
    @staticmethod
    @abstractmethod
    def extract_relevant_sections(contents: str) -> str:
        """
        ? Used by is_valid_ref - removes static noise.
        """
    
    @abstractmethod
    def is_valid_ref(self, obj_name: str, dbscript: DBScript) -> bool:
        """
        ? Returns whether or not a database object reference in a script is a proper reference or just a false positive.
        """
        pass


class DBFlavor_MSSQL(IDBFlavor):
    """
    ? Provides regex patterns and methods that corrospond to Microsoft SQL Server syntax and SQL.
    
    ! `DBScript` objects MUST have their contents be of the following starting format in order to be read:
    * "<CREATE|ALTER|CREATE OR ALTER> <TABLE|VIEW|TRIGGER|FUNCTION|PROCEDURE> [SCHEMA].[OBJ_NAME]"
    
    ! Failure to ensure this will raise an `InvalidDBScriptFormatError` on `DBScript.__init__` when this flavor is passed.
    """
    patterns = {
        DBObjectTypes.TABLE: re.compile(r'CREATE\s+(OR\s+ALTER\s+)?TABLE\s+\[([a-zA-Z0-9_]+)\]\.\[([a-zA-Z0-9_]+)\]', re.IGNORECASE),
        DBObjectTypes.VIEW: re.compile(r'CREATE\s+(OR\s+ALTER\s+)?VIEW\s+\[([a-zA-Z0-9_]+)\]\.\[([a-zA-Z0-9_]+)\]', re.IGNORECASE),
        DBObjectTypes.TRIGGER: re.compile(r'CREATE\s+(OR\s+ALTER\s+)?TRIGGER\s+\[([a-zA-Z0-9_]+)\]\.\[([a-zA-Z0-9_]+)\]', re.IGNORECASE),
        DBObjectTypes.FUNCTION: re.compile(r'CREATE\s+(OR\s+ALTER\s+)?FUNCTION\s+\[([a-zA-Z0-9_]+)\]\.\[([a-zA-Z0-9_]+)\]', re.IGNORECASE),
        DBObjectTypes.SCALAR_FUNCTION: re.compile(r'RETURNS\s+(?!TABLE)\w+', re.IGNORECASE),  #* Search for general FUNCTION first.
        DBObjectTypes.TABLE_FUNCTION: re.compile(r'RETURNS\s+(?=TABLE)\w+', re.IGNORECASE),  #* Search for general FUNCTION first.
        DBObjectTypes.STORED_PROCEDURE: re.compile(r'CREATE\s+(OR\s+ALTER\s+)?PROCEDURE\s+\[([a-zA-Z0-9_]+)\]\.\[([a-zA-Z0-9_]+)\]', re.IGNORECASE)
    }
    valid_context_keywords = ('JOIN', 'FROM', 'INTO', 'UPDATE', 'DELETE', 'INSERT', 'EXEC', 'CALL')
    keywords_pattern = '|'.join(map(re.escape, valid_context_keywords))
    
    def get_dbscript_metadata(self, dbscript: "DBScript") -> DBScriptMetadata:
        if (m := re.search(self.patterns[DBObjectTypes.TABLE], dbscript.contents)):
            return DBScriptMetadata(m.group(3), DBObjectTypes.TABLE, m.group(2))
        elif (m := re.search(self.patterns[DBObjectTypes.VIEW], dbscript.contents)):
            return DBScriptMetadata(m.group(3), DBObjectTypes.VIEW, m.group(2))
        elif (m := re.search(self.patterns[DBObjectTypes.TRIGGER], dbscript.contents)):
            return DBScriptMetadata(m.group(3), DBObjectTypes.TRIGGER, m.group(2))
        elif (m := re.search(self.patterns[DBObjectTypes.FUNCTION], dbscript.contents)):
            obj_name, obj_schema = m.group(3), m.group(2)
            if (m := re.search(self.patterns[DBObjectTypes.TABLE_FUNCTION], dbscript.contents)):
                obj_type = DBObjectTypes.TABLE_FUNCTION
            elif (m := re.search(self.patterns[DBObjectTypes.SCALAR_FUNCTION], dbscript.contents)):
                obj_type = DBObjectTypes.SCALAR_FUNCTION
            else:
                obj_type = DBObjectTypes.FUNCTION
            return DBScriptMetadata(obj_name, obj_type, obj_schema)
        elif (m := re.search(self.patterns[DBObjectTypes.STORED_PROCEDURE], dbscript.contents)):
            return DBScriptMetadata(m.group(3), DBObjectTypes.STORED_PROCEDURE, m.group(2))
        else:
            raise InvalidDBScriptFormatError(f'Invalid contents format for the DB script at "{dbscript.path}".')

    @staticmethod
    def cleaned_contents(contents: str) -> str:
        contents = re.sub(r'--.*', '', contents)
        contents = re.sub(r'/\*.*?\*/', '', contents, flags=re.DOTALL)
        contents = re.sub(r"'([^']*)'", '', contents)
        contents = re.sub(r'"([^"]*)"', '', contents)
        return contents
    
    @staticmethod
    def extract_relevant_sections(contents: str) -> str:
        relevant_lines = []
        for line in contents.splitlines():
            if any(keyword in line for keyword in ('JOIN', 'FROM', 'EXEC', 'INTO', 'UPDATE', 'DELETE', 'INSERT')):
                relevant_lines.append(line)
        return '\n'.join(relevant_lines)
    
    def is_valid_ref(self, obj_name: str, dbscript: DBScript) -> bool:
        processed_script = self.cleaned_contents(dbscript.contents)
        processed_script = self.extract_relevant_sections(processed_script)
        escaped_obj_name = re.escape(obj_name)
        combined_pattern = re.compile(
            rf'(\[?[a-zA-Z0-9_]+\]?\.)?'
            rf'({escaped_obj_name}|\[{escaped_obj_name}\])'
            rf'\s+({self.keywords_pattern})',
            re.IGNORECASE
        )
        return bool(combined_pattern.search(processed_script))

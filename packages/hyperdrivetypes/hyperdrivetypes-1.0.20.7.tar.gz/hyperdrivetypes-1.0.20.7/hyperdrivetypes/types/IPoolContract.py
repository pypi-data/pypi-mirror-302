"""A web3.py Contract class for the IPool contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.43.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overriden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long


from __future__ import annotations

from typing import Any, Iterable, NamedTuple, Sequence, Type, cast

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    combomethod_typed,
    dataclass_to_tuple,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunction,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from . import DataTypesTypes as DataTypes
from .IPoolTypes import (
    BackUnbackedEvent,
    BorrowEvent,
    FlashLoanEvent,
    IsolationModeTotalDebtUpdatedEvent,
    LiquidationCallEvent,
    MintedToTreasuryEvent,
    MintUnbackedEvent,
    RebalanceStableBorrowRateEvent,
    RepayEvent,
    ReserveDataUpdatedEvent,
    ReserveUsedAsCollateralDisabledEvent,
    ReserveUsedAsCollateralEnabledEvent,
    SupplyEvent,
    SwapBorrowRateModeEvent,
    UserEModeSetEvent,
    WithdrawEvent,
)

structs = {
    "DataTypes.EModeCategory": DataTypes.EModeCategory,
    "DataTypes.ReserveConfigurationMap": DataTypes.ReserveConfigurationMap,
    "DataTypes.ReserveData": DataTypes.ReserveData,
    "DataTypes.UserConfigurationMap": DataTypes.UserConfigurationMap,
}


class IPoolADDRESSES_PROVIDERContractFunction(ContractFunction):
    """ContractFunction for the ADDRESSES_PROVIDER method."""

    def __call__(self) -> IPoolADDRESSES_PROVIDERContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolBRIDGE_PROTOCOL_FEEContractFunction(ContractFunction):
    """ContractFunction for the BRIDGE_PROTOCOL_FEE method."""

    def __call__(self) -> IPoolBRIDGE_PROTOCOL_FEEContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolFLASHLOAN_PREMIUM_TOTALContractFunction(ContractFunction):
    """ContractFunction for the FLASHLOAN_PREMIUM_TOTAL method."""

    def __call__(self) -> IPoolFLASHLOAN_PREMIUM_TOTALContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction(ContractFunction):
    """ContractFunction for the FLASHLOAN_PREMIUM_TO_PROTOCOL method."""

    def __call__(self) -> IPoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolMAX_NUMBER_RESERVESContractFunction(ContractFunction):
    """ContractFunction for the MAX_NUMBER_RESERVES method."""

    def __call__(self) -> IPoolMAX_NUMBER_RESERVESContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction(
    ContractFunction
):
    """ContractFunction for the MAX_STABLE_RATE_BORROW_SIZE_PERCENT method."""

    def __call__(self) -> IPoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolBackUnbackedContractFunction(ContractFunction):
    """ContractFunction for the backUnbacked method."""

    def __call__(self, asset: str, amount: int, fee: int) -> IPoolBackUnbackedContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset),
            dataclass_to_tuple(amount),
            dataclass_to_tuple(fee),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolBorrowContractFunction(ContractFunction):
    """ContractFunction for the borrow method."""

    def __call__(self, asset: str, amount: int, interestRateMode: int, referralCode: int, onBehalfOf: str) -> IPoolBorrowContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset),
            dataclass_to_tuple(amount),
            dataclass_to_tuple(interestRateMode),
            dataclass_to_tuple(referralCode),
            dataclass_to_tuple(onBehalfOf),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolConfigureEModeCategoryContractFunction(ContractFunction):
    """ContractFunction for the configureEModeCategory method."""

    def __call__(self, _id: int, config: DataTypes.EModeCategory) -> IPoolConfigureEModeCategoryContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(_id), dataclass_to_tuple(config)
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolDepositContractFunction(ContractFunction):
    """ContractFunction for the deposit method."""

    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int) -> IPoolDepositContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset),
            dataclass_to_tuple(amount),
            dataclass_to_tuple(onBehalfOf),
            dataclass_to_tuple(referralCode),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolDropReserveContractFunction(ContractFunction):
    """ContractFunction for the dropReserve method."""

    def __call__(self, asset: str) -> IPoolDropReserveContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(asset))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolFinalizeTransferContractFunction(ContractFunction):
    """ContractFunction for the finalizeTransfer method."""

    def __call__(self, asset: str, _from: str, to: str, amount: int, balanceFromBefore: int, balanceToBefore: int) -> IPoolFinalizeTransferContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset),
            dataclass_to_tuple(_from),
            dataclass_to_tuple(to),
            dataclass_to_tuple(amount),
            dataclass_to_tuple(balanceFromBefore),
            dataclass_to_tuple(balanceToBefore),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolFlashLoanContractFunction(ContractFunction):
    """ContractFunction for the flashLoan method."""

    def __call__(self, receiverAddress: str, assets: list[str], amounts: list[int], interestRateModes: list[int], onBehalfOf: str, params: bytes, referralCode: int) -> IPoolFlashLoanContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(receiverAddress),
            dataclass_to_tuple(assets),
            dataclass_to_tuple(amounts),
            dataclass_to_tuple(interestRateModes),
            dataclass_to_tuple(onBehalfOf),
            dataclass_to_tuple(params),
            dataclass_to_tuple(referralCode),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolFlashLoanSimpleContractFunction(ContractFunction):
    """ContractFunction for the flashLoanSimple method."""

    def __call__(self, receiverAddress: str, asset: str, amount: int, params: bytes, referralCode: int) -> IPoolFlashLoanSimpleContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(receiverAddress),
            dataclass_to_tuple(asset),
            dataclass_to_tuple(amount),
            dataclass_to_tuple(params),
            dataclass_to_tuple(referralCode),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolGetConfigurationContractFunction(ContractFunction):
    """ContractFunction for the getConfiguration method."""

    def __call__(self, asset: str) -> IPoolGetConfigurationContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(asset))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.ReserveConfigurationMap:
        """returns DataTypes.ReserveConfigurationMap."""
        # Define the expected return types from the smart contract call

        return_types = DataTypes.ReserveConfigurationMap

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            DataTypes.ReserveConfigurationMap,
            rename_returned_types(structs, return_types, raw_values),
        )


class IPoolGetEModeCategoryDataContractFunction(ContractFunction):
    """ContractFunction for the getEModeCategoryData method."""

    def __call__(self, _id: int) -> IPoolGetEModeCategoryDataContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(_id))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.EModeCategory:
        """returns DataTypes.EModeCategory."""
        # Define the expected return types from the smart contract call

        return_types = DataTypes.EModeCategory

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            DataTypes.EModeCategory,
            rename_returned_types(structs, return_types, raw_values),
        )


class IPoolGetReserveAddressByIdContractFunction(ContractFunction):
    """ContractFunction for the getReserveAddressById method."""

    def __call__(self, _id: int) -> IPoolGetReserveAddressByIdContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(_id))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # Define the expected return types from the smart contract call

        return_types = str

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetReserveDataContractFunction(ContractFunction):
    """ContractFunction for the getReserveData method."""

    def __call__(self, asset: str) -> IPoolGetReserveDataContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(asset))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.ReserveData:
        """returns DataTypes.ReserveData."""
        # Define the expected return types from the smart contract call

        return_types = DataTypes.ReserveData

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            DataTypes.ReserveData,
            rename_returned_types(structs, return_types, raw_values),
        )


class IPoolGetReserveNormalizedIncomeContractFunction(ContractFunction):
    """ContractFunction for the getReserveNormalizedIncome method."""

    def __call__(self, asset: str) -> IPoolGetReserveNormalizedIncomeContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(asset))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetReserveNormalizedVariableDebtContractFunction(ContractFunction):
    """ContractFunction for the getReserveNormalizedVariableDebt method."""

    def __call__(self, asset: str) -> IPoolGetReserveNormalizedVariableDebtContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(asset))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetReservesListContractFunction(ContractFunction):
    """ContractFunction for the getReservesList method."""

    def __call__(self) -> IPoolGetReservesListContractFunction:  # type: ignore
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # Define the expected return types from the smart contract call

        return_types = list[str]

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetUserAccountDataContractFunction(ContractFunction):
    """ContractFunction for the getUserAccountData method."""

    class ReturnValues(NamedTuple):
        """The return named tuple for GetUserAccountData."""

        totalCollateralBase: int
        totalDebtBase: int
        availableBorrowsBase: int
        currentLiquidationThreshold: int
        ltv: int
        healthFactor: int

    def __call__(self, user: str) -> IPoolGetUserAccountDataContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(user))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # Define the expected return types from the smart contract call

        return_types = [int, int, int, int, int, int]

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetUserConfigurationContractFunction(ContractFunction):
    """ContractFunction for the getUserConfiguration method."""

    def __call__(self, user: str) -> IPoolGetUserConfigurationContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(user))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.UserConfigurationMap:
        """returns DataTypes.UserConfigurationMap."""
        # Define the expected return types from the smart contract call

        return_types = DataTypes.UserConfigurationMap

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            DataTypes.UserConfigurationMap,
            rename_returned_types(structs, return_types, raw_values),
        )


class IPoolGetUserEModeContractFunction(ContractFunction):
    """ContractFunction for the getUserEMode method."""

    def __call__(self, user: str) -> IPoolGetUserEModeContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(user))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolInitReserveContractFunction(ContractFunction):
    """ContractFunction for the initReserve method."""

    def __call__(self, asset: str, aTokenAddress: str, stableDebtAddress: str, variableDebtAddress: str, interestRateStrategyAddress: str) -> IPoolInitReserveContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset),
            dataclass_to_tuple(aTokenAddress),
            dataclass_to_tuple(stableDebtAddress),
            dataclass_to_tuple(variableDebtAddress),
            dataclass_to_tuple(interestRateStrategyAddress),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolLiquidationCallContractFunction(ContractFunction):
    """ContractFunction for the liquidationCall method."""

    def __call__(self, collateralAsset: str, debtAsset: str, user: str, debtToCover: int, receiveAToken: bool) -> IPoolLiquidationCallContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(collateralAsset),
            dataclass_to_tuple(debtAsset),
            dataclass_to_tuple(user),
            dataclass_to_tuple(debtToCover),
            dataclass_to_tuple(receiveAToken),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolMintToTreasuryContractFunction(ContractFunction):
    """ContractFunction for the mintToTreasury method."""

    def __call__(self, assets: list[str]) -> IPoolMintToTreasuryContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(assets))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolMintUnbackedContractFunction(ContractFunction):
    """ContractFunction for the mintUnbacked method."""

    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int) -> IPoolMintUnbackedContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset),
            dataclass_to_tuple(amount),
            dataclass_to_tuple(onBehalfOf),
            dataclass_to_tuple(referralCode),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolRebalanceStableBorrowRateContractFunction(ContractFunction):
    """ContractFunction for the rebalanceStableBorrowRate method."""

    def __call__(self, asset: str, user: str) -> IPoolRebalanceStableBorrowRateContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset), dataclass_to_tuple(user)
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolRepayContractFunction(ContractFunction):
    """ContractFunction for the repay method."""

    def __call__(self, asset: str, amount: int, interestRateMode: int, onBehalfOf: str) -> IPoolRepayContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset),
            dataclass_to_tuple(amount),
            dataclass_to_tuple(interestRateMode),
            dataclass_to_tuple(onBehalfOf),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolRepayWithATokensContractFunction(ContractFunction):
    """ContractFunction for the repayWithATokens method."""

    def __call__(self, asset: str, amount: int, interestRateMode: int) -> IPoolRepayWithATokensContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset),
            dataclass_to_tuple(amount),
            dataclass_to_tuple(interestRateMode),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolRepayWithPermitContractFunction(ContractFunction):
    """ContractFunction for the repayWithPermit method."""

    def __call__(self, asset: str, amount: int, interestRateMode: int, onBehalfOf: str, deadline: int, permitV: int, permitR: bytes, permitS: bytes) -> IPoolRepayWithPermitContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset),
            dataclass_to_tuple(amount),
            dataclass_to_tuple(interestRateMode),
            dataclass_to_tuple(onBehalfOf),
            dataclass_to_tuple(deadline),
            dataclass_to_tuple(permitV),
            dataclass_to_tuple(permitR),
            dataclass_to_tuple(permitS),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolRescueTokensContractFunction(ContractFunction):
    """ContractFunction for the rescueTokens method."""

    def __call__(self, token: str, to: str, amount: int) -> IPoolRescueTokensContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(token),
            dataclass_to_tuple(to),
            dataclass_to_tuple(amount),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolResetIsolationModeTotalDebtContractFunction(ContractFunction):
    """ContractFunction for the resetIsolationModeTotalDebt method."""

    def __call__(self, asset: str) -> IPoolResetIsolationModeTotalDebtContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(asset))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolSetConfigurationContractFunction(ContractFunction):
    """ContractFunction for the setConfiguration method."""

    def __call__(self, asset: str, configuration: DataTypes.ReserveConfigurationMap) -> IPoolSetConfigurationContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset), dataclass_to_tuple(configuration)
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolSetReserveInterestRateStrategyAddressContractFunction(
    ContractFunction
):
    """ContractFunction for the setReserveInterestRateStrategyAddress method."""

    def __call__(self, asset: str, rateStrategyAddress: str) -> IPoolSetReserveInterestRateStrategyAddressContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset), dataclass_to_tuple(rateStrategyAddress)
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolSetUserEModeContractFunction(ContractFunction):
    """ContractFunction for the setUserEMode method."""

    def __call__(self, categoryId: int) -> IPoolSetUserEModeContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(categoryId))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolSetUserUseReserveAsCollateralContractFunction(ContractFunction):
    """ContractFunction for the setUserUseReserveAsCollateral method."""

    def __call__(self, asset: str, useAsCollateral: bool) -> IPoolSetUserUseReserveAsCollateralContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset), dataclass_to_tuple(useAsCollateral)
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolSupplyContractFunction(ContractFunction):
    """ContractFunction for the supply method."""

    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int) -> IPoolSupplyContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset),
            dataclass_to_tuple(amount),
            dataclass_to_tuple(onBehalfOf),
            dataclass_to_tuple(referralCode),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolSupplyWithPermitContractFunction(ContractFunction):
    """ContractFunction for the supplyWithPermit method."""

    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int, deadline: int, permitV: int, permitR: bytes, permitS: bytes) -> IPoolSupplyWithPermitContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset),
            dataclass_to_tuple(amount),
            dataclass_to_tuple(onBehalfOf),
            dataclass_to_tuple(referralCode),
            dataclass_to_tuple(deadline),
            dataclass_to_tuple(permitV),
            dataclass_to_tuple(permitR),
            dataclass_to_tuple(permitS),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolSwapBorrowRateModeContractFunction(ContractFunction):
    """ContractFunction for the swapBorrowRateMode method."""

    def __call__(self, asset: str, interestRateMode: int) -> IPoolSwapBorrowRateModeContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset), dataclass_to_tuple(interestRateMode)
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolUpdateBridgeProtocolFeeContractFunction(ContractFunction):
    """ContractFunction for the updateBridgeProtocolFee method."""

    def __call__(self, bridgeProtocolFee: int) -> IPoolUpdateBridgeProtocolFeeContractFunction:  # type: ignore
        clone = super().__call__(dataclass_to_tuple(bridgeProtocolFee))
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolUpdateFlashloanPremiumsContractFunction(ContractFunction):
    """ContractFunction for the updateFlashloanPremiums method."""

    def __call__(self, flashLoanPremiumTotal: int, flashLoanPremiumToProtocol: int) -> IPoolUpdateFlashloanPremiumsContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(flashLoanPremiumTotal),
            dataclass_to_tuple(flashLoanPremiumToProtocol),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # Define the expected return types from the smart contract call

        # Call the function


class IPoolWithdrawContractFunction(ContractFunction):
    """ContractFunction for the withdraw method."""

    def __call__(self, asset: str, amount: int, to: str) -> IPoolWithdrawContractFunction:  # type: ignore
        clone = super().__call__(
            dataclass_to_tuple(asset),
            dataclass_to_tuple(amount),
            dataclass_to_tuple(to),
        )
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # Define the expected return types from the smart contract call

        return_types = int

        # Call the function

        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolContractFunctions(ContractFunctions):
    """ContractFunctions for the IPool contract."""

    ADDRESSES_PROVIDER: IPoolADDRESSES_PROVIDERContractFunction

    BRIDGE_PROTOCOL_FEE: IPoolBRIDGE_PROTOCOL_FEEContractFunction

    FLASHLOAN_PREMIUM_TOTAL: IPoolFLASHLOAN_PREMIUM_TOTALContractFunction

    FLASHLOAN_PREMIUM_TO_PROTOCOL: (
        IPoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction
    )

    MAX_NUMBER_RESERVES: IPoolMAX_NUMBER_RESERVESContractFunction

    MAX_STABLE_RATE_BORROW_SIZE_PERCENT: (
        IPoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction
    )

    backUnbacked: IPoolBackUnbackedContractFunction

    borrow: IPoolBorrowContractFunction

    configureEModeCategory: IPoolConfigureEModeCategoryContractFunction

    deposit: IPoolDepositContractFunction

    dropReserve: IPoolDropReserveContractFunction

    finalizeTransfer: IPoolFinalizeTransferContractFunction

    flashLoan: IPoolFlashLoanContractFunction

    flashLoanSimple: IPoolFlashLoanSimpleContractFunction

    getConfiguration: IPoolGetConfigurationContractFunction

    getEModeCategoryData: IPoolGetEModeCategoryDataContractFunction

    getReserveAddressById: IPoolGetReserveAddressByIdContractFunction

    getReserveData: IPoolGetReserveDataContractFunction

    getReserveNormalizedIncome: IPoolGetReserveNormalizedIncomeContractFunction

    getReserveNormalizedVariableDebt: (
        IPoolGetReserveNormalizedVariableDebtContractFunction
    )

    getReservesList: IPoolGetReservesListContractFunction

    getUserAccountData: IPoolGetUserAccountDataContractFunction

    getUserConfiguration: IPoolGetUserConfigurationContractFunction

    getUserEMode: IPoolGetUserEModeContractFunction

    initReserve: IPoolInitReserveContractFunction

    liquidationCall: IPoolLiquidationCallContractFunction

    mintToTreasury: IPoolMintToTreasuryContractFunction

    mintUnbacked: IPoolMintUnbackedContractFunction

    rebalanceStableBorrowRate: IPoolRebalanceStableBorrowRateContractFunction

    repay: IPoolRepayContractFunction

    repayWithATokens: IPoolRepayWithATokensContractFunction

    repayWithPermit: IPoolRepayWithPermitContractFunction

    rescueTokens: IPoolRescueTokensContractFunction

    resetIsolationModeTotalDebt: (
        IPoolResetIsolationModeTotalDebtContractFunction
    )

    setConfiguration: IPoolSetConfigurationContractFunction

    setReserveInterestRateStrategyAddress: (
        IPoolSetReserveInterestRateStrategyAddressContractFunction
    )

    setUserEMode: IPoolSetUserEModeContractFunction

    setUserUseReserveAsCollateral: (
        IPoolSetUserUseReserveAsCollateralContractFunction
    )

    supply: IPoolSupplyContractFunction

    supplyWithPermit: IPoolSupplyWithPermitContractFunction

    swapBorrowRateMode: IPoolSwapBorrowRateModeContractFunction

    updateBridgeProtocolFee: IPoolUpdateBridgeProtocolFeeContractFunction

    updateFlashloanPremiums: IPoolUpdateFlashloanPremiumsContractFunction

    withdraw: IPoolWithdrawContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.ADDRESSES_PROVIDER = (
            IPoolADDRESSES_PROVIDERContractFunction.factory(
                "ADDRESSES_PROVIDER",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="ADDRESSES_PROVIDER",
            )
        )
        self.BRIDGE_PROTOCOL_FEE = (
            IPoolBRIDGE_PROTOCOL_FEEContractFunction.factory(
                "BRIDGE_PROTOCOL_FEE",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="BRIDGE_PROTOCOL_FEE",
            )
        )
        self.FLASHLOAN_PREMIUM_TOTAL = (
            IPoolFLASHLOAN_PREMIUM_TOTALContractFunction.factory(
                "FLASHLOAN_PREMIUM_TOTAL",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="FLASHLOAN_PREMIUM_TOTAL",
            )
        )
        self.FLASHLOAN_PREMIUM_TO_PROTOCOL = (
            IPoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction.factory(
                "FLASHLOAN_PREMIUM_TO_PROTOCOL",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="FLASHLOAN_PREMIUM_TO_PROTOCOL",
            )
        )
        self.MAX_NUMBER_RESERVES = (
            IPoolMAX_NUMBER_RESERVESContractFunction.factory(
                "MAX_NUMBER_RESERVES",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="MAX_NUMBER_RESERVES",
            )
        )
        self.MAX_STABLE_RATE_BORROW_SIZE_PERCENT = (
            IPoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction.factory(
                "MAX_STABLE_RATE_BORROW_SIZE_PERCENT",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="MAX_STABLE_RATE_BORROW_SIZE_PERCENT",
            )
        )
        self.backUnbacked = IPoolBackUnbackedContractFunction.factory(
            "backUnbacked",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="backUnbacked",
        )
        self.borrow = IPoolBorrowContractFunction.factory(
            "borrow",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="borrow",
        )
        self.configureEModeCategory = (
            IPoolConfigureEModeCategoryContractFunction.factory(
                "configureEModeCategory",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="configureEModeCategory",
            )
        )
        self.deposit = IPoolDepositContractFunction.factory(
            "deposit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="deposit",
        )
        self.dropReserve = IPoolDropReserveContractFunction.factory(
            "dropReserve",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="dropReserve",
        )
        self.finalizeTransfer = IPoolFinalizeTransferContractFunction.factory(
            "finalizeTransfer",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="finalizeTransfer",
        )
        self.flashLoan = IPoolFlashLoanContractFunction.factory(
            "flashLoan",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="flashLoan",
        )
        self.flashLoanSimple = IPoolFlashLoanSimpleContractFunction.factory(
            "flashLoanSimple",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="flashLoanSimple",
        )
        self.getConfiguration = IPoolGetConfigurationContractFunction.factory(
            "getConfiguration",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getConfiguration",
        )
        self.getEModeCategoryData = (
            IPoolGetEModeCategoryDataContractFunction.factory(
                "getEModeCategoryData",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getEModeCategoryData",
            )
        )
        self.getReserveAddressById = (
            IPoolGetReserveAddressByIdContractFunction.factory(
                "getReserveAddressById",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReserveAddressById",
            )
        )
        self.getReserveData = IPoolGetReserveDataContractFunction.factory(
            "getReserveData",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getReserveData",
        )
        self.getReserveNormalizedIncome = (
            IPoolGetReserveNormalizedIncomeContractFunction.factory(
                "getReserveNormalizedIncome",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReserveNormalizedIncome",
            )
        )
        self.getReserveNormalizedVariableDebt = (
            IPoolGetReserveNormalizedVariableDebtContractFunction.factory(
                "getReserveNormalizedVariableDebt",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReserveNormalizedVariableDebt",
            )
        )
        self.getReservesList = IPoolGetReservesListContractFunction.factory(
            "getReservesList",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getReservesList",
        )
        self.getUserAccountData = (
            IPoolGetUserAccountDataContractFunction.factory(
                "getUserAccountData",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getUserAccountData",
            )
        )
        self.getUserConfiguration = (
            IPoolGetUserConfigurationContractFunction.factory(
                "getUserConfiguration",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getUserConfiguration",
            )
        )
        self.getUserEMode = IPoolGetUserEModeContractFunction.factory(
            "getUserEMode",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getUserEMode",
        )
        self.initReserve = IPoolInitReserveContractFunction.factory(
            "initReserve",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="initReserve",
        )
        self.liquidationCall = IPoolLiquidationCallContractFunction.factory(
            "liquidationCall",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="liquidationCall",
        )
        self.mintToTreasury = IPoolMintToTreasuryContractFunction.factory(
            "mintToTreasury",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="mintToTreasury",
        )
        self.mintUnbacked = IPoolMintUnbackedContractFunction.factory(
            "mintUnbacked",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="mintUnbacked",
        )
        self.rebalanceStableBorrowRate = (
            IPoolRebalanceStableBorrowRateContractFunction.factory(
                "rebalanceStableBorrowRate",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="rebalanceStableBorrowRate",
            )
        )
        self.repay = IPoolRepayContractFunction.factory(
            "repay",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="repay",
        )
        self.repayWithATokens = IPoolRepayWithATokensContractFunction.factory(
            "repayWithATokens",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="repayWithATokens",
        )
        self.repayWithPermit = IPoolRepayWithPermitContractFunction.factory(
            "repayWithPermit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="repayWithPermit",
        )
        self.rescueTokens = IPoolRescueTokensContractFunction.factory(
            "rescueTokens",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="rescueTokens",
        )
        self.resetIsolationModeTotalDebt = (
            IPoolResetIsolationModeTotalDebtContractFunction.factory(
                "resetIsolationModeTotalDebt",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="resetIsolationModeTotalDebt",
            )
        )
        self.setConfiguration = IPoolSetConfigurationContractFunction.factory(
            "setConfiguration",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setConfiguration",
        )
        self.setReserveInterestRateStrategyAddress = (
            IPoolSetReserveInterestRateStrategyAddressContractFunction.factory(
                "setReserveInterestRateStrategyAddress",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setReserveInterestRateStrategyAddress",
            )
        )
        self.setUserEMode = IPoolSetUserEModeContractFunction.factory(
            "setUserEMode",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setUserEMode",
        )
        self.setUserUseReserveAsCollateral = (
            IPoolSetUserUseReserveAsCollateralContractFunction.factory(
                "setUserUseReserveAsCollateral",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setUserUseReserveAsCollateral",
            )
        )
        self.supply = IPoolSupplyContractFunction.factory(
            "supply",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="supply",
        )
        self.supplyWithPermit = IPoolSupplyWithPermitContractFunction.factory(
            "supplyWithPermit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="supplyWithPermit",
        )
        self.swapBorrowRateMode = (
            IPoolSwapBorrowRateModeContractFunction.factory(
                "swapBorrowRateMode",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="swapBorrowRateMode",
            )
        )
        self.updateBridgeProtocolFee = (
            IPoolUpdateBridgeProtocolFeeContractFunction.factory(
                "updateBridgeProtocolFee",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateBridgeProtocolFee",
            )
        )
        self.updateFlashloanPremiums = (
            IPoolUpdateFlashloanPremiumsContractFunction.factory(
                "updateFlashloanPremiums",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateFlashloanPremiums",
            )
        )
        self.withdraw = IPoolWithdrawContractFunction.factory(
            "withdraw",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="withdraw",
        )


class IPoolBackUnbackedContractEvent(ContractEvent):
    """ContractEvent for BackUnbacked."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[BackUnbackedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BackUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BackUnbackedEvent.BackUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    backer=abi_event.args["backer"],
                    amount=abi_event.args["amount"],
                    fee=abi_event.args["fee"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[BackUnbackedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BackUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BackUnbackedEvent.BackUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    backer=abi_event.args["backer"],
                    amount=abi_event.args["amount"],
                    fee=abi_event.args["fee"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolBorrowContractEvent(ContractEvent):
    """ContractEvent for Borrow."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[BorrowEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BorrowEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BorrowEvent.BorrowEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    borrowRate=abi_event.args["borrowRate"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[BorrowEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BorrowEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BorrowEvent.BorrowEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    borrowRate=abi_event.args["borrowRate"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolFlashLoanContractEvent(ContractEvent):
    """ContractEvent for FlashLoan."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[FlashLoanEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            FlashLoanEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=FlashLoanEvent.FlashLoanEventArgs(
                    target=abi_event.args["target"],
                    initiator=abi_event.args["initiator"],
                    asset=abi_event.args["asset"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    premium=abi_event.args["premium"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[FlashLoanEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            FlashLoanEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=FlashLoanEvent.FlashLoanEventArgs(
                    target=abi_event.args["target"],
                    initiator=abi_event.args["initiator"],
                    asset=abi_event.args["asset"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    premium=abi_event.args["premium"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolIsolationModeTotalDebtUpdatedContractEvent(ContractEvent):
    """ContractEvent for IsolationModeTotalDebtUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[IsolationModeTotalDebtUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            IsolationModeTotalDebtUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=IsolationModeTotalDebtUpdatedEvent.IsolationModeTotalDebtUpdatedEventArgs(
                    asset=abi_event.args["asset"],
                    totalDebt=abi_event.args["totalDebt"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[IsolationModeTotalDebtUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            IsolationModeTotalDebtUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=IsolationModeTotalDebtUpdatedEvent.IsolationModeTotalDebtUpdatedEventArgs(
                    asset=abi_event.args["asset"],
                    totalDebt=abi_event.args["totalDebt"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolLiquidationCallContractEvent(ContractEvent):
    """ContractEvent for LiquidationCall."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LiquidationCallEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LiquidationCallEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LiquidationCallEvent.LiquidationCallEventArgs(
                    collateralAsset=abi_event.args["collateralAsset"],
                    debtAsset=abi_event.args["debtAsset"],
                    user=abi_event.args["user"],
                    debtToCover=abi_event.args["debtToCover"],
                    liquidatedCollateralAmount=abi_event.args[
                        "liquidatedCollateralAmount"
                    ],
                    liquidator=abi_event.args["liquidator"],
                    receiveAToken=abi_event.args["receiveAToken"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LiquidationCallEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LiquidationCallEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LiquidationCallEvent.LiquidationCallEventArgs(
                    collateralAsset=abi_event.args["collateralAsset"],
                    debtAsset=abi_event.args["debtAsset"],
                    user=abi_event.args["user"],
                    debtToCover=abi_event.args["debtToCover"],
                    liquidatedCollateralAmount=abi_event.args[
                        "liquidatedCollateralAmount"
                    ],
                    liquidator=abi_event.args["liquidator"],
                    receiveAToken=abi_event.args["receiveAToken"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolMintUnbackedContractEvent(ContractEvent):
    """ContractEvent for MintUnbacked."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MintUnbackedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintUnbackedEvent.MintUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MintUnbackedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintUnbackedEvent.MintUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolMintedToTreasuryContractEvent(ContractEvent):
    """ContractEvent for MintedToTreasury."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MintedToTreasuryEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintedToTreasuryEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintedToTreasuryEvent.MintedToTreasuryEventArgs(
                    reserve=abi_event.args["reserve"],
                    amountMinted=abi_event.args["amountMinted"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MintedToTreasuryEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintedToTreasuryEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintedToTreasuryEvent.MintedToTreasuryEventArgs(
                    reserve=abi_event.args["reserve"],
                    amountMinted=abi_event.args["amountMinted"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolRebalanceStableBorrowRateContractEvent(ContractEvent):
    """ContractEvent for RebalanceStableBorrowRate."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[RebalanceStableBorrowRateEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RebalanceStableBorrowRateEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RebalanceStableBorrowRateEvent.RebalanceStableBorrowRateEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[RebalanceStableBorrowRateEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RebalanceStableBorrowRateEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RebalanceStableBorrowRateEvent.RebalanceStableBorrowRateEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolRepayContractEvent(ContractEvent):
    """ContractEvent for Repay."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[RepayEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RepayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RepayEvent.RepayEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    repayer=abi_event.args["repayer"],
                    amount=abi_event.args["amount"],
                    useATokens=abi_event.args["useATokens"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[RepayEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RepayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RepayEvent.RepayEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    repayer=abi_event.args["repayer"],
                    amount=abi_event.args["amount"],
                    useATokens=abi_event.args["useATokens"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolReserveDataUpdatedContractEvent(ContractEvent):
    """ContractEvent for ReserveDataUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ReserveDataUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveDataUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveDataUpdatedEvent.ReserveDataUpdatedEventArgs(
                    reserve=abi_event.args["reserve"],
                    liquidityRate=abi_event.args["liquidityRate"],
                    stableBorrowRate=abi_event.args["stableBorrowRate"],
                    variableBorrowRate=abi_event.args["variableBorrowRate"],
                    liquidityIndex=abi_event.args["liquidityIndex"],
                    variableBorrowIndex=abi_event.args["variableBorrowIndex"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ReserveDataUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveDataUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveDataUpdatedEvent.ReserveDataUpdatedEventArgs(
                    reserve=abi_event.args["reserve"],
                    liquidityRate=abi_event.args["liquidityRate"],
                    stableBorrowRate=abi_event.args["stableBorrowRate"],
                    variableBorrowRate=abi_event.args["variableBorrowRate"],
                    liquidityIndex=abi_event.args["liquidityIndex"],
                    variableBorrowIndex=abi_event.args["variableBorrowIndex"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolReserveUsedAsCollateralDisabledContractEvent(ContractEvent):
    """ContractEvent for ReserveUsedAsCollateralDisabled."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ReserveUsedAsCollateralDisabledEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralDisabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralDisabledEvent.ReserveUsedAsCollateralDisabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ReserveUsedAsCollateralDisabledEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralDisabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralDisabledEvent.ReserveUsedAsCollateralDisabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolReserveUsedAsCollateralEnabledContractEvent(ContractEvent):
    """ContractEvent for ReserveUsedAsCollateralEnabled."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ReserveUsedAsCollateralEnabledEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralEnabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralEnabledEvent.ReserveUsedAsCollateralEnabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ReserveUsedAsCollateralEnabledEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralEnabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralEnabledEvent.ReserveUsedAsCollateralEnabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolSupplyContractEvent(ContractEvent):
    """ContractEvent for Supply."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[SupplyEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SupplyEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SupplyEvent.SupplyEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[SupplyEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SupplyEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SupplyEvent.SupplyEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolSwapBorrowRateModeContractEvent(ContractEvent):
    """ContractEvent for SwapBorrowRateMode."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[SwapBorrowRateModeEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SwapBorrowRateModeEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SwapBorrowRateModeEvent.SwapBorrowRateModeEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    interestRateMode=abi_event.args["interestRateMode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[SwapBorrowRateModeEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SwapBorrowRateModeEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SwapBorrowRateModeEvent.SwapBorrowRateModeEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    interestRateMode=abi_event.args["interestRateMode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolUserEModeSetContractEvent(ContractEvent):
    """ContractEvent for UserEModeSet."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[UserEModeSetEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserEModeSetEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserEModeSetEvent.UserEModeSetEventArgs(
                    user=abi_event.args["user"],
                    categoryId=abi_event.args["categoryId"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[UserEModeSetEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserEModeSetEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserEModeSetEvent.UserEModeSetEventArgs(
                    user=abi_event.args["user"],
                    categoryId=abi_event.args["categoryId"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolWithdrawContractEvent(ContractEvent):
    """ContractEvent for Withdraw."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[WithdrawEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            WithdrawEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=WithdrawEvent.WithdrawEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    to=abi_event.args["to"],
                    amount=abi_event.args["amount"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[WithdrawEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            WithdrawEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=WithdrawEvent.WithdrawEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    to=abi_event.args["to"],
                    amount=abi_event.args["amount"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolContractEvents(ContractEvents):
    """ContractEvents for the IPool contract."""

    BackUnbacked: Type[IPoolBackUnbackedContractEvent]

    Borrow: Type[IPoolBorrowContractEvent]

    FlashLoan: Type[IPoolFlashLoanContractEvent]

    IsolationModeTotalDebtUpdated: Type[
        IPoolIsolationModeTotalDebtUpdatedContractEvent
    ]

    LiquidationCall: Type[IPoolLiquidationCallContractEvent]

    MintUnbacked: Type[IPoolMintUnbackedContractEvent]

    MintedToTreasury: Type[IPoolMintedToTreasuryContractEvent]

    RebalanceStableBorrowRate: Type[IPoolRebalanceStableBorrowRateContractEvent]

    Repay: Type[IPoolRepayContractEvent]

    ReserveDataUpdated: Type[IPoolReserveDataUpdatedContractEvent]

    ReserveUsedAsCollateralDisabled: Type[
        IPoolReserveUsedAsCollateralDisabledContractEvent
    ]

    ReserveUsedAsCollateralEnabled: Type[
        IPoolReserveUsedAsCollateralEnabledContractEvent
    ]

    Supply: Type[IPoolSupplyContractEvent]

    SwapBorrowRateMode: Type[IPoolSwapBorrowRateModeContractEvent]

    UserEModeSet: Type[IPoolUserEModeSetContractEvent]

    Withdraw: Type[IPoolWithdrawContractEvent]

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.BackUnbacked = cast(
            Type[IPoolBackUnbackedContractEvent],
            IPoolBackUnbackedContractEvent.factory(
                "BackUnbacked",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="BackUnbacked",
            ),
        )
        self.Borrow = cast(
            Type[IPoolBorrowContractEvent],
            IPoolBorrowContractEvent.factory(
                "Borrow",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Borrow",
            ),
        )
        self.FlashLoan = cast(
            Type[IPoolFlashLoanContractEvent],
            IPoolFlashLoanContractEvent.factory(
                "FlashLoan",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="FlashLoan",
            ),
        )
        self.IsolationModeTotalDebtUpdated = cast(
            Type[IPoolIsolationModeTotalDebtUpdatedContractEvent],
            IPoolIsolationModeTotalDebtUpdatedContractEvent.factory(
                "IsolationModeTotalDebtUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="IsolationModeTotalDebtUpdated",
            ),
        )
        self.LiquidationCall = cast(
            Type[IPoolLiquidationCallContractEvent],
            IPoolLiquidationCallContractEvent.factory(
                "LiquidationCall",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="LiquidationCall",
            ),
        )
        self.MintUnbacked = cast(
            Type[IPoolMintUnbackedContractEvent],
            IPoolMintUnbackedContractEvent.factory(
                "MintUnbacked",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MintUnbacked",
            ),
        )
        self.MintedToTreasury = cast(
            Type[IPoolMintedToTreasuryContractEvent],
            IPoolMintedToTreasuryContractEvent.factory(
                "MintedToTreasury",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="MintedToTreasury",
            ),
        )
        self.RebalanceStableBorrowRate = cast(
            Type[IPoolRebalanceStableBorrowRateContractEvent],
            IPoolRebalanceStableBorrowRateContractEvent.factory(
                "RebalanceStableBorrowRate",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="RebalanceStableBorrowRate",
            ),
        )
        self.Repay = cast(
            Type[IPoolRepayContractEvent],
            IPoolRepayContractEvent.factory(
                "Repay",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Repay",
            ),
        )
        self.ReserveDataUpdated = cast(
            Type[IPoolReserveDataUpdatedContractEvent],
            IPoolReserveDataUpdatedContractEvent.factory(
                "ReserveDataUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="ReserveDataUpdated",
            ),
        )
        self.ReserveUsedAsCollateralDisabled = cast(
            Type[IPoolReserveUsedAsCollateralDisabledContractEvent],
            IPoolReserveUsedAsCollateralDisabledContractEvent.factory(
                "ReserveUsedAsCollateralDisabled",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="ReserveUsedAsCollateralDisabled",
            ),
        )
        self.ReserveUsedAsCollateralEnabled = cast(
            Type[IPoolReserveUsedAsCollateralEnabledContractEvent],
            IPoolReserveUsedAsCollateralEnabledContractEvent.factory(
                "ReserveUsedAsCollateralEnabled",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="ReserveUsedAsCollateralEnabled",
            ),
        )
        self.Supply = cast(
            Type[IPoolSupplyContractEvent],
            IPoolSupplyContractEvent.factory(
                "Supply",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Supply",
            ),
        )
        self.SwapBorrowRateMode = cast(
            Type[IPoolSwapBorrowRateModeContractEvent],
            IPoolSwapBorrowRateModeContractEvent.factory(
                "SwapBorrowRateMode",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="SwapBorrowRateMode",
            ),
        )
        self.UserEModeSet = cast(
            Type[IPoolUserEModeSetContractEvent],
            IPoolUserEModeSetContractEvent.factory(
                "UserEModeSet",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="UserEModeSet",
            ),
        )
        self.Withdraw = cast(
            Type[IPoolWithdrawContractEvent],
            IPoolWithdrawContractEvent.factory(
                "Withdraw",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="Withdraw",
            ),
        )


ipool_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "ADDRESSES_PROVIDER",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract IPoolAddressesProvider",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "BRIDGE_PROTOCOL_FEE",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "FLASHLOAN_PREMIUM_TOTAL",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint128", "internalType": "uint128"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "FLASHLOAN_PREMIUM_TO_PROTOCOL",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint128", "internalType": "uint128"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "MAX_NUMBER_RESERVES",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint16", "internalType": "uint16"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "MAX_STABLE_RATE_BORROW_SIZE_PERCENT",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "backUnbacked",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "fee", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "borrow",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "configureEModeCategory",
            "inputs": [
                {"name": "id", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "config",
                    "type": "tuple",
                    "internalType": "struct DataTypes.EModeCategory",
                    "components": [
                        {
                            "name": "ltv",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationThreshold",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationBonus",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "priceSource",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "label",
                            "type": "string",
                            "internalType": "string",
                        },
                    ],
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "deposit",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "dropReserve",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "finalizeTransfer",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {"name": "from", "type": "address", "internalType": "address"},
                {"name": "to", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "balanceFromBefore",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "balanceToBefore",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "flashLoan",
            "inputs": [
                {
                    "name": "receiverAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "assets",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {
                    "name": "amounts",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "interestRateModes",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "params", "type": "bytes", "internalType": "bytes"},
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "flashLoanSimple",
            "inputs": [
                {
                    "name": "receiverAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "params", "type": "bytes", "internalType": "bytes"},
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getConfiguration",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.ReserveConfigurationMap",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        }
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getEModeCategoryData",
            "inputs": [
                {"name": "id", "type": "uint8", "internalType": "uint8"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.EModeCategory",
                    "components": [
                        {
                            "name": "ltv",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationThreshold",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationBonus",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "priceSource",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "label",
                            "type": "string",
                            "internalType": "string",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveAddressById",
            "inputs": [
                {"name": "id", "type": "uint16", "internalType": "uint16"}
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveData",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.ReserveData",
                    "components": [
                        {
                            "name": "configuration",
                            "type": "tuple",
                            "internalType": "struct DataTypes.ReserveConfigurationMap",
                            "components": [
                                {
                                    "name": "data",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                }
                            ],
                        },
                        {
                            "name": "liquidityIndex",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentLiquidityRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "variableBorrowIndex",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentVariableBorrowRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentStableBorrowRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "lastUpdateTimestamp",
                            "type": "uint40",
                            "internalType": "uint40",
                        },
                        {
                            "name": "id",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "aTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "stableDebtTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "variableDebtTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "interestRateStrategyAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "accruedToTreasury",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "unbacked",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "isolationModeTotalDebt",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveNormalizedIncome",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveNormalizedVariableDebt",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReservesList",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address[]", "internalType": "address[]"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getUserAccountData",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "totalCollateralBase",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "totalDebtBase",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "availableBorrowsBase",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "currentLiquidationThreshold",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "ltv", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "healthFactor",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getUserConfiguration",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.UserConfigurationMap",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        }
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getUserEMode",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "initReserve",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "aTokenAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "stableDebtAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "variableDebtAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "interestRateStrategyAddress",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "liquidationCall",
            "inputs": [
                {
                    "name": "collateralAsset",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "debtAsset",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "user", "type": "address", "internalType": "address"},
                {
                    "name": "debtToCover",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "receiveAToken",
                    "type": "bool",
                    "internalType": "bool",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mintToTreasury",
            "inputs": [
                {
                    "name": "assets",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mintUnbacked",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rebalanceStableBorrowRate",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {"name": "user", "type": "address", "internalType": "address"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repay",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repayWithATokens",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repayWithPermit",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "deadline",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "permitV", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "permitR",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
                {
                    "name": "permitS",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rescueTokens",
            "inputs": [
                {"name": "token", "type": "address", "internalType": "address"},
                {"name": "to", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "resetIsolationModeTotalDebt",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setConfiguration",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "configuration",
                    "type": "tuple",
                    "internalType": "struct DataTypes.ReserveConfigurationMap",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        }
                    ],
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setReserveInterestRateStrategyAddress",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "rateStrategyAddress",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUserEMode",
            "inputs": [
                {"name": "categoryId", "type": "uint8", "internalType": "uint8"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUserUseReserveAsCollateral",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "useAsCollateral",
                    "type": "bool",
                    "internalType": "bool",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "supply",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "supplyWithPermit",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
                {
                    "name": "deadline",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "permitV", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "permitR",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
                {
                    "name": "permitS",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "swapBorrowRateMode",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateBridgeProtocolFee",
            "inputs": [
                {
                    "name": "bridgeProtocolFee",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateFlashloanPremiums",
            "inputs": [
                {
                    "name": "flashLoanPremiumTotal",
                    "type": "uint128",
                    "internalType": "uint128",
                },
                {
                    "name": "flashLoanPremiumToProtocol",
                    "type": "uint128",
                    "internalType": "uint128",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "withdraw",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "to", "type": "address", "internalType": "address"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "event",
            "name": "BackUnbacked",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "backer",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "fee",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Borrow",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "enum DataTypes.InterestRateMode",
                },
                {
                    "name": "borrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "FlashLoan",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "initiator",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "asset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "enum DataTypes.InterestRateMode",
                },
                {
                    "name": "premium",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "IsolationModeTotalDebtUpdated",
            "inputs": [
                {
                    "name": "asset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "totalDebt",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "LiquidationCall",
            "inputs": [
                {
                    "name": "collateralAsset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "debtAsset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "debtToCover",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "liquidatedCollateralAmount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "liquidator",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "receiveAToken",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MintUnbacked",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MintedToTreasury",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amountMinted",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "RebalanceStableBorrowRate",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Repay",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "repayer",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "useATokens",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ReserveDataUpdated",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "liquidityRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "stableBorrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "variableBorrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "liquidityIndex",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "variableBorrowIndex",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ReserveUsedAsCollateralDisabled",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ReserveUsedAsCollateralEnabled",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Supply",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "SwapBorrowRateMode",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "enum DataTypes.InterestRateMode",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "UserEModeSet",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "categoryId",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "uint8",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Withdraw",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "to",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
    ],
)


class IPoolContract(Contract):
    """A web3.py Contract class for the IPool contract."""

    abi: ABI = ipool_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr("0x")

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = IPoolContractFunctions(ipool_abi, self.w3, address)  # type: ignore
        self.events = IPoolContractEvents(ipool_abi, self.w3, address)  # type: ignore

    events: IPoolContractEvents

    functions: IPoolContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = IPoolContractFunctions(ipool_abi, w3, None)

        return contract

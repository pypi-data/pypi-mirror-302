import{C as q}from"./codemirror.es-Bh644rv_.js";import{d as S,i as ue,a as V,n as ce,b as A,s as _,t as h,c as w,e as G,f as Oe,h as Se,j as I,k as F,l as E,m as C,o as ne,p as fe,q as k,r as we,v as _e,G as Re,u as $e,w as Fe,x as Q,y as Ve,z as Ae,A as te,T as de,B as pe,C as Ce,D as ke,E as Le}from"./GraphiQL-BAPdO7-j.js";import{R as me,P as L}from"./Range-CZNrBk8u.js";import{f9 as Ue,cH as f,cJ as p,cP as T,cR as D,cN as v,cQ as y,cS as Y,fa as ge,fb as je,fc as Me,fd as Pe,cX as ve,cI as Ge,fe as qe,cW as Ye}from"./index-CQRaJAEP.js";import"./codemirror.es2-CXusOVRv.js";function ye(n){return{Document(t){for(const e of t.definitions)if(!Ue(e)){const r=e.kind===f.SCHEMA_DEFINITION||e.kind===f.SCHEMA_EXTENSION?"schema":'"'+e.name.value+'"';n.reportError(new p(`The ${r} definition is not executable.`,{nodes:e}))}return!1}}}function Be(n){return{Field(t){const e=n.getParentType();if(e&&!n.getFieldDef()){const s=n.getSchema(),i=t.name.value;let o=S("to use an inline fragment on",Qe(s,e,i));o===""&&(o=S(He(e,i))),n.reportError(new p(`Cannot query field "${i}" on type "${e.name}".`+o,{nodes:t}))}}}}function Qe(n,t,e){if(!ue(t))return[];const r=new Set,s=Object.create(null);for(const o of n.getPossibleTypes(t))if(o.getFields()[e]){r.add(o),s[o.name]=1;for(const a of o.getInterfaces()){var i;a.getFields()[e]&&(r.add(a),s[a.name]=((i=s[a.name])!==null&&i!==void 0?i:0)+1)}}return[...r].sort((o,a)=>{const l=s[a.name]-s[o.name];return l!==0?l:V(o)&&n.isSubType(o,a)?-1:V(a)&&n.isSubType(a,o)?1:ce(o.name,a.name)}).map(o=>o.name)}function He(n,t){if(A(n)||V(n)){const e=Object.keys(n.getFields());return _(t,e)}return[]}function We(n){return{InlineFragment(t){const e=t.typeCondition;if(e){const r=h(n.getSchema(),e);if(r&&!w(r)){const s=T(e);n.reportError(new p(`Fragment cannot condition on non composite type "${s}".`,{nodes:e}))}}},FragmentDefinition(t){const e=h(n.getSchema(),t.typeCondition);if(e&&!w(e)){const r=T(t.typeCondition);n.reportError(new p(`Fragment "${t.name.value}" cannot condition on non composite type "${r}".`,{nodes:t.typeCondition}))}}}}function Xe(n){return{...Je(n),Argument(t){const e=n.getArgument(),r=n.getFieldDef(),s=n.getParentType();if(!e&&r&&s){const i=t.name.value,o=r.args.map(l=>l.name),a=_(i,o);n.reportError(new p(`Unknown argument "${i}" on field "${s.name}.${r.name}".`+S(a),{nodes:t}))}}}}function Je(n){const t=Object.create(null),e=n.getSchema(),r=e?e.getDirectives():G;for(const o of r)t[o.name]=o.args.map(a=>a.name);const s=n.getDocument().definitions;for(const o of s)if(o.kind===f.DIRECTIVE_DEFINITION){var i;const a=(i=o.arguments)!==null&&i!==void 0?i:[];t[o.name.value]=a.map(l=>l.name.value)}return{Directive(o){const a=o.name.value,l=t[a];if(o.arguments&&l)for(const u of o.arguments){const c=u.name.value;if(!l.includes(c)){const d=_(c,l);n.reportError(new p(`Unknown argument "${c}" on directive "@${a}".`+S(d),{nodes:u}))}}return!1}}}function Ke(n){const t=Object.create(null),e=n.getSchema(),r=e?e.getDirectives():G;for(const i of r)t[i.name]=i.locations;const s=n.getDocument().definitions;for(const i of s)i.kind===f.DIRECTIVE_DEFINITION&&(t[i.name.value]=i.locations.map(o=>o.value));return{Directive(i,o,a,l,u){const c=i.name.value,d=t[c];if(!d){n.reportError(new p(`Unknown directive "@${c}".`,{nodes:i}));return}const m=ze(u);m&&!d.includes(m)&&n.reportError(new p(`Directive "@${c}" may not be used on ${m}.`,{nodes:i}))}}}function ze(n){const t=n[n.length-1];switch("kind"in t||D(!1),t.kind){case f.OPERATION_DEFINITION:return Ze(t.operation);case f.FIELD:return y.FIELD;case f.FRAGMENT_SPREAD:return y.FRAGMENT_SPREAD;case f.INLINE_FRAGMENT:return y.INLINE_FRAGMENT;case f.FRAGMENT_DEFINITION:return y.FRAGMENT_DEFINITION;case f.VARIABLE_DEFINITION:return y.VARIABLE_DEFINITION;case f.SCHEMA_DEFINITION:case f.SCHEMA_EXTENSION:return y.SCHEMA;case f.SCALAR_TYPE_DEFINITION:case f.SCALAR_TYPE_EXTENSION:return y.SCALAR;case f.OBJECT_TYPE_DEFINITION:case f.OBJECT_TYPE_EXTENSION:return y.OBJECT;case f.FIELD_DEFINITION:return y.FIELD_DEFINITION;case f.INTERFACE_TYPE_DEFINITION:case f.INTERFACE_TYPE_EXTENSION:return y.INTERFACE;case f.UNION_TYPE_DEFINITION:case f.UNION_TYPE_EXTENSION:return y.UNION;case f.ENUM_TYPE_DEFINITION:case f.ENUM_TYPE_EXTENSION:return y.ENUM;case f.ENUM_VALUE_DEFINITION:return y.ENUM_VALUE;case f.INPUT_OBJECT_TYPE_DEFINITION:case f.INPUT_OBJECT_TYPE_EXTENSION:return y.INPUT_OBJECT;case f.INPUT_VALUE_DEFINITION:{const e=n[n.length-3];return"kind"in e||D(!1),e.kind===f.INPUT_OBJECT_TYPE_DEFINITION?y.INPUT_FIELD_DEFINITION:y.ARGUMENT_DEFINITION}default:D(!1,"Unexpected kind: "+v(t.kind))}}function Ze(n){switch(n){case Y.QUERY:return y.QUERY;case Y.MUTATION:return y.MUTATION;case Y.SUBSCRIPTION:return y.SUBSCRIPTION}}function xe(n){return{FragmentSpread(t){const e=t.name.value;n.getFragment(e)||n.reportError(new p(`Unknown fragment "${e}".`,{nodes:t.name}))}}}function en(n){const t=n.getSchema(),e=t?t.getTypeMap():Object.create(null),r=Object.create(null);for(const i of n.getDocument().definitions)ge(i)&&(r[i.name.value]=!0);const s=[...Object.keys(e),...Object.keys(r)];return{NamedType(i,o,a,l,u){const c=i.name.value;if(!e[c]&&!r[c]){var d;const m=(d=u[2])!==null&&d!==void 0?d:a,g=m!=null&&nn(m);if(g&&re.includes(c))return;const N=_(c,g?re.concat(s):s);n.reportError(new p(`Unknown type "${c}".`+S(N),{nodes:i}))}}}}const re=[...Oe,...Se].map(n=>n.name);function nn(n){return"kind"in n&&(je(n)||Me(n))}function tn(n){let t=0;return{Document(e){t=e.definitions.filter(r=>r.kind===f.OPERATION_DEFINITION).length},OperationDefinition(e){!e.name&&t>1&&n.reportError(new p("This anonymous operation must be the only defined operation.",{nodes:e}))}}}const rn=3;function sn(n){function t(e,r=Object.create(null),s=0){if(e.kind===f.FRAGMENT_SPREAD){const i=e.name.value;if(r[i]===!0)return!1;const o=n.getFragment(i);if(!o)return!1;try{return r[i]=!0,t(o,r,s)}finally{r[i]=void 0}}if(e.kind===f.FIELD&&(e.name.value==="fields"||e.name.value==="interfaces"||e.name.value==="possibleTypes"||e.name.value==="inputFields")&&(s++,s>=rn))return!0;if("selectionSet"in e&&e.selectionSet){for(const i of e.selectionSet.selections)if(t(i,r,s))return!0}return!1}return{Field(e){if((e.name.value==="__schema"||e.name.value==="__type")&&t(e))return n.reportError(new p("Maximum introspection depth exceeded",{nodes:[e]})),!1}}}function an(n){const t=Object.create(null),e=[],r=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(i){return s(i),!1}};function s(i){if(t[i.name.value])return;const o=i.name.value;t[o]=!0;const a=n.getFragmentSpreads(i.selectionSet);if(a.length!==0){r[o]=e.length;for(const l of a){const u=l.name.value,c=r[u];if(e.push(l),c===void 0){const d=n.getFragment(u);d&&s(d)}else{const d=e.slice(c),m=d.slice(0,-1).map(g=>'"'+g.name.value+'"').join(", ");n.reportError(new p(`Cannot spread fragment "${u}" within itself`+(m!==""?` via ${m}.`:"."),{nodes:d}))}e.pop()}r[o]=void 0}}}function on(n){let t=Object.create(null);return{OperationDefinition:{enter(){t=Object.create(null)},leave(e){const r=n.getRecursiveVariableUsages(e);for(const{node:s}of r){const i=s.name.value;t[i]!==!0&&n.reportError(new p(e.name?`Variable "$${i}" is not defined by operation "${e.name.value}".`:`Variable "$${i}" is not defined.`,{nodes:[s,e]}))}}},VariableDefinition(e){t[e.variable.name.value]=!0}}}function Ne(n){const t=[],e=[];return{OperationDefinition(r){return t.push(r),!1},FragmentDefinition(r){return e.push(r),!1},Document:{leave(){const r=Object.create(null);for(const s of t)for(const i of n.getRecursivelyReferencedFragments(s))r[i.name.value]=!0;for(const s of e){const i=s.name.value;r[i]!==!0&&n.reportError(new p(`Fragment "${i}" is never used.`,{nodes:s}))}}}}}function ln(n){let t=[];return{OperationDefinition:{enter(){t=[]},leave(e){const r=Object.create(null),s=n.getRecursiveVariableUsages(e);for(const{node:i}of s)r[i.name.value]=!0;for(const i of t){const o=i.variable.name.value;r[o]!==!0&&n.reportError(new p(e.name?`Variable "$${o}" is never used in operation "${e.name.value}".`:`Variable "$${o}" is never used.`,{nodes:i}))}}},VariableDefinition(e){t.push(e)}}}function K(n){switch(n.kind){case f.OBJECT:return{...n,fields:un(n.fields)};case f.LIST:return{...n,values:n.values.map(K)};case f.INT:case f.FLOAT:case f.STRING:case f.BOOLEAN:case f.NULL:case f.ENUM:case f.VARIABLE:return n}}function un(n){return n.map(t=>({...t,value:K(t.value)})).sort((t,e)=>ce(t.name.value,e.name.value))}function Te(n){return Array.isArray(n)?n.map(([t,e])=>`subfields "${t}" conflict because `+Te(e)).join(" and "):n}function cn(n){const t=new vn,e=new Map;return{SelectionSet(r){const s=fn(n,e,t,n.getParentType(),r);for(const[[i,o],a,l]of s){const u=Te(o);n.reportError(new p(`Fields "${i}" conflict because ${u}. Use different aliases on the fields to fetch both if this was intentional.`,{nodes:a.concat(l)}))}}}}function fn(n,t,e,r,s){const i=[],[o,a]=M(n,t,r,s);if(pn(n,i,t,e,o),a.length!==0)for(let l=0;l<a.length;l++){U(n,i,t,e,!1,o,a[l]);for(let u=l+1;u<a.length;u++)j(n,i,t,e,!1,a[l],a[u])}return i}function U(n,t,e,r,s,i,o){const a=n.getFragment(o);if(!a)return;const[l,u]=W(n,e,a);if(i!==l){z(n,t,e,r,s,i,l);for(const c of u)r.has(c,o,s)||(r.add(c,o,s),U(n,t,e,r,s,i,c))}}function j(n,t,e,r,s,i,o){if(i===o||r.has(i,o,s))return;r.add(i,o,s);const a=n.getFragment(i),l=n.getFragment(o);if(!a||!l)return;const[u,c]=W(n,e,a),[d,m]=W(n,e,l);z(n,t,e,r,s,u,d);for(const g of m)j(n,t,e,r,s,i,g);for(const g of c)j(n,t,e,r,s,g,o)}function dn(n,t,e,r,s,i,o,a){const l=[],[u,c]=M(n,t,s,i),[d,m]=M(n,t,o,a);z(n,l,t,e,r,u,d);for(const g of m)U(n,l,t,e,r,u,g);for(const g of c)U(n,l,t,e,r,d,g);for(const g of c)for(const N of m)j(n,l,t,e,r,g,N);return l}function pn(n,t,e,r,s){for(const[i,o]of Object.entries(s))if(o.length>1)for(let a=0;a<o.length;a++)for(let l=a+1;l<o.length;l++){const u=Ee(n,e,r,!1,i,o[a],o[l]);u&&t.push(u)}}function z(n,t,e,r,s,i,o){for(const[a,l]of Object.entries(i)){const u=o[a];if(u)for(const c of l)for(const d of u){const m=Ee(n,e,r,s,a,c,d);m&&t.push(m)}}}function Ee(n,t,e,r,s,i,o){const[a,l,u]=i,[c,d,m]=o,g=r||a!==c&&A(a)&&A(c);if(!g){const R=l.name.value,ee=d.name.value;if(R!==ee)return[[s,`"${R}" and "${ee}" are different fields`],[l],[d]];if(!mn(l,d))return[[s,"they have differing arguments"],[l],[d]]}const N=u==null?void 0:u.type,O=m==null?void 0:m.type;if(N&&O&&H(N,O))return[[s,`they return conflicting types "${v(N)}" and "${v(O)}"`],[l],[d]];const Z=l.selectionSet,x=d.selectionSet;if(Z&&x){const R=dn(n,t,e,g,I(N),Z,I(O),x);return gn(R,s,l,d)}}function mn(n,t){const e=n.arguments,r=t.arguments;if(e===void 0||e.length===0)return r===void 0||r.length===0;if(r===void 0||r.length===0||e.length!==r.length)return!1;const s=new Map(r.map(({name:i,value:o})=>[i.value,o]));return e.every(i=>{const o=i.value,a=s.get(i.name.value);return a===void 0?!1:ie(o)===ie(a)})}function ie(n){return T(K(n))}function H(n,t){return F(n)?F(t)?H(n.ofType,t.ofType):!0:F(t)?!0:E(n)?E(t)?H(n.ofType,t.ofType):!0:E(t)?!0:C(n)||C(t)?n!==t:!1}function M(n,t,e,r){const s=t.get(r);if(s)return s;const i=Object.create(null),o=Object.create(null);he(n,e,r,i,o);const a=[i,Object.keys(o)];return t.set(r,a),a}function W(n,t,e){const r=t.get(e.selectionSet);if(r)return r;const s=h(n.getSchema(),e.typeCondition);return M(n,t,s,e.selectionSet)}function he(n,t,e,r,s){for(const i of e.selections)switch(i.kind){case f.FIELD:{const o=i.name.value;let a;(A(t)||V(t))&&(a=t.getFields()[o]);const l=i.alias?i.alias.value:o;r[l]||(r[l]=[]),r[l].push([t,i,a]);break}case f.FRAGMENT_SPREAD:s[i.name.value]=!0;break;case f.INLINE_FRAGMENT:{const o=i.typeCondition,a=o?h(n.getSchema(),o):t;he(n,a,i.selectionSet,r,s);break}}}function gn(n,t,e,r){if(n.length>0)return[[t,n.map(([s])=>s)],[e,...n.map(([,s])=>s).flat()],[r,...n.map(([,,s])=>s).flat()]]}class vn{constructor(){this._data=new Map}has(t,e,r){var s;const[i,o]=t<e?[t,e]:[e,t],a=(s=this._data.get(i))===null||s===void 0?void 0:s.get(o);return a===void 0?!1:r?!0:r===a}add(t,e,r){const[s,i]=t<e?[t,e]:[e,t],o=this._data.get(s);o===void 0?this._data.set(s,new Map([[i,r]])):o.set(i,r)}}function yn(n){return{InlineFragment(t){const e=n.getType(),r=n.getParentType();if(w(e)&&w(r)&&!ne(n.getSchema(),e,r)){const s=v(r),i=v(e);n.reportError(new p(`Fragment cannot be spread here as objects of type "${s}" can never be of type "${i}".`,{nodes:t}))}},FragmentSpread(t){const e=t.name.value,r=Nn(n,e),s=n.getParentType();if(r&&s&&!ne(n.getSchema(),r,s)){const i=v(s),o=v(r);n.reportError(new p(`Fragment "${e}" cannot be spread here as objects of type "${i}" can never be of type "${o}".`,{nodes:t}))}}}}function Nn(n,t){const e=n.getFragment(t);if(e){const r=h(n.getSchema(),e.typeCondition);if(w(r))return r}}function Tn(n){return{...En(n),Field:{leave(t){var e;const r=n.getFieldDef();if(!r)return!1;const s=new Set((e=t.arguments)===null||e===void 0?void 0:e.map(i=>i.name.value));for(const i of r.args)if(!s.has(i.name)&&fe(i)){const o=v(i.type);n.reportError(new p(`Field "${r.name}" argument "${i.name}" of type "${o}" is required, but it was not provided.`,{nodes:t}))}}}}}function En(n){var t;const e=Object.create(null),r=n.getSchema(),s=(t=r==null?void 0:r.getDirectives())!==null&&t!==void 0?t:G;for(const a of s)e[a.name]=k(a.args.filter(fe),l=>l.name);const i=n.getDocument().definitions;for(const a of i)if(a.kind===f.DIRECTIVE_DEFINITION){var o;const l=(o=a.arguments)!==null&&o!==void 0?o:[];e[a.name.value]=k(l.filter(hn),u=>u.name.value)}return{Directive:{leave(a){const l=a.name.value,u=e[l];if(u){var c;const d=(c=a.arguments)!==null&&c!==void 0?c:[],m=new Set(d.map(g=>g.name.value));for(const[g,N]of Object.entries(u))if(!m.has(g)){const O=we(N.type)?v(N.type):T(N.type);n.reportError(new p(`Directive "@${l}" argument "${g}" of type "${O}" is required, but it was not provided.`,{nodes:a}))}}}}}}function hn(n){return n.type.kind===f.NON_NULL_TYPE&&n.defaultValue==null}function In(n){return{Field(t){const e=n.getType(),r=t.selectionSet;if(e){if(C(I(e))){if(r){const s=t.name.value,i=v(e);n.reportError(new p(`Field "${s}" must not have a selection since type "${i}" has no subfields.`,{nodes:r}))}}else if(!r){const s=t.name.value,i=v(e);n.reportError(new p(`Field "${s}" of type "${i}" must have a selection of subfields. Did you mean "${s} { ... }"?`,{nodes:t}))}}}}}function bn(n,t,e){var r;const s={},i=(r=t.arguments)!==null&&r!==void 0?r:[],o=k(i,a=>a.name.value);for(const a of n.args){const l=a.name,u=a.type,c=o[l];if(!c){if(a.defaultValue!==void 0)s[l]=a.defaultValue;else if(E(u))throw new p(`Argument "${l}" of required type "${v(u)}" was not provided.`,{nodes:t});continue}const d=c.value;let m=d.kind===f.NULL;if(d.kind===f.VARIABLE){const N=d.name.value;if(e==null||!Dn(e,N)){if(a.defaultValue!==void 0)s[l]=a.defaultValue;else if(E(u))throw new p(`Argument "${l}" of required type "${v(u)}" was provided the variable "$${N}" which was not provided a runtime value.`,{nodes:d});continue}m=e[N]==null}if(m&&E(u))throw new p(`Argument "${l}" of non-null type "${v(u)}" must not be null.`,{nodes:d});const g=_e(d,u,e);if(g===void 0)throw new p(`Argument "${l}" has invalid value ${T(d)}.`,{nodes:d});s[l]=g}return s}function se(n,t,e){var r;const s=(r=t.directives)===null||r===void 0?void 0:r.find(i=>i.name.value===n.name);if(s)return bn(n,s,e)}function Dn(n,t){return Object.prototype.hasOwnProperty.call(n,t)}function On(n,t,e,r,s){const i=new Map;return X(n,t,e,r,s,i,new Set),i}function X(n,t,e,r,s,i,o){for(const a of s.selections)switch(a.kind){case f.FIELD:{if(!B(e,a))continue;const l=Sn(a),u=i.get(l);u!==void 0?u.push(a):i.set(l,[a]);break}case f.INLINE_FRAGMENT:{if(!B(e,a)||!ae(n,a,r))continue;X(n,t,e,r,a.selectionSet,i,o);break}case f.FRAGMENT_SPREAD:{const l=a.name.value;if(o.has(l)||!B(e,a))continue;o.add(l);const u=t[l];if(!u||!ae(n,u,r))continue;X(n,t,e,r,u.selectionSet,i,o);break}}}function B(n,t){const e=se(Re,t,n);if((e==null?void 0:e.if)===!0)return!1;const r=se($e,t,n);return(r==null?void 0:r.if)!==!1}function ae(n,t,e){const r=t.typeCondition;if(!r)return!0;const s=h(n,r);return s===e?!0:ue(s)?n.isSubType(s,e):!1}function Sn(n){return n.alias?n.alias.value:n.name.value}function wn(n){return{OperationDefinition(t){if(t.operation==="subscription"){const e=n.getSchema(),r=e.getSubscriptionType();if(r){const s=t.name?t.name.value:null,i=Object.create(null),o=n.getDocument(),a=Object.create(null);for(const u of o.definitions)u.kind===f.FRAGMENT_DEFINITION&&(a[u.name.value]=u);const l=On(e,a,i,r,t.selectionSet);if(l.size>1){const d=[...l.values()].slice(1).flat();n.reportError(new p(s!=null?`Subscription "${s}" must select only one top level field.`:"Anonymous Subscription must select only one top level field.",{nodes:d}))}for(const u of l.values())u[0].name.value.startsWith("__")&&n.reportError(new p(s!=null?`Subscription "${s}" must not select an introspection top level field.`:"Anonymous Subscription must not select an introspection top level field.",{nodes:u}))}}}}}function Ie(n,t){const e=new Map;for(const r of n){const s=t(r),i=e.get(s);i===void 0?e.set(s,[r]):i.push(r)}return e}function _n(n){return{Field:t,Directive:t};function t(e){var r;const s=(r=e.arguments)!==null&&r!==void 0?r:[],i=Ie(s,o=>o.name.value);for(const[o,a]of i)a.length>1&&n.reportError(new p(`There can be only one argument named "${o}".`,{nodes:a.map(l=>l.name)}))}}function Rn(n){const t=Object.create(null),e=n.getSchema(),r=e?e.getDirectives():G;for(const a of r)t[a.name]=!a.isRepeatable;const s=n.getDocument().definitions;for(const a of s)a.kind===f.DIRECTIVE_DEFINITION&&(t[a.name.value]=!a.repeatable);const i=Object.create(null),o=Object.create(null);return{enter(a){if(!("directives"in a)||!a.directives)return;let l;if(a.kind===f.SCHEMA_DEFINITION||a.kind===f.SCHEMA_EXTENSION)l=i;else if(ge(a)||Pe(a)){const u=a.name.value;l=o[u],l===void 0&&(o[u]=l=Object.create(null))}else l=Object.create(null);for(const u of a.directives){const c=u.name.value;t[c]&&(l[c]?n.reportError(new p(`The directive "@${c}" can only be used once at this location.`,{nodes:[l[c],u]})):l[c]=u)}}}}function $n(n){const t=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(e){const r=e.name.value;return t[r]?n.reportError(new p(`There can be only one fragment named "${r}".`,{nodes:[t[r],e.name]})):t[r]=e.name,!1}}}function Fn(n){const t=[];let e=Object.create(null);return{ObjectValue:{enter(){t.push(e),e=Object.create(null)},leave(){const r=t.pop();r||D(!1),e=r}},ObjectField(r){const s=r.name.value;e[s]?n.reportError(new p(`There can be only one input field named "${s}".`,{nodes:[e[s],r.name]})):e[s]=r.name}}}function Vn(n){const t=Object.create(null);return{OperationDefinition(e){const r=e.name;return r&&(t[r.value]?n.reportError(new p(`There can be only one operation named "${r.value}".`,{nodes:[t[r.value],r]})):t[r.value]=r),!1},FragmentDefinition:()=>!1}}function An(n){return{OperationDefinition(t){var e;const r=(e=t.variableDefinitions)!==null&&e!==void 0?e:[],s=Ie(r,i=>i.variable.name.value);for(const[i,o]of s)o.length>1&&n.reportError(new p(`There can be only one variable named "$${i}".`,{nodes:o.map(a=>a.variable.name)}))}}}function Cn(n){let t={};return{OperationDefinition:{enter(){t={}}},VariableDefinition(e){t[e.variable.name.value]=e},ListValue(e){const r=Fe(n.getParentInputType());if(!F(r))return b(n,e),!1},ObjectValue(e){const r=I(n.getInputType());if(!Q(r))return b(n,e),!1;const s=k(e.fields,i=>i.name.value);for(const i of Object.values(r.getFields()))if(!s[i.name]&&Ve(i)){const a=v(i.type);n.reportError(new p(`Field "${r.name}.${i.name}" of required type "${a}" was not provided.`,{nodes:e}))}r.isOneOf&&kn(n,e,r,s,t)},ObjectField(e){const r=I(n.getParentInputType());if(!n.getInputType()&&Q(r)){const i=_(e.name.value,Object.keys(r.getFields()));n.reportError(new p(`Field "${e.name.value}" is not defined by type "${r.name}".`+S(i),{nodes:e}))}},NullValue(e){const r=n.getInputType();E(r)&&n.reportError(new p(`Expected value of type "${v(r)}", found ${T(e)}.`,{nodes:e}))},EnumValue:e=>b(n,e),IntValue:e=>b(n,e),FloatValue:e=>b(n,e),StringValue:e=>b(n,e),BooleanValue:e=>b(n,e)}}function b(n,t){const e=n.getInputType();if(!e)return;const r=I(e);if(!C(r)){const s=v(e);n.reportError(new p(`Expected value of type "${s}", found ${T(t)}.`,{nodes:t}));return}try{if(r.parseLiteral(t,void 0)===void 0){const i=v(e);n.reportError(new p(`Expected value of type "${i}", found ${T(t)}.`,{nodes:t}))}}catch(s){const i=v(e);s instanceof p?n.reportError(s):n.reportError(new p(`Expected value of type "${i}", found ${T(t)}; `+s.message,{nodes:t,originalError:s}))}}function kn(n,t,e,r,s){var i;const o=Object.keys(r);if(o.length!==1){n.reportError(new p(`OneOf Input Object "${e.name}" must specify exactly one key.`,{nodes:[t]}));return}const l=(i=r[o[0]])===null||i===void 0?void 0:i.value,u=!l||l.kind===f.NULL,c=(l==null?void 0:l.kind)===f.VARIABLE;if(u){n.reportError(new p(`Field "${e.name}.${o[0]}" must be non-null.`,{nodes:[t]}));return}if(c){const d=l.name.value;s[d].type.kind!==f.NON_NULL_TYPE&&n.reportError(new p(`Variable "${d}" must be non-nullable to be used for OneOf Input Object "${e.name}".`,{nodes:[t]}))}}function Ln(n){return{VariableDefinition(t){const e=h(n.getSchema(),t.type);if(e!==void 0&&!Ae(e)){const r=t.variable.name.value,s=T(t.type);n.reportError(new p(`Variable "$${r}" cannot be non-input type "${s}".`,{nodes:t.type}))}}}}function Un(n){let t=Object.create(null);return{OperationDefinition:{enter(){t=Object.create(null)},leave(e){const r=n.getRecursiveVariableUsages(e);for(const{node:s,type:i,defaultValue:o}of r){const a=s.name.value,l=t[a];if(l&&i){const u=n.getSchema(),c=h(u,l.type);if(c&&!jn(u,c,l.defaultValue,i,o)){const d=v(c),m=v(i);n.reportError(new p(`Variable "$${a}" of type "${d}" used in position expecting type "${m}".`,{nodes:[l,s]}))}}}}},VariableDefinition(e){t[e.variable.name.value]=e}}}function jn(n,t,e,r,s){if(E(r)&&!E(t)){if(!(e!=null&&e.kind!==f.NULL)&&!(s!==void 0))return!1;const a=r.ofType;return te(n,t,a)}return te(n,t,r)}const Mn=Object.freeze([sn]),be=Object.freeze([ye,Vn,tn,wn,en,We,Ln,In,Be,$n,xe,Ne,yn,an,An,on,ln,Ke,Rn,Xe,_n,Cn,Tn,Un,cn,Fn,...Mn]);class Pn{constructor(t,e){this._ast=t,this._fragments=void 0,this._fragmentSpreads=new Map,this._recursivelyReferencedFragments=new Map,this._onError=e}get[Symbol.toStringTag](){return"ASTValidationContext"}reportError(t){this._onError(t)}getDocument(){return this._ast}getFragment(t){let e;if(this._fragments)e=this._fragments;else{e=Object.create(null);for(const r of this.getDocument().definitions)r.kind===f.FRAGMENT_DEFINITION&&(e[r.name.value]=r);this._fragments=e}return e[t]}getFragmentSpreads(t){let e=this._fragmentSpreads.get(t);if(!e){e=[];const r=[t];let s;for(;s=r.pop();)for(const i of s.selections)i.kind===f.FRAGMENT_SPREAD?e.push(i):i.selectionSet&&r.push(i.selectionSet);this._fragmentSpreads.set(t,e)}return e}getRecursivelyReferencedFragments(t){let e=this._recursivelyReferencedFragments.get(t);if(!e){e=[];const r=Object.create(null),s=[t.selectionSet];let i;for(;i=s.pop();)for(const o of this.getFragmentSpreads(i)){const a=o.name.value;if(r[a]!==!0){r[a]=!0;const l=this.getFragment(a);l&&(e.push(l),s.push(l.selectionSet))}}this._recursivelyReferencedFragments.set(t,e)}return e}}class Gn extends Pn{constructor(t,e,r,s){super(e,s),this._schema=t,this._typeInfo=r,this._variableUsages=new Map,this._recursiveVariableUsages=new Map}get[Symbol.toStringTag](){return"ValidationContext"}getSchema(){return this._schema}getVariableUsages(t){let e=this._variableUsages.get(t);if(!e){const r=[],s=new de(this._schema);ve(t,pe(s,{VariableDefinition:()=>!1,Variable(i){r.push({node:i,type:s.getInputType(),defaultValue:s.getDefaultValue()})}})),e=r,this._variableUsages.set(t,e)}return e}getRecursiveVariableUsages(t){let e=this._recursiveVariableUsages.get(t);if(!e){e=this.getVariableUsages(t);for(const r of this.getRecursivelyReferencedFragments(t))e=e.concat(this.getVariableUsages(r));this._recursiveVariableUsages.set(t,e)}return e}getType(){return this._typeInfo.getType()}getParentType(){return this._typeInfo.getParentType()}getInputType(){return this._typeInfo.getInputType()}getParentInputType(){return this._typeInfo.getParentInputType()}getFieldDef(){return this._typeInfo.getFieldDef()}getDirective(){return this._typeInfo.getDirective()}getArgument(){return this._typeInfo.getArgument()}getEnumValue(){return this._typeInfo.getEnumValue()}}function De(n,t,e=be,r,s=new de(n)){var i;const o=(i=void 0)!==null&&i!==void 0?i:100;t||Ge(!1,"Must provide document."),Ce(n);const a=Object.freeze({}),l=[],u=new Gn(n,t,s,d=>{if(l.length>=o)throw l.push(new p("Too many validation errors, error limit reached. Validation aborted.")),a;l.push(d)}),c=qe(e.map(d=>d(u)));try{ve(t,pe(s,c))}catch(d){if(d!==a)throw d}return l}function qn(n){return{Field(t){const e=n.getFieldDef(),r=e==null?void 0:e.deprecationReason;if(e&&r!=null){const s=n.getParentType();s!=null||D(!1),n.reportError(new p(`The field ${s.name}.${e.name} is deprecated. ${r}`,{nodes:t}))}},Argument(t){const e=n.getArgument(),r=e==null?void 0:e.deprecationReason;if(e&&r!=null){const s=n.getDirective();if(s!=null)n.reportError(new p(`Directive "@${s.name}" argument "${e.name}" is deprecated. ${r}`,{nodes:t}));else{const i=n.getParentType(),o=n.getFieldDef();i!=null&&o!=null||D(!1),n.reportError(new p(`Field "${i.name}.${o.name}" argument "${e.name}" is deprecated. ${r}`,{nodes:t}))}}},ObjectField(t){const e=I(n.getParentInputType());if(Q(e)){const r=e.getFields()[t.name.value],s=r==null?void 0:r.deprecationReason;s!=null&&n.reportError(new p(`The input field ${e.name}.${r.name} is deprecated. ${s}`,{nodes:t}))}},EnumValue(t){const e=n.getEnumValue(),r=e==null?void 0:e.deprecationReason;if(e&&r!=null){const s=I(n.getInputType());s!=null||D(!1),n.reportError(new p(`The enum value "${s.name}.${e.name}" is deprecated. ${r}`,{nodes:t}))}}}}function Yn(n,t,e,r,s){const i=be.filter(a=>!(a===Ne||a===ye));return e&&Array.prototype.push.apply(i,e),De(n,t,i).filter(a=>{if(a.message.includes("Unknown directive")&&a.nodes){const l=a.nodes[0];if(l&&l.kind===f.DIRECTIVE){const u=l.name.value;if(u==="arguments"||u==="argumentDefinitions")return!1}}return!0})}const $={Error:"Error",Warning:"Warning",Information:"Information",Hint:"Hint"},J={[$.Error]:1,[$.Warning]:2,[$.Information]:3,[$.Hint]:4},P=(n,t)=>{if(!n)throw new Error(t)};function Bn(n,t=null,e,r,s){var i,o;let a=null,l="";s&&(l=typeof s=="string"?s:s.reduce((c,d)=>c+T(d)+`

`,""));const u=l?`${n}

${l}`:n;try{a=Ye(u)}catch(c){if(c instanceof p){const d=Hn((o=(i=c.locations)===null||i===void 0?void 0:i[0])!==null&&o!==void 0?o:{line:0,column:0},u);return[{severity:J.Error,message:c.message,source:"GraphQL: Syntax",range:d}]}throw c}return Qn(a,t,e)}function Qn(n,t=null,e,r){if(!t)return[];const s=Yn(t,n,e).flatMap(o=>oe(o,J.Error,"Validation")),i=De(t,n,[qn]).flatMap(o=>oe(o,J.Warning,"Deprecation"));return s.concat(i)}function oe(n,t,e){if(!n.nodes)return[];const r=[];for(const[s,i]of n.nodes.entries()){const o=i.kind!=="Variable"&&"name"in i&&i.name!==void 0?i.name:"variable"in i&&i.variable!==void 0?i.variable:i;if(o){P(n.locations,"GraphQL validation error requires locations.");const a=n.locations[s],l=Wn(o),u=a.column+(l.end-l.start);r.push({source:`GraphQL: ${e}`,message:n.message,severity:t,range:new me(new L(a.line-1,a.column-1),new L(a.line-1,u))})}}return r}function Hn(n,t){const e=Le(),r=e.startState(),s=t.split(`
`);P(s.length>=n.line,"Query text must have more lines than where the error happened");let i=null;for(let u=0;u<n.line;u++)for(i=new ke(s[u]);!i.eol()&&e.token(i,r)!=="invalidchar";);P(i,"Expected Parser stream to be available.");const o=n.line-1,a=i.getStartOfToken(),l=i.getCurrentPosition();return new me(new L(o,a),new L(o,l))}function Wn(n){const e=n.loc;return P(e,"Expected ASTNode to have a location."),e}const le=["error","warning","information","hint"],Xn={"GraphQL: Validation":"validation","GraphQL: Deprecation":"deprecation","GraphQL: Syntax":"syntax"};q.registerHelper("lint","graphql",(n,t)=>{const{schema:e,validationRules:r,externalFragments:s}=t;return Bn(n,e,r,void 0,s).map(a=>({message:a.message,severity:a.severity?le[a.severity-1]:le[0],type:a.source?Xn[a.source]:void 0,from:q.Pos(a.range.start.line,a.range.start.character),to:q.Pos(a.range.end.line,a.range.end.character)}))});

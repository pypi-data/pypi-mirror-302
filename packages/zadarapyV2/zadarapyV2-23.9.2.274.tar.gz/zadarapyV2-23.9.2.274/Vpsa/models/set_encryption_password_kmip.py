# coding: utf-8

"""
    Zadara VPSA Storage Array REST API

     # Overview  This document outlines the methods available for administrating your Zadara Storage VPSA&#8482;. The Zadara Storage Array REST API   supports form-encoded, JSON, and XML requests, and can return either JSON or XML responses.  ## Usage  The majority of the APIs available require authentication which requires an API token to use. You can retrieve this token through the   Users section of your VPSA, or through the API using the \"Return a user's access key\" API in the Users Section below.  ## Authentication Methods  The authentication token can be passed either through the access_key parameter inside of the body of the REST API request, or   through the X-Access-Key header.  ## Timeouts  By default, all operations that don't complete within five seconds will return a message informing you that the action may take some  time to complete. When using the API, this can cause some actions, such as large volume creation, to be undesirably asynchronous.  You can specify your own timeout with the timeout parameter, in seconds, and a timeout value of -1 specifies an infinite timeout.  ## Specific Fields For Product  Some of the fields/actions used in the API should be used only for a specific product. The following tags are used to mark which   product responds to the fields/actions  VPSA Flash Array  VPSA Storage Array - Hybrid VPSA  ## Questions  If you have any questions or need support involving the REST API, please contact for assistance.   # noqa: E501

    OpenAPI spec version: 23.09-sp2
    Contact: support@zadarastorage.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from Vpsa.configuration import Configuration


class SetEncryptionPasswordKmip(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'current_encryption_pwd': 'str',
        'host': 'str',
        'key_id': 'str',
        'key_name': 'str',
        'connect_via': 'str',
        'user': 'str',
        'password': 'str',
        'port': 'int',
        'version': 'str',
        'ca_cert_file': 'str',
        'proxy_host': 'str',
        'proxyport': 'str',
        'proxy_username': 'str',
        'proxy_password': 'str',
        'key_file_content': 'str',
        'cert_file_content': 'str'
    }

    attribute_map = {
        'current_encryption_pwd': 'current_encryption_pwd',
        'host': 'host',
        'key_id': 'key_id',
        'key_name': 'key_name',
        'connect_via': 'connect_via',
        'user': 'user',
        'password': 'password',
        'port': 'port',
        'version': 'version',
        'ca_cert_file': 'ca_cert_file',
        'proxy_host': 'proxy_host',
        'proxyport': 'proxyport',
        'proxy_username': 'proxy_username',
        'proxy_password': 'proxy_password',
        'key_file_content': 'key_file_content',
        'cert_file_content': 'cert_file_content'
    }

    def __init__(self, current_encryption_pwd=None, host=None, key_id=None, key_name=None, connect_via=None, user=None, password=None, port=None, version='3', ca_cert_file='/etc/ssl/certs/DigiCert_Global_Root_CA.pem', proxy_host=None, proxyport=None, proxy_username=None, proxy_password=None, key_file_content=None, cert_file_content=None, _configuration=None):  # noqa: E501
        """SetEncryptionPasswordKmip - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._current_encryption_pwd = None
        self._host = None
        self._key_id = None
        self._key_name = None
        self._connect_via = None
        self._user = None
        self._password = None
        self._port = None
        self._version = None
        self._ca_cert_file = None
        self._proxy_host = None
        self._proxyport = None
        self._proxy_username = None
        self._proxy_password = None
        self._key_file_content = None
        self._cert_file_content = None
        self.discriminator = None

        self.current_encryption_pwd = current_encryption_pwd
        self.host = host
        self.key_id = key_id
        self.key_name = key_name
        self.connect_via = connect_via
        self.user = user
        self.password = password
        if port is not None:
            self.port = port
        if version is not None:
            self.version = version
        if ca_cert_file is not None:
            self.ca_cert_file = ca_cert_file
        if proxy_host is not None:
            self.proxy_host = proxy_host
        if proxyport is not None:
            self.proxyport = proxyport
        if proxy_username is not None:
            self.proxy_username = proxy_username
        if proxy_password is not None:
            self.proxy_password = proxy_password
        if key_file_content is not None:
            self.key_file_content = key_file_content
        if cert_file_content is not None:
            self.cert_file_content = cert_file_content

    @property
    def current_encryption_pwd(self):
        """Gets the current_encryption_pwd of this SetEncryptionPasswordKmip.  # noqa: E501

        Current master encryption password.  # noqa: E501

        :return: The current_encryption_pwd of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: str
        """
        return self._current_encryption_pwd

    @current_encryption_pwd.setter
    def current_encryption_pwd(self, current_encryption_pwd):
        """Sets the current_encryption_pwd of this SetEncryptionPasswordKmip.

        Current master encryption password.  # noqa: E501

        :param current_encryption_pwd: The current_encryption_pwd of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and current_encryption_pwd is None:
            raise ValueError("Invalid value for `current_encryption_pwd`, must not be `None`")  # noqa: E501

        self._current_encryption_pwd = current_encryption_pwd

    @property
    def host(self):
        """Gets the host of this SetEncryptionPasswordKmip.  # noqa: E501

        The KMIP host to set.  # noqa: E501

        :return: The host of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: str
        """
        return self._host

    @host.setter
    def host(self, host):
        """Sets the host of this SetEncryptionPasswordKmip.

        The KMIP host to set.  # noqa: E501

        :param host: The host of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and host is None:
            raise ValueError("Invalid value for `host`, must not be `None`")  # noqa: E501

        self._host = host

    @property
    def key_id(self):
        """Gets the key_id of this SetEncryptionPasswordKmip.  # noqa: E501

        The KMIP key UUID to set.  # noqa: E501

        :return: The key_id of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: str
        """
        return self._key_id

    @key_id.setter
    def key_id(self, key_id):
        """Sets the key_id of this SetEncryptionPasswordKmip.

        The KMIP key UUID to set.  # noqa: E501

        :param key_id: The key_id of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and key_id is None:
            raise ValueError("Invalid value for `key_id`, must not be `None`")  # noqa: E501

        self._key_id = key_id

    @property
    def key_name(self):
        """Gets the key_name of this SetEncryptionPasswordKmip.  # noqa: E501

        The KMIP key name to set.  # noqa: E501

        :return: The key_name of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: str
        """
        return self._key_name

    @key_name.setter
    def key_name(self, key_name):
        """Sets the key_name of this SetEncryptionPasswordKmip.

        The KMIP key name to set.  # noqa: E501

        :param key_name: The key_name of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and key_name is None:
            raise ValueError("Invalid value for `key_name`, must not be `None`")  # noqa: E501

        self._key_name = key_name

    @property
    def connect_via(self):
        """Gets the connect_via of this SetEncryptionPasswordKmip.  # noqa: E501

        The KMIP connection interface.  # noqa: E501

        :return: The connect_via of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: str
        """
        return self._connect_via

    @connect_via.setter
    def connect_via(self, connect_via):
        """Sets the connect_via of this SetEncryptionPasswordKmip.

        The KMIP connection interface.  # noqa: E501

        :param connect_via: The connect_via of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and connect_via is None:
            raise ValueError("Invalid value for `connect_via`, must not be `None`")  # noqa: E501
        allowed_values = ["public", "fe"]  # noqa: E501
        if (self._configuration.client_side_validation and
                connect_via not in allowed_values):
            raise ValueError(
                "Invalid value for `connect_via` ({0}), must be one of {1}"  # noqa: E501
                .format(connect_via, allowed_values)
            )

        self._connect_via = connect_via

    @property
    def user(self):
        """Gets the user of this SetEncryptionPasswordKmip.  # noqa: E501

        The KMIP username, can be used for authentication.  # noqa: E501

        :return: The user of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: str
        """
        return self._user

    @user.setter
    def user(self, user):
        """Sets the user of this SetEncryptionPasswordKmip.

        The KMIP username, can be used for authentication.  # noqa: E501

        :param user: The user of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and user is None:
            raise ValueError("Invalid value for `user`, must not be `None`")  # noqa: E501

        self._user = user

    @property
    def password(self):
        """Gets the password of this SetEncryptionPasswordKmip.  # noqa: E501

        The KMIP password, can be used for authentication.  # noqa: E501

        :return: The password of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: str
        """
        return self._password

    @password.setter
    def password(self, password):
        """Sets the password of this SetEncryptionPasswordKmip.

        The KMIP password, can be used for authentication.  # noqa: E501

        :param password: The password of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and password is None:
            raise ValueError("Invalid value for `password`, must not be `None`")  # noqa: E501

        self._password = password

    @property
    def port(self):
        """Gets the port of this SetEncryptionPasswordKmip.  # noqa: E501

        The KMIP host port to set.  # noqa: E501

        :return: The port of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: int
        """
        return self._port

    @port.setter
    def port(self, port):
        """Sets the port of this SetEncryptionPasswordKmip.

        The KMIP host port to set.  # noqa: E501

        :param port: The port of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: int
        """
        if (self._configuration.client_side_validation and
                port is not None and port > 65535):  # noqa: E501
            raise ValueError("Invalid value for `port`, must be a value less than or equal to `65535`")  # noqa: E501
        if (self._configuration.client_side_validation and
                port is not None and port < 1):  # noqa: E501
            raise ValueError("Invalid value for `port`, must be a value greater than or equal to `1`")  # noqa: E501

        self._port = port

    @property
    def version(self):
        """Gets the version of this SetEncryptionPasswordKmip.  # noqa: E501

        The KMIP version to use:  0 (for unknown)  1 (for 1.0)  2 (for 1.1)  3 (for 1.2)  4 (for 1.3)  5 (for 1.4)  6 (for 2.0)  # noqa: E501

        :return: The version of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: str
        """
        return self._version

    @version.setter
    def version(self, version):
        """Sets the version of this SetEncryptionPasswordKmip.

        The KMIP version to use:  0 (for unknown)  1 (for 1.0)  2 (for 1.1)  3 (for 1.2)  4 (for 1.3)  5 (for 1.4)  6 (for 2.0)  # noqa: E501

        :param version: The version of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: str
        """
        allowed_values = ["0", "1", "2", "3", "4", "5", "6"]  # noqa: E501
        if (self._configuration.client_side_validation and
                version not in allowed_values):
            raise ValueError(
                "Invalid value for `version` ({0}), must be one of {1}"  # noqa: E501
                .format(version, allowed_values)
            )

        self._version = version

    @property
    def ca_cert_file(self):
        """Gets the ca_cert_file of this SetEncryptionPasswordKmip.  # noqa: E501

        The location of the CA certificate file on the VPSA file system.  # noqa: E501

        :return: The ca_cert_file of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: str
        """
        return self._ca_cert_file

    @ca_cert_file.setter
    def ca_cert_file(self, ca_cert_file):
        """Sets the ca_cert_file of this SetEncryptionPasswordKmip.

        The location of the CA certificate file on the VPSA file system.  # noqa: E501

        :param ca_cert_file: The ca_cert_file of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: str
        """

        self._ca_cert_file = ca_cert_file

    @property
    def proxy_host(self):
        """Gets the proxy_host of this SetEncryptionPasswordKmip.  # noqa: E501

        The proxy host, used if setting KMIP KMS with proxy.  # noqa: E501

        :return: The proxy_host of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: str
        """
        return self._proxy_host

    @proxy_host.setter
    def proxy_host(self, proxy_host):
        """Sets the proxy_host of this SetEncryptionPasswordKmip.

        The proxy host, used if setting KMIP KMS with proxy.  # noqa: E501

        :param proxy_host: The proxy_host of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: str
        """

        self._proxy_host = proxy_host

    @property
    def proxyport(self):
        """Gets the proxyport of this SetEncryptionPasswordKmip.  # noqa: E501

        The proxy port, used if setting KMIP KMS with proxy.  # noqa: E501

        :return: The proxyport of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: str
        """
        return self._proxyport

    @proxyport.setter
    def proxyport(self, proxyport):
        """Sets the proxyport of this SetEncryptionPasswordKmip.

        The proxy port, used if setting KMIP KMS with proxy.  # noqa: E501

        :param proxyport: The proxyport of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: str
        """

        self._proxyport = proxyport

    @property
    def proxy_username(self):
        """Gets the proxy_username of this SetEncryptionPasswordKmip.  # noqa: E501

        The proxy user name, used if setting KMIP KMS with authenticated proxy.  # noqa: E501

        :return: The proxy_username of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: str
        """
        return self._proxy_username

    @proxy_username.setter
    def proxy_username(self, proxy_username):
        """Sets the proxy_username of this SetEncryptionPasswordKmip.

        The proxy user name, used if setting KMIP KMS with authenticated proxy.  # noqa: E501

        :param proxy_username: The proxy_username of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: str
        """

        self._proxy_username = proxy_username

    @property
    def proxy_password(self):
        """Gets the proxy_password of this SetEncryptionPasswordKmip.  # noqa: E501

        The proxy password, used if setting KMIP KMS with authenticated proxy.  # noqa: E501

        :return: The proxy_password of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: str
        """
        return self._proxy_password

    @proxy_password.setter
    def proxy_password(self, proxy_password):
        """Sets the proxy_password of this SetEncryptionPasswordKmip.

        The proxy password, used if setting KMIP KMS with authenticated proxy.  # noqa: E501

        :param proxy_password: The proxy_password of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: str
        """

        self._proxy_password = proxy_password

    @property
    def key_file_content(self):
        """Gets the key_file_content of this SetEncryptionPasswordKmip.  # noqa: E501

        The private key file content, can be used for authentication.  # noqa: E501

        :return: The key_file_content of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: str
        """
        return self._key_file_content

    @key_file_content.setter
    def key_file_content(self, key_file_content):
        """Sets the key_file_content of this SetEncryptionPasswordKmip.

        The private key file content, can be used for authentication.  # noqa: E501

        :param key_file_content: The key_file_content of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: str
        """

        self._key_file_content = key_file_content

    @property
    def cert_file_content(self):
        """Gets the cert_file_content of this SetEncryptionPasswordKmip.  # noqa: E501

        The KMIP certificate file content, can be used for authentication.  # noqa: E501

        :return: The cert_file_content of this SetEncryptionPasswordKmip.  # noqa: E501
        :rtype: str
        """
        return self._cert_file_content

    @cert_file_content.setter
    def cert_file_content(self, cert_file_content):
        """Sets the cert_file_content of this SetEncryptionPasswordKmip.

        The KMIP certificate file content, can be used for authentication.  # noqa: E501

        :param cert_file_content: The cert_file_content of this SetEncryptionPasswordKmip.  # noqa: E501
        :type: str
        """

        self._cert_file_content = cert_file_content

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(SetEncryptionPasswordKmip, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, SetEncryptionPasswordKmip):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, SetEncryptionPasswordKmip):
            return True

        return self.to_dict() != other.to_dict()

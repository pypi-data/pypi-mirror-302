# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *
import dataclasses

APPLY_TRANSFORMS_METADATA = Metadata(
    id="af0ab7e47649587aa2226c23dbebd40492471a49.boutiques",
    name="apply_transforms",
    package="ants",
    container_image_tag="antsx/ants:v2.5.3",
)


class ApplyTransformsWarpedOutputOutputs(typing.NamedTuple):
    """
    Output object returned when calling `ApplyTransformsWarpedOutput(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_image_outfile: OutputPathType
    """Warped image."""


@dataclasses.dataclass
class ApplyTransformsWarpedOutput:
    """
    Output the warped image.
    """
    warped_output_file_name: str
    """Output file name."""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append(self.warped_output_file_name)
        return cargs
    
    def outputs(
        self,
        execution: Execution,
    ) -> ApplyTransformsWarpedOutputOutputs:
        """
        Collect output file paths.
        
        Args:
            execution: The execution object.
        Returns:
            NamedTuple of outputs (described in `ApplyTransformsWarpedOutputOutputs`).
        """
        ret = ApplyTransformsWarpedOutputOutputs(
            root=execution.output_file("."),
            output_image_outfile=execution.output_file(self.warped_output_file_name),
        )
        return ret


class ApplyTransformsCompositeDisplacementFieldOutputOutputs(typing.NamedTuple):
    """
    Output object returned when calling `ApplyTransformsCompositeDisplacementFieldOutput(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_image_outfile: OutputPathType
    """Warped image."""


@dataclasses.dataclass
class ApplyTransformsCompositeDisplacementFieldOutput:
    """
    Print out the displacement field based on the composite transform and the
    reference image.
    """
    composite_displacement_field: str
    """Output file name."""
    print_out_composite_warp_file: typing.Literal[0, 1] | None = None
    """Output a composite warp file instead of a transformed image."""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        if self.print_out_composite_warp_file is not None:
            cargs.append("[" + self.composite_displacement_field + ",printOutCompositeWarpFile=" + str(self.print_out_composite_warp_file) + "]")
        return cargs
    
    def outputs(
        self,
        execution: Execution,
    ) -> ApplyTransformsCompositeDisplacementFieldOutputOutputs:
        """
        Collect output file paths.
        
        Args:
            execution: The execution object.
        Returns:
            NamedTuple of outputs (described in `ApplyTransformsCompositeDisplacementFieldOutputOutputs`).
        """
        ret = ApplyTransformsCompositeDisplacementFieldOutputOutputs(
            root=execution.output_file("."),
            output_image_outfile=execution.output_file(self.composite_displacement_field),
        )
        return ret


class ApplyTransformsGenericAffineTransformOutputOutputs(typing.NamedTuple):
    """
    Output object returned when calling `ApplyTransformsGenericAffineTransformOutput(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_image_outfile: OutputPathType
    """Warped image."""


@dataclasses.dataclass
class ApplyTransformsGenericAffineTransformOutput:
    """
    Compose all affine transforms and (if boolean is set) calculate its inverse
    which is then written to an ITK file.
    """
    generic_affine_transform_file: str
    """Output file name."""
    calculate_inverse: typing.Literal[0, 1] | None = None
    """Calculate the inverse of the affine transform."""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        if self.calculate_inverse is not None:
            cargs.append("Linear[" + self.generic_affine_transform_file + ",calculateInverse=" + str(self.calculate_inverse) + "]")
        return cargs
    
    def outputs(
        self,
        execution: Execution,
    ) -> ApplyTransformsGenericAffineTransformOutputOutputs:
        """
        Collect output file paths.
        
        Args:
            execution: The execution object.
        Returns:
            NamedTuple of outputs (described in `ApplyTransformsGenericAffineTransformOutputOutputs`).
        """
        ret = ApplyTransformsGenericAffineTransformOutputOutputs(
            root=execution.output_file("."),
            output_image_outfile=execution.output_file(self.generic_affine_transform_file),
        )
        return ret


@dataclasses.dataclass
class ApplyTransformsLinear:
    """
    Linear interpolation.
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append("Linear")
        return cargs


@dataclasses.dataclass
class ApplyTransformsNearestNeighbor:
    """
    Nearest neighbor interpolation.
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append("NearestNeighbor")
        return cargs


@dataclasses.dataclass
class ApplyTransformsMultiLabel:
    """
    Multi label interpolation.
    """
    sigma: float | None = None
    """Sigma value."""
    alpha: float | None = None
    """Alpha value."""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        if self.sigma is not None and self.alpha is not None:
            cargs.append("MultiLabel[" + "sigma=" + str(self.sigma) + ",alpha=" + str(self.alpha) + "]")
        return cargs


@dataclasses.dataclass
class ApplyTransformsGaussian:
    """
    Gaussian interpolation.
    """
    sigma: float | None = None
    """Sigma value."""
    alpha: float | None = None
    """Alpha value."""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        if self.sigma is not None and self.alpha is not None:
            cargs.append("Gaussian[" + "sigma=" + str(self.sigma) + ",alpha=" + str(self.alpha) + "]")
        return cargs


@dataclasses.dataclass
class ApplyTransformsBspline:
    """
    BSpline interpolation.
    """
    order: int | None = None
    """Order value."""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        if self.order is not None:
            cargs.append("BSpline[" + "order=" + str(self.order) + "]")
        return cargs


@dataclasses.dataclass
class ApplyTransformsCosineWindowedSinc:
    """
    Cosine windowed sinc interpolation.
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append("CosineWindowedSinc")
        return cargs


@dataclasses.dataclass
class ApplyTransformsWelchWindowedSinc:
    """
    Welch windowed sinc interpolation.
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append("WelchWindowedSinc")
        return cargs


@dataclasses.dataclass
class ApplyTransformsHammingWindowedSinc:
    """
    Hamming windowed sinc interpolation.
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append("HammingWindowedSinc")
        return cargs


@dataclasses.dataclass
class ApplyTransformsLanczosWindowedSinc:
    """
    Lanczos windowed sinc interpolation.
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append("LanczosWindowedSinc")
        return cargs


@dataclasses.dataclass
class ApplyTransformsGenericLabel:
    """
    Generic label interpolation.
    """
    interpolator: str | None = None
    """Interpolator value."""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        if self.interpolator is not None:
            cargs.append("GenericLabel[" + "interpolator=" + self.interpolator + "]")
        return cargs


@dataclasses.dataclass
class ApplyTransformsTransformFileName:
    """
    Transform file name.
    """
    transform_file_name: InputPathType
    """Transform file name."""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append(execution.input_file(self.transform_file_name))
        return cargs


@dataclasses.dataclass
class ApplyTransformsUseInverse:
    """
    Use inverse.
    """
    transform_file_name: InputPathType
    """Transform file name."""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append("[" + execution.input_file(self.transform_file_name) + ",useInverse]")
        return cargs


class ApplyTransformsOutputs(typing.NamedTuple):
    """
    Output object returned when calling `apply_transforms(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output: typing.Union[ApplyTransformsWarpedOutputOutputs, ApplyTransformsCompositeDisplacementFieldOutputOutputs, ApplyTransformsGenericAffineTransformOutputOutputs]
    """Outputs from `ApplyTransformsWarpedOutput` or
    `ApplyTransformsCompositeDisplacementFieldOutput` or
    `ApplyTransformsGenericAffineTransformOutput`."""


def apply_transforms(
    input_image: InputPathType,
    reference_image: InputPathType,
    output: typing.Union[ApplyTransformsWarpedOutput, ApplyTransformsCompositeDisplacementFieldOutput, ApplyTransformsGenericAffineTransformOutput],
    dimensionality: typing.Literal[2, 3, 4] | None = None,
    input_image_type: typing.Literal[0, 1, 2, 3, 4, 5] | None = None,
    interpolation: typing.Union[ApplyTransformsLinear, ApplyTransformsNearestNeighbor, ApplyTransformsMultiLabel, ApplyTransformsGaussian, ApplyTransformsBspline, ApplyTransformsCosineWindowedSinc, ApplyTransformsWelchWindowedSinc, ApplyTransformsHammingWindowedSinc, ApplyTransformsLanczosWindowedSinc, ApplyTransformsGenericLabel] | None = None,
    output_data_type: typing.Literal["char", "uchar", "short", "int", "float", "double", "default"] | None = None,
    transform: list[typing.Union[ApplyTransformsTransformFileName, ApplyTransformsUseInverse]] | None = None,
    default_value: float | None = None,
    static_cast_for_r: str | None = None,
    float_: typing.Literal[0, 1] | None = None,
    verbose: typing.Literal[0, 1] | None = None,
    runner: Runner | None = None,
) -> ApplyTransformsOutputs:
    """
    antsApplyTransforms, applied to an input image, transforms it according to a
    reference image and a transform (or a set of transforms).
    
    Author: Advanced Normalization Tools (ANTs) Contributors
    
    Args:
        input_image: Currently, the only input objects supported are image\
            objects. However, the current framework allows for warping of other\
            objects such as meshes and point sets.
        reference_image: For warping input images, the reference image defines\
            the spacing, origin, size, and direction of the output warped image.
        output: One can either output the warped image or, if the boolean is\
            set, one can print out the displacement field based on the composite\
            transform and the reference image. A third option is to compose all\
            affine transforms and (if boolean is set) calculate its inverse which\
            is then written to an ITK file.
        dimensionality: This option forces the image to be treated as a\
            specified-dimensional image. if not specified, antswarp tries to infer\
            the dimensionality from the input image.
        input_image_type: Option specifying the input image type of scalar\
            (default), vector, tensor, time series, or multi-channel. A time series\
            image is a scalar image defined by an additional dimension for the time\
            component whereas a multi-channel image is a vector image with only\
            spatial dimensions. Five-dimensional images are e.g., AFNI stats image.
        interpolation: Several interpolation options are available in ITK.\
            These have all been made available.
        output_data_type: Output image data type. This is a direct typecast;\
            output values are not rescaled. Default is to use the internal data\
            type (float or double). uchar is unsigned char; others are signed.\
            WARNING: Outputs will be incorrect (overflowed/reinterpreted) if values\
            exceed the range allowed by your choice. Note that some pixel types are\
            not supported by some image formats. e.g. int is not supported by jpg.
        transform: Several transform options are supported including all those\
            defined in the ITK library in addition to a deformation field\
            transform. The ordering of the transformations follows the ordering\
            specified on the command line. An identity transform is pushed onto the\
            transformation stack. Each new transform encountered on the command\
            line is also pushed onto the transformation stack. Then, to warp the\
            input object, each point comprising the input object is warped first\
            according to the last transform pushed onto the stack followed by the\
            second to last transform, etc. until the last transform encountered\
            which is the identity transform. Also, it should be noted that the\
            inverse transform can be accommodated with the usual caveat that such\
            an inverse must be defined by the specified transform class.
        default_value: Default voxel value to be used with input images only.\
            Specifies the voxel value when the input point maps outside the output\
            domain. With tensor input images, specifies the default voxel\
            eigenvalues.
        static_cast_for_r: Forces static cast in ReadTransform (for R).
        float_: Use float instead of double for computations.
        verbose: Verbose output.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `ApplyTransformsOutputs`).
    """
    runner = runner or get_global_runner()
    execution = runner.start_execution(APPLY_TRANSFORMS_METADATA)
    cargs = []
    cargs.append("antsApplyTransforms")
    if dimensionality is not None:
        cargs.extend([
            "--dimensionality",
            str(dimensionality)
        ])
    if input_image_type is not None:
        cargs.extend([
            "--input-image-type",
            str(input_image_type)
        ])
    cargs.extend([
        "--input",
        execution.input_file(input_image)
    ])
    cargs.extend([
        "--reference-image",
        execution.input_file(reference_image)
    ])
    cargs.extend([
        "--output",
        *output.run(execution)
    ])
    if interpolation is not None:
        cargs.extend([
            "--interpolation",
            *interpolation.run(execution)
        ])
    if output_data_type is not None:
        cargs.extend([
            "--output-data-type",
            output_data_type
        ])
    if transform is not None:
        cargs.extend([
            "--transform",
            *[a for c in [s.run(execution) for s in transform] for a in c]
        ])
    if default_value is not None:
        cargs.extend([
            "--default-value",
            str(default_value)
        ])
    if static_cast_for_r is not None:
        cargs.extend([
            "--static-cast-for-R",
            static_cast_for_r
        ])
    if float_ is not None:
        cargs.extend([
            "--float",
            str(float_)
        ])
    if verbose is not None:
        cargs.extend([
            "--verbose",
            str(verbose)
        ])
    ret = ApplyTransformsOutputs(
        root=execution.output_file("."),
        output=output.outputs(execution),
    )
    execution.run(cargs)
    return ret


__all__ = [
    "APPLY_TRANSFORMS_METADATA",
    "ApplyTransformsBspline",
    "ApplyTransformsCompositeDisplacementFieldOutput",
    "ApplyTransformsCompositeDisplacementFieldOutputOutputs",
    "ApplyTransformsCosineWindowedSinc",
    "ApplyTransformsGaussian",
    "ApplyTransformsGenericAffineTransformOutput",
    "ApplyTransformsGenericAffineTransformOutputOutputs",
    "ApplyTransformsGenericLabel",
    "ApplyTransformsHammingWindowedSinc",
    "ApplyTransformsLanczosWindowedSinc",
    "ApplyTransformsLinear",
    "ApplyTransformsMultiLabel",
    "ApplyTransformsNearestNeighbor",
    "ApplyTransformsOutputs",
    "ApplyTransformsTransformFileName",
    "ApplyTransformsUseInverse",
    "ApplyTransformsWarpedOutput",
    "ApplyTransformsWarpedOutputOutputs",
    "ApplyTransformsWelchWindowedSinc",
    "apply_transforms",
]

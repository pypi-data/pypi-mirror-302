"""
delta-complete SMT solver for linear theories over the reals
"""
from __future__ import annotations
import typing
__all__ = ['BoundPropagationType', 'Box', 'Config', 'Expression', 'Format', 'Formula', 'Interval', 'LOG_CRITICAL', 'LOG_DEBUG', 'LOG_ERROR', 'LOG_INFO', 'LOG_NONE', 'LOG_TRACE', 'LOG_WARN', 'LPMode', 'LPSolver', 'PreprocessingRunningFrequency', 'SatDefaultPhase', 'SatSolver', 'SmtResult', 'SmtSolver', 'SmtSolverOutput', 'Variable', 'VariableType', 'Variables', 'set_verbosity']
class BoundPropagationType:
    """
    Members:
    
      AUTO
    
      EQ_BINOMIAL
    
      EQ_POLYNOMIAL
    
      BOUND_POLYNOMIAL
    """
    AUTO: typing.ClassVar[BoundPropagationType]  # value = <BoundPropagationType.AUTO: 0>
    BOUND_POLYNOMIAL: typing.ClassVar[BoundPropagationType]  # value = <BoundPropagationType.BOUND_POLYNOMIAL: 3>
    EQ_BINOMIAL: typing.ClassVar[BoundPropagationType]  # value = <BoundPropagationType.EQ_BINOMIAL: 1>
    EQ_POLYNOMIAL: typing.ClassVar[BoundPropagationType]  # value = <BoundPropagationType.EQ_POLYNOMIAL: 2>
    __members__: typing.ClassVar[dict[str, BoundPropagationType]]  # value = {'AUTO': <BoundPropagationType.AUTO: 0>, 'EQ_BINOMIAL': <BoundPropagationType.EQ_BINOMIAL: 1>, 'EQ_POLYNOMIAL': <BoundPropagationType.EQ_POLYNOMIAL: 2>, 'BOUND_POLYNOMIAL': <BoundPropagationType.BOUND_POLYNOMIAL: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Box:
    @staticmethod
    @typing.overload
    def Add(*args, **kwargs) -> None:
        ...
    @typing.overload
    def Add(self, arg0: Variable) -> None:
        ...
    def __contains__(self, arg0: Variable) -> bool:
        ...
    def __getitem__(self, arg0: Variable) -> Interval:
        ...
    @typing.overload
    def __init__(self, arg0: LPSolver) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[Variable], arg1: LPSolver) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: Variable, arg1: Interval) -> None:
        ...
    def __str__(self: Config) -> str:
        ...
    @property
    def empty(self) -> bool:
        ...
    @property
    def lp_solver(self) -> LPSolver:
        ...
    @property
    def size(self) -> int:
        ...
    @property
    def variables(self) -> list[Variable]:
        ...
class Config:
    bound_implication_frequency: PreprocessingRunningFrequency
    bound_propagation_frequency: PreprocessingRunningFrequency
    bound_propagation_type: BoundPropagationType
    complete: bool
    continuous_output: bool
    csv: bool
    debug_parsing: bool
    debug_scanning: bool
    disable_expansion: bool
    enforce_check_sat: bool
    filename: str
    format: Format
    lp_mode: LPMode
    lp_solver: LPSolver
    number_of_jobs: int
    onnx_file: str
    optimize: bool
    precision: float
    produce_model: bool
    random_seed: int
    read_from_stdin: bool
    sat_default_phase: SatDefaultPhase
    sat_solver: SatSolver
    silent: bool
    simplex_sat_phase: int
    skip_check_sat: bool
    verbose_dlinear: int
    verbose_simplex: int
    verify: bool
    with_timings: bool
    @staticmethod
    def from_args(arg0: list[str]) -> Config:
        ...
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        ...
class Expression:
    __hash__: typing.ClassVar[None] = None
    def Differentiate(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def Evaluate(self) -> float:
        ...
    @typing.overload
    def Evaluate(self, arg0: dict[Variable, float]) -> float:
        ...
    def EvaluatePartial(self, arg0: dict[Variable, float]) -> Expression:
        ...
    def Expand(self) -> Expression:
        ...
    def Substitute(self, arg0: Variable, arg1: Expression) -> Expression:
        ...
    def __abs__(self) -> Expression:
        ...
    @typing.overload
    def __add__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __add__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __eq__(self, arg0: Expression) -> Formula:
        ...
    @typing.overload
    def __eq__(self, arg0: Variable) -> Formula:
        ...
    @typing.overload
    def __eq__(self, arg0: float) -> Formula:
        ...
    @typing.overload
    def __ge__(self, arg0: Expression) -> Formula:
        ...
    @typing.overload
    def __ge__(self, arg0: Variable) -> Formula:
        ...
    @typing.overload
    def __ge__(self, arg0: float) -> Formula:
        ...
    @typing.overload
    def __gt__(self, arg0: Expression) -> Formula:
        ...
    @typing.overload
    def __gt__(self, arg0: Variable) -> Formula:
        ...
    @typing.overload
    def __gt__(self, arg0: float) -> Formula:
        ...
    @typing.overload
    def __iadd__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __iadd__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __iadd__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __imul__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __imul__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __imul__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Variable) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Variable) -> None:
        ...
    @typing.overload
    def __isub__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __isub__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __isub__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __itruediv__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __itruediv__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __itruediv__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __le__(self, arg0: Expression) -> Formula:
        ...
    @typing.overload
    def __le__(self, arg0: Variable) -> Formula:
        ...
    @typing.overload
    def __le__(self, arg0: float) -> Formula:
        ...
    @typing.overload
    def __lt__(self, arg0: Expression) -> Formula:
        ...
    @typing.overload
    def __lt__(self, arg0: Variable) -> Formula:
        ...
    @typing.overload
    def __lt__(self, arg0: float) -> Formula:
        ...
    @typing.overload
    def __mul__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __mul__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __ne__(self, arg0: Expression) -> Formula:
        ...
    @typing.overload
    def __ne__(self, arg0: Variable) -> Formula:
        ...
    @typing.overload
    def __ne__(self, arg0: float) -> Formula:
        ...
    def __neg__(self) -> Expression:
        ...
    def __pos__(self) -> Expression:
        ...
    def __pow__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __radd__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> Expression:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rmul__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __rsub__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __rtruediv__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __rtruediv__(self, arg0: float) -> Expression:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __sub__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __truediv__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __truediv__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __truediv__(self, arg0: float) -> Expression:
        ...
    def to_smt2_string(self) -> str:
        ...
    def to_string(self) -> str:
        ...
class Format:
    """
    Members:
    
      AUTO
    
      SMT2
    
      MPS
    """
    AUTO: typing.ClassVar[Format]  # value = <Format.AUTO: 0>
    MPS: typing.ClassVar[Format]  # value = <Format.MPS: 2>
    SMT2: typing.ClassVar[Format]  # value = <Format.SMT2: 1>
    __members__: typing.ClassVar[dict[str, Format]]  # value = {'AUTO': <Format.AUTO: 0>, 'SMT2': <Format.SMT2: 1>, 'MPS': <Format.MPS: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Formula:
    @staticmethod
    def FALSE() -> Formula:
        ...
    @staticmethod
    def TRUE() -> Formula:
        ...
    def EqualTo(self, arg0: Formula) -> bool:
        ...
    def Evaluate(self) -> bool:
        ...
    def GetFreeVariables(self) -> Variables:
        ...
    def Substitute(self, arg0: Variable, arg1: Expression) -> Formula:
        ...
    @typing.overload
    def __eq__(self, arg0: Formula) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Variable) -> Formula:
        ...
    def __hash__(self) -> int:
        ...
    def __init__(self, arg0: Variable) -> None:
        ...
    @typing.overload
    def __ne__(self, arg0: Formula) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: Variable) -> Formula:
        ...
    def __nonzero__(self) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def to_smt2_string(self) -> str:
        ...
    def to_string(self) -> str:
        ...
class Interval:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    @typing.overload
    def __add__(*args, **kwargs) -> Interval:
        ...
    @staticmethod
    @typing.overload
    def __init__(*args, **kwargs) -> None:
        ...
    @staticmethod
    @typing.overload
    def __init__(*args, **kwargs) -> None:
        ...
    @staticmethod
    @typing.overload
    def __mul__(*args, **kwargs) -> Interval:
        ...
    @staticmethod
    @typing.overload
    def __sub__(*args, **kwargs) -> Interval:
        ...
    @staticmethod
    @typing.overload
    def __truediv__(*args, **kwargs) -> Interval:
        ...
    @staticmethod
    def bisect(*args, **kwargs) -> tuple[Interval, Interval]:
        ...
    @typing.overload
    def __add__(self, arg0: Interval) -> Interval:
        ...
    def __eq__(self, arg0: Interval) -> bool:
        ...
    @typing.overload
    def __mul__(self, arg0: Interval) -> Interval:
        ...
    def __str__(self: Config) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: Interval) -> Interval:
        ...
    @typing.overload
    def __truediv__(self, arg0: Interval) -> Interval:
        ...
    def set_empty(self) -> None:
        ...
    @property
    def diam(self) -> float:
        ...
    @property
    def is_bisectable(self) -> bool:
        ...
    @property
    def is_degenerated(self) -> bool:
        ...
    @property
    def is_empty(self) -> bool:
        ...
    @property
    def lb(self) -> float:
        ...
    @property
    def ub(self) -> float:
        ...
class LPMode:
    """
    Members:
    
      AUTO
    
      PURE_PRECISION_BOOSTING
    
      PURE_ITERATIVE_REFINEMENT
    
      HYBRID
    """
    AUTO: typing.ClassVar[LPMode]  # value = <LPMode.AUTO: 0>
    HYBRID: typing.ClassVar[LPMode]  # value = <LPMode.HYBRID: 3>
    PURE_ITERATIVE_REFINEMENT: typing.ClassVar[LPMode]  # value = <LPMode.PURE_ITERATIVE_REFINEMENT: 2>
    PURE_PRECISION_BOOSTING: typing.ClassVar[LPMode]  # value = <LPMode.PURE_PRECISION_BOOSTING: 1>
    __members__: typing.ClassVar[dict[str, LPMode]]  # value = {'AUTO': <LPMode.AUTO: 0>, 'PURE_PRECISION_BOOSTING': <LPMode.PURE_PRECISION_BOOSTING: 1>, 'PURE_ITERATIVE_REFINEMENT': <LPMode.PURE_ITERATIVE_REFINEMENT: 2>, 'HYBRID': <LPMode.HYBRID: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class LPSolver:
    """
    Members:
    
      QSOPTEX
    
      SOPLEX
    """
    QSOPTEX: typing.ClassVar[LPSolver]  # value = <LPSolver.QSOPTEX: 1>
    SOPLEX: typing.ClassVar[LPSolver]  # value = <LPSolver.SOPLEX: 0>
    __members__: typing.ClassVar[dict[str, LPSolver]]  # value = {'QSOPTEX': <LPSolver.QSOPTEX: 1>, 'SOPLEX': <LPSolver.SOPLEX: 0>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class PreprocessingRunningFrequency:
    """
    Members:
    
      AUTO
    
      NEVER
    
      ON_FIXED
    
      ON_ITERATION
    
      ALWAYS
    """
    ALWAYS: typing.ClassVar[PreprocessingRunningFrequency]  # value = <PreprocessingRunningFrequency.ALWAYS: 4>
    AUTO: typing.ClassVar[PreprocessingRunningFrequency]  # value = <PreprocessingRunningFrequency.AUTO: 0>
    NEVER: typing.ClassVar[PreprocessingRunningFrequency]  # value = <PreprocessingRunningFrequency.NEVER: 1>
    ON_FIXED: typing.ClassVar[PreprocessingRunningFrequency]  # value = <PreprocessingRunningFrequency.ON_FIXED: 2>
    ON_ITERATION: typing.ClassVar[PreprocessingRunningFrequency]  # value = <PreprocessingRunningFrequency.ON_ITERATION: 3>
    __members__: typing.ClassVar[dict[str, PreprocessingRunningFrequency]]  # value = {'AUTO': <PreprocessingRunningFrequency.AUTO: 0>, 'NEVER': <PreprocessingRunningFrequency.NEVER: 1>, 'ON_FIXED': <PreprocessingRunningFrequency.ON_FIXED: 2>, 'ON_ITERATION': <PreprocessingRunningFrequency.ON_ITERATION: 3>, 'ALWAYS': <PreprocessingRunningFrequency.ALWAYS: 4>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class SatDefaultPhase:
    """
    Members:
    
      RANDOM_INITIAL_PHASE
    
      FALSE
    
      TRUE
    
      JEROS_LOW_WANG
    """
    FALSE: typing.ClassVar[SatDefaultPhase]  # value = <SatDefaultPhase.FALSE: 0>
    JEROS_LOW_WANG: typing.ClassVar[SatDefaultPhase]  # value = <SatDefaultPhase.JEROS_LOW_WANG: 2>
    RANDOM_INITIAL_PHASE: typing.ClassVar[SatDefaultPhase]  # value = <SatDefaultPhase.RANDOM_INITIAL_PHASE: 3>
    TRUE: typing.ClassVar[SatDefaultPhase]  # value = <SatDefaultPhase.TRUE: 1>
    __members__: typing.ClassVar[dict[str, SatDefaultPhase]]  # value = {'RANDOM_INITIAL_PHASE': <SatDefaultPhase.RANDOM_INITIAL_PHASE: 3>, 'FALSE': <SatDefaultPhase.FALSE: 0>, 'TRUE': <SatDefaultPhase.TRUE: 1>, 'JEROS_LOW_WANG': <SatDefaultPhase.JEROS_LOW_WANG: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class SatSolver:
    """
    Members:
    
      PICOSAT
    
      CADICAL
    """
    CADICAL: typing.ClassVar[SatSolver]  # value = <SatSolver.CADICAL: 0>
    PICOSAT: typing.ClassVar[SatSolver]  # value = <SatSolver.PICOSAT: 1>
    __members__: typing.ClassVar[dict[str, SatSolver]]  # value = {'PICOSAT': <SatSolver.PICOSAT: 1>, 'CADICAL': <SatSolver.CADICAL: 0>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class SmtResult:
    """
    Members:
    
      SAT
    
      DELTA_SAT
    
      UNSAT
    
      ERROR
    
      UNKNOWN
    
      UNSOLVED
    
      SKIP_SAT
    """
    DELTA_SAT: typing.ClassVar[SmtResult]  # value = <SmtResult.DELTA_SAT: 3>
    ERROR: typing.ClassVar[SmtResult]  # value = <SmtResult.ERROR: 10>
    SAT: typing.ClassVar[SmtResult]  # value = <SmtResult.SAT: 2>
    SKIP_SAT: typing.ClassVar[SmtResult]  # value = <SmtResult.SKIP_SAT: 1>
    UNKNOWN: typing.ClassVar[SmtResult]  # value = <SmtResult.UNKNOWN: 9>
    UNSAT: typing.ClassVar[SmtResult]  # value = <SmtResult.UNSAT: 8>
    UNSOLVED: typing.ClassVar[SmtResult]  # value = <SmtResult.UNSOLVED: 0>
    __members__: typing.ClassVar[dict[str, SmtResult]]  # value = {'SAT': <SmtResult.SAT: 2>, 'DELTA_SAT': <SmtResult.DELTA_SAT: 3>, 'UNSAT': <SmtResult.UNSAT: 8>, 'ERROR': <SmtResult.ERROR: 10>, 'UNKNOWN': <SmtResult.UNKNOWN: 9>, 'UNSOLVED': <SmtResult.UNSOLVED: 0>, 'SKIP_SAT': <SmtResult.SKIP_SAT: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class SmtSolver:
    def Assert(self, assertion: Formula) -> None:
        ...
    def CheckSat(self) -> SmtSolverOutput:
        ...
    def GetExpected(self) -> SmtResult:
        ...
    def GetInfo(self, key: str) -> str:
        ...
    def GetOption(self, key: str) -> str:
        ...
    @typing.overload
    def Parse(self) -> SmtSolverOutput:
        ...
    @typing.overload
    def Parse(self, filename: str) -> SmtSolverOutput:
        ...
    def Verify(self, arg0: Box) -> bool:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Config) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: str) -> None:
        ...
class SmtSolverOutput:
    def __str__(self) -> str:
        ...
    def matched_expectation(self, arg0: SmtResult) -> bool:
        ...
    @property
    def actual_precision(self) -> float:
        ...
    @property
    def cnfizer_time(self) -> float:
        ...
    @property
    def complete_model(self) -> Box:
        ...
    @property
    def exit_code(self) -> int:
        ...
    @property
    def is_sat(self) -> bool:
        ...
    @property
    def ite_time(self) -> float:
        ...
    @property
    def lower_bound(self) -> float:
        ...
    @property
    def model(self) -> Box:
        ...
    @property
    def n_assertions(self) -> int:
        ...
    @property
    def parser_time(self) -> float:
        ...
    @property
    def precision(self) -> float:
        ...
    @property
    def precision_upper_bound(self) -> float:
        ...
    @property
    def predicate_abstractor(self) -> float:
        ...
    @property
    def preprocessor_time(self) -> float:
        ...
    @property
    def produce_models(self) -> bool:
        ...
    @property
    def result(self) -> SmtResult:
        ...
    @property
    def sat_time(self) -> float:
        ...
    @property
    def theory_time(self) -> float:
        ...
    @property
    def upper_bound(self) -> float:
        ...
    @property
    def with_timings(self) -> bool:
        ...
class Variable:
    def __abs__(self) -> Expression:
        ...
    @typing.overload
    def __add__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __eq__(self, arg0: Variable) -> Formula:
        ...
    @typing.overload
    def __eq__(self, arg0: float) -> Formula:
        ...
    @typing.overload
    def __ge__(self, arg0: Variable) -> Formula:
        ...
    @typing.overload
    def __ge__(self, arg0: float) -> Formula:
        ...
    @typing.overload
    def __gt__(self, arg0: Variable) -> Formula:
        ...
    @typing.overload
    def __gt__(self, arg0: float) -> Formula:
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self, arg0: str) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: str, arg1: VariableType) -> None:
        ...
    @typing.overload
    def __le__(self, arg0: Variable) -> Formula:
        ...
    @typing.overload
    def __le__(self, arg0: float) -> Formula:
        ...
    @typing.overload
    def __lt__(self, arg0: Variable) -> Formula:
        ...
    @typing.overload
    def __lt__(self, arg0: float) -> Formula:
        ...
    @typing.overload
    def __mul__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __ne__(self, arg0: Variable) -> Formula:
        ...
    @typing.overload
    def __ne__(self, arg0: float) -> Formula:
        ...
    def __neg__(self) -> Expression:
        ...
    def __pos__(self) -> Expression:
        ...
    def __pow__(self, arg0: Expression) -> Expression:
        ...
    def __radd__(self, arg0: float) -> Expression:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Expression:
        ...
    def __rsub__(self, arg0: float) -> Expression:
        ...
    def __rtruediv__(self, arg0: float) -> Expression:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __truediv__(self, arg0: Variable) -> Expression:
        ...
    @typing.overload
    def __truediv__(self, arg0: float) -> Expression:
        ...
    def get_id(self) -> int:
        ...
    def get_type(self) -> VariableType:
        ...
class VariableType:
    """
    Members:
    
      Real
    
      Int
    
      Bool
    
      Binary
    """
    Binary: typing.ClassVar[VariableType]  # value = <VariableType.Binary: 2>
    Bool: typing.ClassVar[VariableType]  # value = <VariableType.Bool: 3>
    Int: typing.ClassVar[VariableType]  # value = <VariableType.Int: 1>
    Real: typing.ClassVar[VariableType]  # value = <VariableType.Real: 0>
    __members__: typing.ClassVar[dict[str, VariableType]]  # value = {'Real': <VariableType.Real: 0>, 'Int': <VariableType.Int: 1>, 'Bool': <VariableType.Bool: 3>, 'Binary': <VariableType.Binary: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Variables:
    def IsStrictSubsetOf(self, arg0: Variables) -> bool:
        ...
    def IsStrictSupersetOf(self, arg0: Variables) -> bool:
        ...
    def IsSubsetOf(self, arg0: Variables) -> bool:
        ...
    def IsSupersetOf(self, arg0: Variables) -> bool:
        ...
    @typing.overload
    def __add__(self, arg0: Variables) -> Variables:
        ...
    @typing.overload
    def __add__(self, arg0: Variable) -> Variables:
        ...
    def __contains__(self, arg0: Variable) -> bool:
        ...
    def __eq__(self, arg0: Variables) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[Variable]) -> None:
        ...
    def __iter__(self) -> typing.Iterator[Variable]:
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, arg0: Variables) -> bool:
        ...
    def __radd__(self, arg0: Variable) -> Variables:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: Variables) -> Variables:
        ...
    @typing.overload
    def __sub__(self, arg0: Variable) -> Variables:
        ...
    def empty(self) -> bool:
        ...
    @typing.overload
    def erase(self, arg0: Variable) -> int:
        ...
    @typing.overload
    def erase(self, arg0: Variables) -> int:
        ...
    def include(self, arg0: Variable) -> bool:
        ...
    @typing.overload
    def insert(self, arg0: Variable) -> None:
        ...
    @typing.overload
    def insert(self, arg0: Variables) -> None:
        ...
    def size(self) -> int:
        ...
    def to_string(self) -> str:
        ...
def set_verbosity(arg0: int) -> None:
    ...
LOG_CRITICAL: int = 0
LOG_DEBUG: int = 4
LOG_ERROR: int = 1
LOG_INFO: int = 3
LOG_NONE: int = -1
LOG_TRACE: int = 5
LOG_WARN: int = 2
__version__: str = '0.0.1'
